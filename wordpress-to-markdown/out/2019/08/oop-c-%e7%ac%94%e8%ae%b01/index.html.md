---
layout: post
title: OOP-C++笔记-1
date: 2019-08-27
tags: ["基础__OOP-C++"]
---

<!-- wp:code -->

    提前声明: temp 均为变量

    第二章C++对C的改进及拓展
    2.1 函数中一些基本控制的区别{
        2.1.1 C++I/O流{
            "流" : 将数据从一个对象到另一个对象的流动抽象为"流"
            提取符: ">>"
            插入符: "<<"
        }
        2.1.2 注释
        2.1.3 const{
            用const定义只读变量,而不是宏定义,安全.
            课本写到 : 缺省"常量类型",默认为int,注意!!!VS和CB测试后均提示"C++不支持默认int"
            符号常量有地址,可以有指针指向,但不能修改常量值;
        }
        2.1.4 强制类型转换{
            static_cast
            const_cast
            dynamic_cast
            reinterpret_cast
        }
        2.1.5 bool{
            可以使用boollalpha操纵符使其输出为true/false.
            用法: 
                cout << boolalpha << temp; 
            流操纵符 : 控制输入输出格式的一类函数
        }
        2.1.6 名称(字)空间{
            格式:
                namespace 名称 { ... ; }
            使用方法:{
                1.using namespace ...; 之后可以随便使用,无需"::"
                2.使用域解析符(或称作用域运算)"::". 例: std::cin >> temp
                3.using namespace 名称::局部内容(相当于"解析"了部分东西,不能全部使用)
            }
        }
    }
    2.2有关函数的区别{
        2.2.1 局部变量随用随定义
        2.2.2 域解析符::扩大全局变量的范围{
            局部变量与全局变量重名时,局部变量优先级高,但我们此时仍要用全局变量,就要使用"::"
            用法:
                ::temp = ... ;
            (局部变量全局变量重名后还要用全局变量是只有沙雕才会做出来的事,请不要做沙雕)
        }
        2.2.3 形式参数可带有默认值{
            一般的写法 : f(int a ,int b ,int c)
            现在可以写成 : f(int a , int b = 1, int c = 2) (注意这里缺省是有顺序的,请自己测试)
            并且在使用的时候可以不传 b 和 c 的值 : f(5);
            而不会提示 "E0165 函数调用中的参数太少".
        }
        2.2.4 内联函数{
            函数前面增加关键字 inline , 该函数就成为内联函数
            内联函数与宏定义相似, 但更安全.
            注意,内联函数虽然是函数,但只能处理很简单的操作.
            请不要妄想将所有函数前面都加inline去提高程序运行速度
            这种做法,貌似很厉害(我也这么写过)
            实际上,计算机会识别函数复杂程度, 基本上, 只有不超过2行内容的函数才会成功转化为内联函数,其他的....emm,写了和没写一模一样...
        }
        2.2.5 函数重载{
            定义:对于功能完全相同或类似,只是在形式参数的个数,类型,顺序仿麦呢有区别的不同函数以相同函数名来命名,该同名函数称为被重载(Overload)
            f(int = 3) 与 f() 不可.
            上面这个函数()中的东西很奇怪,意思是你可以传入参数也可以不传参数,参数默认==3,没法引用,没有用.
        }
    }
    2.3 新增引用的灵活运用{
        引用(Reference)在声明时通过&来标记,用来为变量起别名
        2.3.1 引用的概念及使用{
            使用时,不会为其另外分配空间
            不能建立引用的引用,引用的指针,引用数组,总之,引用是最后一级.并且,引用和原变量是"绑定"的(一个值变,都变!)
        }
        2.3.2 引用作为形式参数{
            最常用的方法,标准的称为,扩大实际参数变量的作用域.(多定义全局变量可以省事很多)
            const int &temp 常引用,只能访问,不能修改,安全
        }
        2.3.3 引用与指针的区别{
            区别较大,却又功能相似.
            可以理解为引用是有限制的简化的指针,所以引用深受C++程序员青睐,但指针...你懂的.

        }
        2.3.4 引用作为返回值{
            int& f(){ ...; }
        }
    }
    2.4 动态内存空间管理{
        2.4.1 用new申请动态空间{
            int *pre;
            C风格{
                pre = (int*)malloc(10*sizeof(int));
                pre = (int*)calloc(10,sizeof(int));
                free;
            }
        }
        2.4.2 用delete释放动态内存空间{
            C++风格{
                (new是运算符而不是库函数)
                pre = new int;
                pre = new int[10];
                delete []pre;
                delete pre;
            }
            注意! 尽可能使用new & delete,因为malloc&free对于C++中的一些东西(构造/析构函数)不支持!
        }
        2.4.3 void类型的指针{
            1.可以定义void类型的指针,但是不能定义void类型的变量或引用
            用法:{
                void *temp;
                char c = 'A';
                temp = &c;
                cout << *(char *)temp << endl;  // 这个地方转成什么类型就再显示转换回什么类型,写别的类型输出不正确
            }
        }
    }
    2.5 C++语言中的异常处理{
        2.5.1 异常和异常处理{
            RE; runtime error 运行错误
            CE; complier error 编译错误
        }
        2.5.2 异常处理的实现{
            3步:{
                1.检查异常(使用try)
                2.抛出异常(使用throw)
                3.捕捉异常(使用catch)
                catch(...)
                "..."不是省略号,而是可变参数列表,能用于捕捉所有异常
            }
        }
    }

    2019-8-28

<!-- /wp:code -->