---
layout: post
title: OOP-C++笔记-2
date: 2019-08-29
tags: ["基础__OOP-C++"]
---

<!-- wp:code -->

    第三章类与对象
    3.1 类的定义{
        3.1.1 类的定义{
            类: 将不同的数据和这些数据相关的操作封装在一起的集合体
            类包含两部分: 数据成员 和 成员函数
            注意 : 在类的定义中不能对数据成员直接进行初始化(尽管程序可以运行)
            成员函数的写法{
                1.放在class中 : void 函数名() (自动视为内联函数) 
                2.放在class外 : void 类名::函数名()
            }
            访问属性
            访问权限修饰符/访问控制修饰符 : public,private,protected
            private 私有成员 只允许该类的成员和友元访问, 不能被其他函数访问
            protected 保护成员 既允许该类的成员函数和友元访问, 又允许其派生类的成员函数访问
            public 公有成员 既允许该类的成员函数访问, 也允许类外部的其他函数访问
            class 和 struct 的区别, 结构体默认访问属性为public , 类默认访问属性为private.
        }
        3.1.2 定义对象{
            对象是类的实例或实体,类本身是抽象的,只有定义了对象,系统才会给对象分配相应的储存空间
        }
        3.1.3 this指针{
            this指针用来存放当前对象的地址,从而使得不同对象调用同意成员函数所处理的是自己的数据成员,不会造成混乱
        }
    }
    3.2 构造函数和析构函数{
        属性均必须为public.
        构造函数 : 在定义类的对象时,为其所属类分配储存空间,并初始化
        析构函数 : 在对象身份期结束时,完成对象存储空间的回收和相关的善后事务
        3.2.1 构造函数{
            1.如果构造函数有实际参数表,那么在创建对象时就必须要给出构造函数需要的实际参数表:{
                形式1:
                class{
                    Date(int ,int )
                }
                ...
                Date today(1,5);
                -----------------
                形式2:
                class{
                    Date()
                }
                ...
                Date today;
            }                 
            下面这条语句:                       
                today = Date(2,3);
            构造函数无法直接调用,只能在创建对象时自动调用,而这一句是在定义一个无名对象.
            2.任何类的对象在建立时必定要自动调用构造函数,如果没有程序员定义的构造函数,系统将会默认构造函数,其作用就只有分配空间,该函数无任何参数和语句,空壳子.
            构造函数可重载.
            3.具有默认参数值的构造函数 : Date(int a = 1 ,int b = 2) ,此时传入0个,1个或2个参数均可.
            4.构造拷贝函数 : Date(const Date & d)
            构造拷贝函数是一类特殊的构造函数,它能够用一个已知的对象初始化另一方个新建的同类新对象.
            用户可以根据需要定义自己的拷贝构造函数,从而实现同类对象之间数据成员的值传递
            注意! : Date d2 = d1 ; 等效于 Date d2(d1); 这不是一个赋值语句!!!
            d2 = d1; 才是一个赋值语句
            此处注意到 : 没有写拷贝构造函数 Date d2 = d1; 也成功运行,百度后得知:编译器也能默认生成拷贝构造函数,此处进行浅拷贝.
            >>>浅拷贝/深拷贝后面将会学到,先搁置
            调用拷贝构造函数的三种情况{
                1.明确表示有一个对象初始化另一个对象 : Date d2(d1);
                2.当对象作为参数的实际参数传递给函数的值形式参数(注意,如果形式参数是引用参数或指针参数,都不会调用拷贝构造函数,因为此时不会产生新对象) :Date f(Date d) {...}
                3.当对象作为函数返回值
            }
        }
        3.2.2 析构函数{
            形式{
                类内:
                    ~类名();
                类外:
                    类名::~类名(){...}
            }
            析构函数无形式参数,并且不能被重载
            自动调用
            两种情况下调用{
                1.对象生存期结束时
                2.对用new运算符动态创建的对象,再用delete释放时.(别忘了,free/malloc在析构/构造函数中不能用!)
            }
            一般用默认的析构函数就可以了,但是,当类中有指针类型的数据成员,并且在构造函数中用该指针申请了空间,此时一定要自定义析构函数来释放这些空间,保证对象生存期结束时,所有空间被释放了!
        }
    }
    3.3 深拷贝与浅拷贝{
        浅拷贝造成指针悬挂问题:两个同类对象,类中有指针,并且构造函数为指针变量申请了空间,浅拷贝时,两个对象中的指针变量指向同一块地址,一旦,其中一个对象调用了析构函数,该地址空间被释放,另一个对象的指针成员变量就无法访问该空间了,从而导致出错.
        解决方法 : 深拷贝 : 另外申请动态空间后,再复制对应动态空间中的内容.(new)
    }
    3.4 对象的使用{
        ......;
    }
    3.5 友元{
        友元的三种形式{
            1.一个不属于任何类的普通函数声明为当前类的友元,称为当前类的友元函数
            2.一个其他类的成员函数声明为当前类的友元,称为当前类的友元成员
            3.另一个类声明为当前类的友元,称为当前类的友元类
        }
        3.5.1 友元函数{
            friend 函数返回类型 函数名 (形式参数表)
            友元函数要在类内给出声明(之后定义时,不能再加friend),或者直接给出定义,不受访问属性的约束.
        }
        3.5.2 友元成员{
            friend void Date::diaplay(const Student &);
            友元成员不仅可以访问自己所在类的所有成员,也可以访问friend声明所在类的所有成员,这样,可以使两个类共享数据,相互合作.
        }
        3.5.3 友元类{
            friend 类名;
            友元关系是单向的,也不存在传递性.
        }
        使用友元可以避免频繁的调用接口函数,提高程序运行速度和运行效率.
    }
    3.6 程序实例-学生信息管理系统

    2019-8-29

<!-- /wp:code -->