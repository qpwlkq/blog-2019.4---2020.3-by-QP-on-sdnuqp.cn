---
layout: post
title: [专题二：搜索进阶]ZOJ - 2477-Magic Cube-IDA_Star
date: 2019-06-03
tags: ["kuangbin专题","题解"]
---

<!-- wp:code -->

    这个题可以用BFS，我本来写的BFS，但是！！！12次旋转太难写了！！！把我写崩了，提前打表的IDA*，这个表也不好打呀，出题人意图何在！？

    #include<cstdio>
    #include<algorithm>
    #include<iostream>
    #include<cstring>
    #include<cmath>

    using namespace std;

    int n,m,depth;
    int ans[10],dir[10];
    char a[100];

    int centre[6]= {5,23,26,29,32,50};
    int row[6][10] = {
        {1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 },
        {10, 11, 12, 22, 23, 24, 34, 35, 36},
        {13, 14, 15, 25, 26, 27, 37, 38, 39},
        {16, 17, 18, 28, 29, 30, 40, 41, 42},
        {19, 20, 21, 31, 32, 33, 43, 44, 45},
        {46, 47, 48, 49, 50, 51, 52, 53, 54}
    };

    int change[12][20]= { //12表示12种操作，20是因为每一种操作都会导致20个格子发生变化;
        {12, 24, 36, 35, 34, 22, 10, 11, 13, 25, 37, 46, 49, 52, 45, 33, 21, 1, 4, 7},
        {10, 11, 12, 24, 36, 35, 34, 22, 1, 4, 7, 13, 25, 37, 46, 49, 52, 45, 33, 21},
        {15, 27, 39, 38, 37, 25, 13, 14, 16, 28, 40, 48, 47, 46, 36, 24, 12, 7, 8, 9},
        {13, 14, 15, 27, 39, 38, 37, 25, 7, 8, 9, 16, 28, 40, 48, 47, 46, 36, 24, 12},
        {18, 30, 42, 41, 40, 28, 16, 17, 19, 31, 43, 54, 51, 48, 39, 27, 15, 9, 6, 3},
        {16, 17, 18, 30, 42, 41, 40, 28, 9, 6, 3, 19, 31, 43, 54, 51, 48, 39, 27, 15},
        {21, 33, 45, 44, 43, 31, 19, 20, 3, 2, 1, 10, 22, 34, 52, 53, 54, 42, 30, 18},
        {19, 20, 21, 33, 45, 44, 43, 31, 42, 30, 18, 3, 2, 1, 10, 22, 34, 52, 53, 54},
        {3, 6, 9, 8, 7, 4, 1, 2, 18, 17, 16, 15, 14, 13, 12, 11, 10, 21, 20, 19},
        {1, 2, 3, 6, 9, 8, 7, 4, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10},
        {48, 51, 54, 53, 52, 49, 46, 47, 40, 41, 42, 43, 44, 45, 34, 35, 36, 37, 38, 39},
        {46, 47, 48, 51, 54, 53, 52, 49, 37, 38, 39, 40, 41, 42, 43, 44, 45, 34, 35, 36}
    };

    int geth() {
        int sum=0;
        for(int i=0; i<6; i++) {
            for(int j=0; j<9; j++)
                if(a[row[i][j]]!=a[centre[i]])
                    sum++;
        }
        return sum;
    }

    int solve(int d) {
        int h=geth();
        if(d+ceil(h/12.0)>depth)
            return 0;
        if(h==0)
            return 1;
        char maze[100];
        //memcpy(maze,a,sizeof(a));
        for(int i=0; i<12; i++) {
            memcpy(maze,a,sizeof(a));
            for(int j = 0; j < 20; j++)
                a[change[i][j]] = maze[change[i^1][j]];//这里的^是用来如果i为偶数则+1，若为奇数则i-1，这样使得在减小代码量的前提下进行魔方位置的模拟。

            ans[d]=i/2;

            if(!(i&1))
                dir[d]=1;
            else
                dir[d]=-1;
            if(solve(d+1))
                return 1;
            memcpy(a,maze,sizeof(maze));
        }
        return 0;
    }

    int main() {
        int t;
        scanf("%d",&t);
        while(t--) {
            for(int i=1; i<=54; i++)
                cin>>a[i];
            if(!geth()) {
                printf("0\n");
                continue;
            }
            for(depth=1; depth<=5; depth++)
                if(solve(0))
                    break;
            if(depth==6)
                printf("-1\n");
            else {
                printf("%d\n",depth);
                for(int i=0; i<depth; i++)
                    printf("%d %d\n",ans[i],dir[i]);
            }
        }
        return 0;
    }

<!-- /wp:code -->