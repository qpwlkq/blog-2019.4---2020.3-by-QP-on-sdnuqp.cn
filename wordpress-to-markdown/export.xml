<?xml version="1.0" encoding="UTF-8" ?>
<!-- This is a WordPress eXtended RSS file generated by WordPress as an export of your site. -->
<!-- It contains information about your site's posts, pages, comments, categories, and other content. -->
<!-- You may use this file to transfer that content from one site to another. -->
<!-- This file is not intended to serve as a complete backup of your site. -->

<!-- To import this information into a WordPress site follow these steps: -->
<!-- 1. Log in to that site as an administrator. -->
<!-- 2. Go to Tools: Import in the WordPress admin panel. -->
<!-- 3. Install the "WordPress" importer from the list. -->
<!-- 4. Activate & Run Importer. -->
<!-- 5. Upload this file using the form provided on that page. -->
<!-- 6. You will first be asked to map the authors in this export file to users -->
<!--    on the site. For each author, you may choose to map to an -->
<!--    existing user on the site or to create a new user. -->
<!-- 7. WordPress will then import each of the posts, pages, comments, categories, etc. -->
<!--    contained in this file into your site. -->

	<!-- generator="WordPress/5.2.5" created="2020-04-13 14:18" -->
<rss version="2.0"
	xmlns:excerpt="http://wordpress.org/export/1.2/excerpt/"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:wp="http://wordpress.org/export/1.2/"
>

<channel>
	<title>浮生若梦</title>
	<link>https://sdnuqp.cn</link>
	<description>welcome to my blog</description>
	<pubDate>Mon, 13 Apr 2020 14:18:34 +0000</pubDate>
	<language>zh-CN</language>
	<wp:wxr_version>1.2</wp:wxr_version>
	<wp:base_site_url>https://sdnuqp.cn</wp:base_site_url>
	<wp:base_blog_url>https://sdnuqp.cn</wp:base_blog_url>

		<wp:author><wp:author_id>2</wp:author_id><wp:author_login><![CDATA[wlkq]]></wp:author_login><wp:author_email><![CDATA[1047907457@qq.com]]></wp:author_email><wp:author_display_name><![CDATA[秦, 鹏]]></wp:author_display_name><wp:author_first_name><![CDATA[鹏]]></wp:author_first_name><wp:author_last_name><![CDATA[秦]]></wp:author_last_name></wp:author>

				
	<generator>https://wordpress.org/?v=5.2.5</generator>

<image>
	<url>https://sdnuqp.cn/wp-content/uploads/2019/03/cropped-1551276821458-5-32x32.jpg</url>
	<title>浮生若梦</title>
	<link>https://sdnuqp.cn</link>
	<width>32</width>
	<height>32</height>
</image> 
<site xmlns="com-wordpress:feed-additions:1">160314186</site>
		<item>
		<title>char型数组 &amp; str兄弟会（sprintf&amp;sscanf）</title>
		<link>https://sdnuqp.cn/char%e5%9e%8b%e6%95%b0%e7%bb%84-str%e5%85%84%e5%bc%9f%e4%bc%9a%ef%bc%88sprintfsscanf%ef%bc%89/</link>
		<pubDate>Fri, 29 Mar 2019 13:22:36 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=137</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:heading {"level":1} -->
<h1>char型数组也是很有意思的东西，它像string一样有很多函数or操作or算法</h1>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>尽量不要用gets()函数输入，这是个哲学问题。。。。。。Orz</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>1-1 sscanf和sprintf函数，面向字符串的输入输出流</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>在我看来就是从字符串中输入数据，而不是像scanf从键盘键入数据。详见百度百科</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>1-1-1 sscanf函数</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p><em>sscanf 读取格式化的字符串中的数据</em>--百度百科</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>TA常用来字符串和数字的转换，很好使，不用自己系一大堆代码了。Orz。。。</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>int main(){    
//    s="0123456789";

    char ss[100]="123abc(DEFghijk)";
    char sss[100]="z123abc(DEFghijk)";
    char ss1[100];
    char ss2[100];
    char ss3[100];
    char ss4[100];
    char ss5[100];
    sscanf(ss,"%s",ss1);//1
    sscanf(ss,"%8s",ss2);//2
    sscanf(ss,"%[^(]",ss3);//3
    sscanf(ss,"%[^a-z]",ss4);//4
    sscanf(ss,"%[1-9,a-z,A-Z,(]",ss5);//5

    int x;
    cout&lt;&lt;x&lt;&lt;'\n';

    sscanf(ss,"%d",&amp;x);///传地址

    cout&lt;&lt;x&lt;&lt;'\n';
    puts(ss1);
    puts(ss2);
    puts(ss3);
    puts(ss4);
    puts(ss5);
}
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>输出：</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>0
123
123abc(DEFghijk)
123abc(D
123abc
123
123abc(DEFghijk</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>这个函数中间参数有很多，什么转化为16进制，8进制之类的，我觉得大概大学期间用不了几次。。。。菜。。。。Orz。。。。。就不说了，只说说对ACM有用的吧。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>（上面代码有标号） 1号行代码：ss是一个字符串，然后"%s"意思是转化为字符串,然后赋给ss1，作用就是 '=' 。如果中间使“%d”,那么就会起到字符串转化数字的作用了，实例中得到整数123，赋给ss1,ss1是char类型，“{”的ASCII码是123，所以字符串ss1就是单个字符“{”.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>2号行代码：“%8s”中间的数字8表示从头开始，一共取8个字符。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>3号行代码：“%[^(]”表示读到‘（’结束，注意里面不要乱打空格，%[^ ]表示到空格结束，读不进空格。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>4号行代码：“%[^a-z]”表示读到小写字母就结束，小写字母读不进。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>"^"符号表示到什么符号停止，大概就是非的意思。"%[]"这玩意貌似叫字符集</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>5号行代码：%[a-z,A-Z,0-9]意思是读小写,大写字母,数字0-9，后面加个“，”还可以继续加可读入符号。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>1-1-2 sprintf函数</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p><em>sprintf指的是字符串格式化命令，主要功能是把格式化的数据写入某个字符串中</em>--百度百科</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>主要作用与sscanf相反，是将数字转变成字符串，代码：</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>    sprintf(ss1,"%d",123);
    sprintf(ss2,"%4d%4d",123,456);
    puts(ss1);
    puts(ss2);</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>输出：</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>123
 123 456</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>与printf类似，只不过sprintf是打印到一个字符串罢了</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>详见：<a href="https://blog.csdn.net/oyhb_1992/article/details/75095472">sprintf</a></p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>1-2 以atoi函数为代表的一系列函数，C标准库函数</h2>
<!-- /wp:heading -->

<!-- wp:heading {"level":3} -->
<h3>1-2-1 atoi()函数，ascii to integer</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>作用是将字符串转化为整型数，未执行有效转换则返回0，比喻说字符串中全是字母时。。</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>    char ss4[100]="1234asdf";
    char ss5[100]="asdf1234";
    int x=atoi(ss4);
    int x1=atoi(ss5);
    printf("%d\n",x);
    printf("%d",x1);</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>输出：</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>1234
0</code></pre>
<!-- /wp:code -->

<!-- wp:heading {"level":3} -->
<h3>1-2-2 atof()函数，。。。to f 浮点数</h3>
<!-- /wp:heading -->

<!-- wp:code -->
<pre class="wp-block-code"><code>    char ss4[100]="1234.1234";
    char ss5[100]="asdf1234";
    double x=atof(ss4);
    double x1=atof(ss5);
    printf("%lf\n",x);
    printf("%lf",x1);</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>输出：</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>1234.123400
0.000000</code></pre>
<!-- /wp:code -->

<!-- wp:heading {"level":3} -->
<h3>1-2-3 atol()函数 ，长整型</h3>
<!-- /wp:heading -->

<!-- wp:code -->
<pre class="wp-block-code"><code>    char ss3[100]="-2147483648";
    char ss4[100]="2147483647";
    char ss5[100]="asdf1234";
    long long int x0=atol(ss3);
    long long int x=atol(ss4);
    long long int x1=atol(ss5);
    printf("%lld\n",x0);
    printf("%lld\n",x);
    printf("%lld",x1);
    //输出：
    //-2147483648
    //2147483647
    //0</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>这个函数我试着有点问题，超出int范围之后，返回的数就很哲学。。。。。。。Orz</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>！！！</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>1-3 tolower() and toupper()</h3>
<!-- /wp:heading -->

<!-- wp:code -->
<pre class="wp-block-code"><code>    char c='C';
    c=tolower(c);
    putchar(c);
    cout&lt;&lt;'\n';
    c=toupper(c);
    putchar(c);</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>tolower转换成小写字母，toupper转换成大写字母，括号中的参数应该是一个int型数，字符c自动转化成ascii码。不嫌麻烦可以用来赋值。。。。。</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>    char c='C';
    c=toupper(65);
    putchar(c);
    //输出A</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>真是闲的。。。Orz。。</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>1-4 重点来了，一堆str开头的函数。。。。前方高能，好累。。。</h2>
<!-- /wp:heading -->

<!-- wp:list -->
<ul><li>strcat() 字符串拼接函数</li><li>strncat() 字符串拼接函数（拼接指定部分）</li><li>strcmp() 字符串比较函数</li><li>strncmp() 字符串比较函数（比较指定长度）</li><li>strnicmp() 字符串比较函数（比较制定长度，不区分大小写）</li><li>strlwr() 将大写转化为小写</li><li>strupr() 将小写转化为大写</li><li>strcpy() 字符串拷贝函数</li><li>strncpy() 字符串拷贝函数（有3个参数，第一个目录字符串、第二个源字符串，第三个是一个整数)</li><li>strlen() 计算字符串长度函数</li><li>strchr() 查找字符串中某字符第一次出现位置函数</li><li>strrchr() 查找字符串中某字符最后一次出现位置函数</li><li>strspn() 返回s1中第一个在s2中不存在的字符的索引(find_first_not_of)</li><li>strcspn() 返回s1中第一个也在s2中存在的字符的索引(find_first_of)</li><li>strdup() 将串拷贝到新建的位置处(返回一个指针,指向为复制字符串分配的空间;如果分配空间失败,则返回NULL值。需要用free()释放相应的内存空间，否则会造成内存泄漏。赶脚基本没用)</li><li>strrev() 字符串反转函数（注意！非C标准库函数，没卵用，还很危险）</li><li>strstr() 查找子串出现位置函数</li><li>strtok() 从串s1中分离出由串s2中指定的分界符分隔开的记号(token)(很复杂，基本没用)</li><li>strtol() 将字符串转化为长整型数</li><li>strtod() 将字符串转化为double型</li><li>strtof() 将字符串转化为flout型</li><li>strtok() 切割字符串</li><li>strset() 用某字符填充字符串</li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>有的返回下标，有的返回长度，有的返回ture或false，有的返回指针。。。有空再具体填充一下吧<br></p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>137</wp:post_id>
		<wp:post_date><![CDATA[2019-03-29 21:22:36]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-03-29 13:22:36]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[char%e5%9e%8b%e6%95%b0%e7%bb%84-str%e5%85%84%e5%bc%9f%e4%bc%9a%ef%bc%88sprintfsscanf%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="string"><![CDATA[字符串__基础]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[neve_meta_content_width]]></wp:meta_key>
		<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_content_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[90]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wp_old_slug]]></wp:meta_key>
		<wp:meta_value><![CDATA[char]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>string成员函数or操作整理</title>
		<link>https://sdnuqp.cn/string%e6%88%90%e5%91%98%e5%87%bd%e6%95%b0or%e6%93%8d%e4%bd%9c%e6%95%b4%e7%90%86/</link>
		<pubDate>Fri, 29 Mar 2019 13:26:16 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=139</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:heading {"level":1} -->
<h1>字符串这个东西嗯~ o(<em>￣▽￣</em>)o有点意思丫</h1>
<!-- /wp:heading -->

<!-- wp:heading {"level":3} -->
<h3>首先是c++特有的 string 类：</h3>
<!-- /wp:heading -->

<!-- wp:heading {"level":4} -->
<h4>1.只能用cin和cout或scanf和printf，不然会得到一堆乱码。（cin以空格和回车为结束，不会吃空格和回车）</h4>
<!-- /wp:heading -->

<!-- wp:heading {"level":5} -->
<h5>1-1.这两种都可以输入输出，虽然会输出，但是有问题，不能这么用，用scanf时不能进行加操作，为了不超时，尽量用char[]吧；</h5>
<!-- /wp:heading -->

<!-- wp:code -->
<pre class="wp-block-code"><code>    scanf("%s",s);
    printf("%s",s);

    scanf("%s",&amp;s);
    printf("%s",s);</code></pre>
<!-- /wp:code -->

<!-- wp:code -->
<pre class="wp-block-code"><code>    scanf("%s",&amp;s);
    cout&lt;&lt;s;
    //没输出</code></pre>
<!-- /wp:code -->

<!-- wp:code -->
<pre class="wp-block-code"><code>    cin>>s;
    printf("%s",s);
    //乱码</code></pre>
<!-- /wp:code -->

<!-- wp:heading {"level":3} -->
<h3>2.string类可以加，加另一个字符串（也可以加自己）或一个字符，这很好使（不可以减）。</h3>
<!-- /wp:heading -->

<!-- wp:code -->
<pre class="wp-block-code"><code>    cin>>s;
    cin>>s1;
    s+=s1;
    cout&lt;&lt;s;</code></pre>
<!-- /wp:code -->

<!-- wp:heading {"level":3} -->
<h3>3.string类成员函数，前方高能？</h3>
<!-- /wp:heading -->

<!-- wp:heading {"level":4} -->
<h4>3-1. s.assign（）貌似是和"="一个作用？</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>其实它有更重要的功能！！！上代码：</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>    s2="WEW";
    s.assign(s2,0,2);
    cout&lt;&lt;s;//输出"WE";</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>s.assign(s2,a,b);</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>意思是s取s2的从a开始往后数b-1个，共b个，这段字符串，好用！（越界也可以，至于有没有影响，我也不知Orz）（注意！！！这里不是a到b，而是a到a+b-1间的字符串！）</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>3-2 好了，第一个函数讲完了，下一个是s.swap()</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>这个猫屎没多大卵用。。</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>    s2= "01234567";
    s = "abcdefgh";
    s.swap(s2);
    cout&lt;&lt;s2&lt;&lt;'\n';
    cout&lt;&lt;s;</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>交换两个字符串内容，注意，括号里不能是"XXXXX",只能是已经定义过的一个s（可以是空的）；</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>3-3 s.append()函数和s.push_back()函数</h4>
<!-- /wp:heading -->

<!-- wp:heading {"level":4} -->
<h4>3-3-1-1 在s后添加一段字符串，代码：</h4>
<!-- /wp:heading -->

<!-- wp:code -->
<pre class="wp-block-code"><code>    s2= "0123456789";
    s1= "ABCDEFGH";
    s = "abcdefgh";
    s1.append(s2,8,1);
    s2.append(s2,8,2);
    cout&lt;&lt;s1;
    cout&lt;&lt;'\n';
    cout&lt;&lt;s2;
    //输出：
    //ABCDEFGH8
    //012345678989</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>注意，可以在s后添加一段s自己中的一段，当然全添加也可以。append（s,a,b）规则同上</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>3-3-1-2 s.append(a,chr)</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>chr是一个char字符，不能是一个字符串！意为在字符串s后面加 a 个字符chr。。。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>3-3-2 push_back()函数</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>s.push_back(chr);，这个函数单纯的在字符串s后面添加一个字符。NO字符串。功能比较简单。。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>3-4 s.clear()和s.erase</h3>
<!-- /wp:heading -->

<!-- wp:heading {"level":4} -->
<h4>3-4-1 s.clear()</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>s.clear()函数貌似比较复杂，像endl一样并不只是换行，它并不是只是清空，还有其他不知道的神奇操作。。。。。看网上有很多人踩坑，出现各种问题，我。。。菜鸡。。不懂。。。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>3-4-2 s.erase()</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>这个函数较为灵活，有两个用法</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>首先是，看代码</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>    s2= "0123456789";
    s2.erase(5);
    cout&lt;&lt;s2;//输出01234</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>将5位置之后的删去，包括5。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>然后是，看代码：</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>    // 从位置pos=6处开始，共删除4个字符
    s.erase(6, 4);</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>删除中间一段可以用这个函数，很好使！</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>3-5 reverse函数（这个不是成员函数）</h3>
<!-- /wp:heading -->

<!-- wp:heading {"level":3} -->
<h3>3-5-1 string</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>这个函数可以用于string和char数组，也是对string来说比较好使常用的几个函数之一。</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>    s="0123456789";
    cout&lt;&lt;s&lt;&lt;'\n';
    reverse(s.begin(),s.end());
    cout&lt;&lt;s&lt;&lt;'\n';
    reverse(s.begin(),s.end()-5);
    cout&lt;&lt;s;</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>输出：</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>   0123456789
   9876543210
   5678943210</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>通过迭代器来决定那段反转，可以部分反转，范围前闭后开。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>3-5-2 char</h3>
<!-- /wp:heading -->

<!-- wp:code -->
<pre class="wp-block-code"><code>    char s[10]={'0','1','2','3','4'};
    reverse(s,s+3);
    printf("%s",s);</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>可以部分反转，前闭后开，reverse(s+a,s+b)表示s[a]到s[b-1]反转</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>3-6 s.find()</h3>
<!-- /wp:heading -->

<!-- wp:heading {"level":4} -->
<h4>3-6-1 s.find(s1)/s.find(chr)</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>首先，如果找到它返回子串（或字符）在母串中第一次出现的首字符下标值，否则返回npos，这个东西有的编译器取值4294967295，有的取值-1，在字符串中找不到子串 (或字符)。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>也可以 s.find(s1,5);表示查找在下标5（包括5）后子串（字符）出现的位置，未找到返回npos</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>3-6-2 s.find_first_of()/s.find_last_of()</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>查找首次出现的位置和最后一次出现的位置，也可以像3-6-1中第二点一样，选择在某位置后查找</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>3-6-2 s.rfind()!!!反向查找子串</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>注意，这个函数不会变绿，与s.find()结合使用，可以判断子串在母串中是否是唯一的。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>3-7 s.substr()</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>s.substr(s1,n)和assign函数很像，规则也相同，看前面吧。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>3-8 s.size()</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>返回长度</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>3-9 s.replace()</h3>
<!-- /wp:heading -->

<!-- wp:heading {"level":4} -->
<h4>3-9-1 前方高能?!这是一个字符串置换函数，可以将母串某一段换成另一串字符串，也可以换成空！！！！不是换成 '\0'，相当于删除了某一段！！！</h4>
<!-- /wp:heading -->

<!-- wp:code -->
<pre class="wp-block-code"><code>    s1 = "0123456789";
    s1.replace(1,2,"");
    cout&lt;&lt;s1;//输出：03456789</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>第一个参数是位置，第二个参数是置换一段的长度。//参数也可以是迭代器</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>3-9-2 5个参数时，看代码：</h4>
<!-- /wp:heading -->

<!-- wp:code -->
<pre class="wp-block-code"><code>    s1 = "0123456789";
    s2 = "qwert";
    s1.replace(1,6,s2,1,3);
    cout&lt;&lt;s1;//输出：0we789</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>后面两个数字表示换成s2的1到3位置子串，男的的一个前闭后闭的函数！！！</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>嗯~ o(<em>￣▽￣</em>)o差不多够使了。。。。 欧克。<br></p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>139</wp:post_id>
		<wp:post_date><![CDATA[2019-03-29 21:26:16]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-03-29 13:26:16]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[string%e6%88%90%e5%91%98%e5%87%bd%e6%95%b0or%e6%93%8d%e4%bd%9c%e6%95%b4%e7%90%86]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="string"><![CDATA[字符串__基础]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[neve_meta_content_width]]></wp:meta_key>
		<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_content_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[90]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>BF算法</title>
		<link>https://sdnuqp.cn/bf%e7%ae%97%e6%b3%95/</link>
		<pubDate>Fri, 29 Mar 2019 13:28:58 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=143</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>先看百度词条的描述：</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>BF算法，即暴风(Brute Force)算法，是普通的模式匹配算法，BF算法的思想就是将目标串S的第一个字符与模式串T的第一个字符进行匹配，若相等，则继续比较S的第二个字符和 T的第二个字符；若不相等，则比较S的第二个字符和T的第一个字符，依次比较下去，直到得出最后的匹配结果。BF算法是一种蛮力算法。</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>                                  —————————————————百度词条</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>只是看看描述，该算法就已清晰，这个算法其实大家都能想到，对于暴力的优化。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>但问题也很明显，如果在很长的一段串中，模式串匹配不成功的部分总在最后一个字符，那样时间复杂度就上去了。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>BF算法思路简单明了，但当匹配失败时，主串的指针回溯到i-j+1位置，j回溯到0，这就明显浪费时间精力了。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>BF算法最好情况下时间复杂度为O（n+m），最差情况下时间啊复杂度为O（n * m）,不够好！</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>代码：</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>int BF(char S[],char T[],int pos)
{//c从第pos位开始搜索匹配
    int i=pos,j=0;
    while(S[i+j]!='\0'&amp;&amp;T[j]!='\0'){
        if(S[i+j]==T[j])
            j++;
        else{
            i++;
            j=0;
        }
    }
    if(T[j]=='\0')
        return i+1;
    else
        return -1;
}</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>143</wp:post_id>
		<wp:post_date><![CDATA[2019-03-29 21:28:58]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-03-29 13:28:58]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[bf%e7%ae%97%e6%b3%95]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="string"><![CDATA[字符串__基础]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[neve_meta_content_width]]></wp:meta_key>
		<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_content_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[90]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>KMP算法及其优化</title>
		<link>https://sdnuqp.cn/kmp%e7%ae%97%e6%b3%95%e5%8f%8a%e5%85%b6%e4%bc%98%e5%8c%96/</link>
		<pubDate>Fri, 29 Mar 2019 13:30:02 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=145</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>如约而至</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>首先，我建议你别看我的博客了，。。。。。。因为有人个写的比我强10000倍。。。。Orz。。。。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><a href="https://blog.csdn.net/x__1998/article/details/79951598">某大神写的KMP详解，写的太好了啊啊啊啊，点我传送，起飞。。</a></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>好了，你非要看我的我也没办法，嗯~ o(<em>￣▽￣</em>)o，我讲的乱七八糟，主要给自己看的，请点赞。。。</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>1- 1 基础KMP算法</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>KMP算法是一种改进的字符串匹配算法，由D.E.Knuth，J.H.Morris和V.R.Pratt同时发现，因此人们称它为克努特——莫里斯——普拉特操作（简称KMP算法）。KMP算法的关键是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是实现一个next()函数，函数本身包含了模式串的局部匹配信息。时间复杂度O(m+n)。</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>———————百度百科</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>反正KMP就是三个人的名字缩写，KMP算法是一种改进能够快速的进行字符串匹配的算法。嗯~ o(<em>￣▽￣</em>)o。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>先上模板，代码：</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>int KMP(char * t, char * p) 
{
    int i = 0; 
    int j = 0;

    while (i &lt; strlen(t) &amp;&amp; j &lt; strlen(p))
    {
        if (j == -1 || t[i] == p[j]) 
        {
            i++;
            j++;
        }
        else 
            j = next[j];
        }

    if (j == strlen(p))
       return i - j;
    else 
       return -1;
}
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>得到next数组，代码：</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>void getNext(char * p, int * next)
{
    next[0] = -1;
    int i = 0, j = -1;

    while (i &lt; strlen(p))
    {
        if (j == -1 || p[i] == p[j])
        {
            ++i;
            ++j;
            next[i] = j;
        }   
        else
            j = next[j];
    }
}
</code></pre>
<!-- /wp:code -->

<!-- wp:heading {"level":3} -->
<h3>以模式串“abababcccab”为例</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p><strong>next数组作用：记录在第i个字符匹配失败的时候，j应该回溯到哪个位置！</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>next[]数组是存“模式串的子串中相同的前缀和后缀最大长度”，子串长度为1时，没有前缀后缀，next[1]=0</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>next[2],即子串是"ab"时,相同前缀后缀最大长度，前缀只有"a",后缀只有"b",不相等，所以next[2]=0</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>next[3]，即子串是"aba"时,前缀两个“a”和“ab”,后缀两个“a”和“ba”,都有“a”,长度1，所以next[3]=1，到这就明白next数组的意义了吧，但关键是如何用代码得到？</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>（还有一种优化算法，使用newnext数组，后面再说。）</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>噫- - - -，有没有发现上面两个函数貌似一样啊？</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>没错就是一样的！！！只不过第二个求next的函数中两个串是一样的，都是模式串，第一个KMP函数中一个主串，一个子串，。。。Orz.......</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>刚开始没好好看这篇博客，没理解，又去找了一堆视频博客，也没搞懂，反而自己混乱了，省略一系列过程，最终又点开了开头链接的那篇博客，往下翻了翻，看到那几张得到next数组的过程图，卧槽，窝里个去，我擦力，恍然啊东大坞！！！</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>白浪费那么多时间了。。。。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>KMP到这为止了，next数组得出请看：</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p><strong><em>推荐博客的几张过程图！</em></strong></p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>1- 2 KMP算法的优化</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>又回来了，本以为对这个算法已经理解透了，代码也会了，做了一个题，结果还是有几个样例TLE了。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>P3375题，最开始介绍的算法超时（主要就是next数组中的值还可以优化），我一看题解，大多数人都用的另一种for循环中套while的方法。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>代码：</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>    int j=0;
    for (int i=2; i&lt;=lb; i++) {
        while(j&amp;&amp;b[i]!=b[j+1])
            j=kmp[j];
        if(b[j+1]==b[i])
            j++;
        kmp[i]=j;
    }
    for(int i=1; i&lt;=la; i++) {
        while(j&amp;&amp;b[j+1]!=a[i])
            j=kmp[j];
        if (b[j+1]==a[i])
            j++;
        if (j==lb) {
            cout&lt;&lt;i-lb+1&lt;&lt;endl;
            j=kmp[j];
        }
    }</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p><a href="https://blog.csdn.net/u012852986/article/details/51413305">链接</a></p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>另，另一种优化方法</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>使用nextval数组，这个是数据结构课本上的优化，旨在防止这种情况：</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>aaaaaaaaaaaaab（T串）</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>aaaab(P串)</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>一旦发现一堆a相同，直接跳到结尾，不用一位位的挪了。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>代码：</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>
void getNextval(){
    nextval[1] = 0;
    i = 1;
    j = 0;
    while(i&lt;len2){
        if( j==0 || m[i] == m[j]){
            i++;
            j++;
            if(m[i] != m[j]){
                nextval[i] = j;
            }
            else{
                nextval[i] = nextval[j];
            }
        }
        else{
            j = nextval[j];
        }
    }
}</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>数据结构课本上的内容。。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>补写一些东西</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>时隔半年之后，再回来看KMP，发现自己还是不会。。。。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>一直挂在心上，对KMP的理解实在不够！趁着暑假集训，重启KMP，此次必须精通！</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>2019.8.6</p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>145</wp:post_id>
		<wp:post_date><![CDATA[2019-03-29 21:30:02]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-03-29 13:30:02]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[kmp%e7%ae%97%e6%b3%95%e5%8f%8a%e5%85%b6%e4%bc%98%e5%8c%96]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="kmp"><![CDATA[字符串__KMP/EXKMP]]></category>
		<category domain="category" nicename="string"><![CDATA[字符串__基础]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[neve_meta_content_width]]></wp:meta_key>
		<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_content_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[90]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>JAVA高精度</title>
		<link>https://sdnuqp.cn/java%e9%ab%98%e7%b2%be%e5%ba%a6/</link>
		<pubDate>Fri, 29 Mar 2019 13:33:17 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=147</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:heading {"level":3} -->
<h3>偶尔会遇到大数的题，Java首选，C++char数组模拟也可以（从第一位开始遍历，逢十进一即可）</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>HDUOJ 1002 A + B Problem II(大数加法)</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>代码：</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>import java.util.*;
import java.math.*;

public class Main
{ 
     public static void main(String args[]) 
     { 
         Scanner in=new Scanner (System.in);

         int i,n=in.nextInt();

         BigInteger a,b,c;

         for(i=1; i&lt;=n; i++){
         if(i!=1)
             System.out.println("");
         a=in.nextBigInteger();
         b=in.nextBigInteger();

         c=a.add(b);
         System.out.println("Case "+i+":");
         System.out.println(a+" + "+b+" = "+c);
         }  
     } 
} 
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>这个题是最简单的Java大数了，</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>其次是HDUOJ 1042 N！</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>import java.io.*;
import java.math.*;
import java.util.*;
import java.text.*;

public class Main
{ 
     public static void main(String args[]) 
     { 
//       Scanner in = new Scanner(System.in);
         Scanner in = new Scanner (new BufferedInputStream(System.in));
         while (in.hasNextInt()){
             int i,n = in.nextInt();
//           BigInteger sum = BigInteger.valueOf(1);
             BigInteger sum = new BigInteger("1");
             for(i = 2; i &lt;= n ; i++) {
                 BigInteger z  = BigInteger.valueOf(i);
                 sum = sum.multiply(z);
             }
             System.out.println(sum);
         }
     } 
} </code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>Java小白做了两个题，略有体会。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>看网上说，BigInteger和BigDecmial两个类理论上可以求超级大超级大的一个数，最大值取决于你电脑内存！！！！！！！！！！纽币！</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>BigInter 可以看作是一种数据类型，从C++角度来看。。。。。菜。。。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>声明一个变量a：</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>    BigInteger a;</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>对a赋值有两种方式：</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>第一种：</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>    a = new BigInteger("123");
    //"123"是一个字符串，将字符串转化成一个数字</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>第二种：</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>    a = BigInteger.valueOf(i); 
    //这里的i就是一个数，可以用于for循环</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>大数的加减乘除是通过四个“函数”，貌似叫方法，没学过不懂。</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>    a = a.add(BigInteger other);//加
    a = a.multiply(BigInteger other);//乘
    a = a.subtract(BigInteger other);//减
    a = a.divide(BigInteger other);//除
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>还有一些东西，详见</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>[<a href="https://blog.csdn.net/Young_12138/article/details/68498724">https://blog.csdn.net/Young_12138/article/details/68498724</a>]()</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>[<a href="https://blog.csdn.net/suyebiubiu/article/details/78511556">https://blog.csdn.net/suyebiubiu/article/details/78511556</a>]()</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>大浮点数BigDecimal</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>HDU 1753</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>代码：</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>import java.io.*;
import java.math.*;
import java.util.*;
import java.text.*;

public class Main{
    public static void main(String args[]) {
        Scanner in = new Scanner (new BufferedInputStream(System.in));
        BigDecimal a , b;
        while(in.hasNextBigDecimal()) {
            a = in.nextBigDecimal();
            b = in.nextBigDecimal();
            System.out.println(a.add(b).stripTrailingZeros().toPlainString());
        }   
    }
}</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>顺带一提，开数组：</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>    BigInteger a[] = new BigInteger[100];</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>147</wp:post_id>
		<wp:post_date><![CDATA[2019-03-29 21:33:17]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-03-29 13:33:17]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[java%e9%ab%98%e7%b2%be%e5%ba%a6]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="java"><![CDATA[基础__JAVA]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[neve_meta_content_width]]></wp:meta_key>
		<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_content_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[90]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wp_old_slug]]></wp:meta_key>
		<wp:meta_value><![CDATA[%e9%ab%98%e7%b2%be%e5%ba%a6]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>STL-priority_queue</title>
		<link>https://sdnuqp.cn/stl-priority_queue/</link>
		<pubDate>Fri, 29 Mar 2019 13:34:53 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=149</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>少废话，直接上代码：</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>#include &lt;bits/stdc++.h>
using namespace std;

struct cmp1{
    bool operator ()(int &amp;a,int &amp;b){
        return a>b;//最小值优先
    }
};

struct cmp2{
    bool operator () (int &amp;a,int &amp;b){
        return a&lt;b;//最大值优先
    }
};

priority_queue &lt;int >q;

priority_queue &lt;int ,vector&lt;int >,cmp1>q1;
priority_queue &lt;int ,vector&lt;int >,cmp2>q2;

priority_queue &lt;int ,vector&lt;int >,greater&lt;int > >q3;
priority_queue &lt;int ,vector&lt;int >,less&lt;int > >q4;

int main(){
    int x;
    for(int i=1;i&lt;=10;i++){
        x = i;
        if(x%2){
            x = 10-i;
        }
        q.push(x);
        q1.push(x);
        q2.push(x);
        q3.push(x);
        q4.push(x);
    }
    while(!q.empty()){
        cout&lt;&lt;q.top()&lt;&lt;' ';
        q.pop();
    }
    cout&lt;&lt;'\n';
    while(!q1.empty()){
        cout&lt;&lt;q1.top()&lt;&lt;' ';
        q1.pop();
    }
    cout&lt;&lt;'\n';
    while(!q2.empty()){
        cout&lt;&lt;q2.top()&lt;&lt;' ';
        q2.pop();
    }
    cout&lt;&lt;'\n';
    while(!q3.empty()){
        cout&lt;&lt;q3.top()&lt;&lt;' ';
        q3.pop();
    }
    cout&lt;&lt;'\n';
    while(!q4.empty()){
        cout&lt;&lt;q4.top()&lt;&lt;' ';
        q4.pop();
    }
    cout&lt;&lt;'\n';
    return 0;
}</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>输出：</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code> q:  10 9 8 7 6 5 4 3 2 1
q1:  1 2 3 4 5 6 7 8 9 10
q2:  10 9 8 7 6 5 4 3 2 1
q3:  1 2 3 4 5 6 7 8 9 10
q4:  10 9 8 7 6 5 4 3 2 1</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>另一种：</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>#include &lt;bits/stdc++.h>
using namespace std;

struct number1 {
    int x;
    bool operator &lt; (const number1 &amp;a) const {
        return x>a.x;//最小值优先
    }
};

struct number2 {
    int x;
    bool operator > (const number2 &amp;a) const {
        return x&lt;a.x;//最大值优先
    }
};

number1 num1[]= {14,10,56,7,83,22,36,91,3,47,72,0};
number2 num2[]= {14,10,56,7,83,22,36,91,3,47,72,0};

priority_queue&lt;number1>q5;
priority_queue&lt;number2>q6;

int main() {
    int x;
    for(int i=0; num1[i].x; i++)
        q5.push(num1[i]);
    for(int i=0; num2[i].x; i++)
        q6.push(num2[i]);

    printf("q5:  \n");
    while(!q5.empty()) {
        printf("%3d",q5.top());
        q5.pop();
    }
    puts("");
    printf("q6:  \n");
    while(!q6.empty()) {
        printf("%3d",q6.top());
        q6.pop();
    }
    return 0;
}</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>莫名其妙的报错，跳入stl_function文件</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>  template&lt;typename _Tp>
    struct less : public binary_function&lt;_Tp, _Tp, bool>
    {
      _GLIBCXX14_CONSTEXPR
      bool
      operator()(const _Tp&amp; __x, const _Tp&amp; __y) const
      { return __x &lt; __y; }
    };</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>无力抵抗。。。。。Orz</p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>149</wp:post_id>
		<wp:post_date><![CDATA[2019-03-29 21:34:53]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-03-29 13:34:53]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[stl-priority_queue]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="stl"><![CDATA[基础__STL]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[neve_meta_content_width]]></wp:meta_key>
		<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_content_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[90]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>STL—pair</title>
		<link>https://sdnuqp.cn/stl-pair/</link>
		<pubDate>Fri, 29 Mar 2019 13:35:31 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=151</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>c++中的结构模板，定义在头文件&lt;utility&gt;中，提供一个包含2个数据成员的结构体模板 ---百度百科</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>
#include &lt;bits/stdc++.h>
using namespace std;

int main(){
    pair&lt;pair&lt;int,pair&lt;int,string> >,pair&lt;int,pair&lt;int,string> > >q1;
    q1.first.first = 1;
    q1.first.second.first = 2;
    q1.first.second.second = "hhh";
    q1.second.first = 3;
    q1.second.second.first = 4;
    q1.second.second.second = "lll";

    cout&lt;&lt; q1.first.first;
    cout&lt;&lt;'\n';
    cout&lt;&lt; q1.first.second.first;
    cout&lt;&lt;'\n';
    cout&lt;&lt; q1.first.second.second;
    cout&lt;&lt;'\n';

    cout&lt;&lt; q1.second.first;
    cout&lt;&lt;'\n';
    cout&lt;&lt; q1.second.second.first;
    cout&lt;&lt;'\n';
    cout&lt;&lt; q1.second.second.second;
    cout&lt;&lt;'\n';

    return 0;
}
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>输出：</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>1
2
hhh
3
4
lll</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>pair更像是一个高级点的结构体，了解了这个东西之后就会发现这个东西真好用。。。</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>#include &lt;bits/stdc++.h>
using namespace std;

int main() {
    int a,b,c,d;
    scanf("%d %d",&amp;a,&amp;b);
    scanf("%d %d",&amp;d,&amp;c);

    pair&lt;int,int >q0;//定义

    pair&lt;int,int >q1(a,b);//定义,并赋值

    pair&lt;int,int >q2 = make_pair(d,c);//创建

    if(q1 &lt; q2)
        printf("若p1.first&lt;p2.first || p1.second&lt;p2.second 则p1&lt;p2为ture\n");

    if(q1 == q2)
        printf("pair中两个成员依此相等则为ture\n");

    return 0;
}</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>151</wp:post_id>
		<wp:post_date><![CDATA[2019-03-29 21:35:31]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-03-29 13:35:31]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[stl-pair]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="stl"><![CDATA[基础__STL]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[neve_meta_content_width]]></wp:meta_key>
		<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_content_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[90]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>STL—List</title>
		<link>https://sdnuqp.cn/stl-list/</link>
		<pubDate>Fri, 29 Mar 2019 13:36:24 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=153</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>这篇写的很好，我就不写了，完全转载</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>原文：<a href="https://blog.csdn.net/xiaoquantouer/article/details/70339869">STL-list by小拳头</a></p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>头文件

#include&lt;list>

 

声明一个int型的list：list&lt;int> a；

1、list的构造函数

list&lt;int>a{1,2,3}
list&lt;int>a(n)    //声明一个n个元素的列表，每个元素都是0
list&lt;int>a(n, m)  //声明一个n个元素的列表，每个元素都是m
list&lt;int>a(first, last)  //声明一个列表，其元素的初始值来源于由区间所指定的序列中的元素，first和last是迭代器

2、begin()和end()
通过调用list容器的成员函数begin()得到一个指向容器起始位置的iterator，可以调用list容器的end()函数来得到list末端下一位置

 

3、push_back()和push_front()

使用list的成员函数push_back和push_front插入一个元素到list中。其中push_back()是从list的末端插入，而push_front()是从list的头部插入。

 

4、empty()

判断list是否为空

 

5、resize()

调用resize(n)将list的长度改为只容纳n个元素，超出的元素将被删除。如果n比list原来的长度长，那么默认超出的部分元素置为0。也可以用resize(n, m)的方式将超出的部分赋值为m。

例子：

list&lt;int>b{1, 2, 3, 4};
b.resize(2);
list中输出元素：1,2
list&lt;int>b{1, 2, 3, 4};
b.resize(6);
list中输出元素：1,2,3,4,0,0
list&lt;int>b{1, 2, 3, 4};
b.resize(6,9);
list中输出元素：1,2,3,4,9,9

6、clear()

清空list中的所有元素

 

7、front()和back()

通过front()可以获得list容器中的头部元素，通过back()可以获得list容器的最后一个元素。注意：当list元素为空时，这时候调用front()和back()不会报错。因此在编写程序时，最好先调用empty()函数判断list是否为空，再调用front()和back()函数。

 

8、pop_back()和pop_front()

使用pop_back()可以删掉尾部第一个元素，pop_front()可以删掉头部第一个元素。注意：list必须不为空，如果当list为空的时候调用pop_back()和pop_front()会使程序崩掉。

 

9、assign()

有两种使用情况：

（1）a.assign(n, val):将a中的所有元素替换成n个val元素

例如：

list&lt;int>b{1,2,3,4,5};
b.assign(5,10);
b中的元素变为10, 10, 10, 10, 10

（2）a.assign(b.begin(), b.end())

list&lt;int>a{6,7,8,9};
list&lt;int>b{1,2,3,4,5};
b.assign(a.begin(),a.end());
b中的元素变为6,7,8,9

 

10、swap()

交换两个链表。a.swap(b)和swap(a, b)，都可以完成a链表和b链表的交换。

例子：

list&lt;int>a{6,7,8,9};
list&lt;int>b{1,2,3,4,5};
swap(a, b);  //或a.swap(b)
a中元素变为1,2,3,4,5

b中元素变为6,7,8,9

 

11、reverse()

可以实现list的逆置

例子：

list&lt;int>b{1,2,3,4,5};
reverse(b.begin(),b.end());
b中元素变为5，4，3，2，1

 

12、merge()

a.merge(b) 调用结束后b变为空，a中元素包含原来a和b的元素。

例子：

list&lt;int>a{6,7,8,9};
list&lt;int>b{2, 1, 3, 6, 5};
a.merge(b,greater&lt;int>());
a中元素变为：6,7,8,9,2,1,3,6,5

 

list&lt;int>a{6,7,8,9};
list&lt;int>b{2, 1, 3, 6, 5};
a.merge(b);
a中元素变为：2,1,3,6,5,6,7,8,9

 

13、insert()

在指定位置插入一个或多个元素

a.insert(a.begin(),100);  //在a的开始位置（即头部）插入100
a.insert(a.begin(),2, 100);   //在a的开始位置插入2个100
a.insert(a.begin(),b.begin(), b.end());//在a的开始位置插入b从开始到结束的所有位置的元素

14、erase()
删除一个元素或一个区域的元素

a.erase(a.begin());  //将a的第一个元素删除
a.erase(a.begin(),a.end());  //将a的从begin()到end()之间的元素删除。

15、remove()函数

从list中删除元素

list&lt;int>a{6,7,8,9,7,10};
a.remove(7);
删除了a中所有值为7的元素，此时a中元素为6,8,9,10

 

16、remove_if()函数

括号中可以传入

（1）回调函数

回调函数的原型为boolisRemove(T &amp;obj1);

函数名任意，如果obj1需要被移除则返回1，否则返回0

使用方法：list.remove_if(isRemove)

这种方法最简单，但是无法向回调函数中传递参数，每一个条件就要有一个回调函数，因此不推荐使用

（2）创建用于比较的类，传入类名及初始化参数

用于比较的类必须重载bool operator()(T &amp;obj1)方法，如果obj1需要被移除则返回1，否则返回0.

用于比较的类还应当包含必要的构造函数，用于传递参数。

使用方法：list.remove_if(classname(args))

例1：

bool is_odd(constint&amp; value){
    return (value==4);
}

int main(){
    list&lt;int> a{6,7,4,9,7,10};
    a.remove_if(is_odd);

    list&lt;int>::iterator it = a.begin();
    while(it != a.end()){
        cout&lt;&lt;*it&lt;&lt; " ";
        it++;
    }

    return 0;
}

输出：

6 7 9 7 10

 

例2：

class single_digit{
public:
    bool operator()(const int&amp; value){
        return (value&lt;10);
    }
};

int main(){
    list&lt;int> a{6,7,4,9,7,10};
   a.remove_if(single_digit());

    list&lt;int>::iterator it = a.begin();
    while(it != a.end()){
        cout&lt;&lt;*it&lt;&lt;" ";
        it++;
    }

    return 0;
}

输出：

10</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>153</wp:post_id>
		<wp:post_date><![CDATA[2019-03-29 21:36:24]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-03-29 13:36:24]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[stl-list]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="stl"><![CDATA[基础__STL]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[neve_meta_content_width]]></wp:meta_key>
		<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_content_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[60]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>JAVA输入提速</title>
		<link>https://sdnuqp.cn/java%e8%be%93%e5%85%a5%e6%8f%90%e9%80%9f/</link>
		<pubDate>Fri, 29 Mar 2019 13:37:11 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=155</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:code -->
<pre class="wp-block-code"><code>内部类
static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

    }


第二个（复制于https://blog.csdn.net/lvlinfeng970/article/details/79922263）：

import java.io.*;
import java.util.*;
import java.math.*;
 
public class Main
{
 
    public static void main(String[] args)
    {
        InputReader in = new InputReader();
        PrintWriter out = new PrintWriter(System.out);
        
        
        
        out.close();
    }
}
class InputReader
{
    BufferedReader buf;
    StringTokenizer tok;
    InputReader()
    {
        buf = new BufferedReader(new InputStreamReader(System.in));
    }
    boolean hasNext()
    {
        while(tok == null || !tok.hasMoreElements()) 
        {
            try
            {
                tok = new StringTokenizer(buf.readLine());
            } 
            catch(Exception e) 
            {
                return false;
            }
        }
        return true;
    }
    String next()
    {
        if(hasNext()) return tok.nextToken();
        return null;
    }
    int nextInt()
    {
        return Integer.parseInt(next());
    }
    long nextLong()
    {
        return Long.parseLong(next());
    }
    double nextDouble()
    {
        return Double.parseDouble(next());
    }
    BigInteger nextBigInteger()
    {
        return new BigInteger(next());
    }
    BigDecimal nextBigDecimal()
    {
        return new BigDecimal(next());
    }
}
</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>155</wp:post_id>
		<wp:post_date><![CDATA[2019-03-29 21:37:11]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-03-29 13:37:11]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[java%e8%be%93%e5%85%a5%e6%8f%90%e9%80%9f]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="java"><![CDATA[基础__JAVA]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[neve_meta_content_width]]></wp:meta_key>
		<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_content_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[60]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wp_old_slug]]></wp:meta_key>
		<wp:meta_value><![CDATA[%e8%be%93%e5%85%a5%e6%8f%90%e9%80%9f]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>lambda表达式（λ）</title>
		<link>https://sdnuqp.cn/lambda%e8%a1%a8%e8%be%be%e5%bc%8f%ef%bc%88%ce%bb%ef%bc%89%ef%bc%88%e7%a9%ba%e7%9a%84%ef%bc%89/</link>
		<pubDate>Fri, 29 Mar 2019 13:39:40 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=159</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>C++11中有很多很好使的东西</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>比如说：lambda</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">  “Lambda 表达式”(lambda expression)是一个<a rel="noreferrer noopener" target="_blank" href="https://baike.baidu.com/item/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/4337265">匿名函数</a>，Lambda表达式基于数学中的<a rel="noreferrer noopener" target="_blank" href="https://baike.baidu.com/item/%CE%BB%E6%BC%94%E7%AE%97">λ演算</a>得名，直接对应于其中的lambda抽象(lambda abstraction)，是一个匿名函数，即没有函数名的函数。Lambda表达式可以表示<a rel="noreferrer noopener" target="_blank" href="https://baike.baidu.com/item/%E9%97%AD%E5%8C%85/10908873">闭包</a>（注意和数学传统意义上的不同）。
                                                   --------百度O_o</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>总之，它是一个可以简写一些函数的方法，很多函数比如说在结构体排序的时候:</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>...
bool cmp(node a,node b){
    return a.x &lt; b.x
}
或者是
bool cmp(int &amp;a,int &amp;b){
    return a &lt; b;
}
...
int main(){
    ...
    sort(a,a+10,cmp);
    ...
}</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>要写一个cmp函数</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>用lanbda表达式改写一下就是：</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>sort(a, a+n, [](int a,int b){return a>b;});</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>明显简洁多了。。。。。。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>更高级的应用请去看 <a href="https://docs.microsoft.com/en-us/cpp/cpp/lambda-expressions-in-cpp?view=vs-2019">Microsoft Docs</a>。</p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>159</wp:post_id>
		<wp:post_date><![CDATA[2019-03-29 21:39:40]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-03-29 13:39:40]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[lambda%e8%a1%a8%e8%be%be%e5%bc%8f%ef%bc%88%ce%bb%ef%bc%89%ef%bc%88%e7%a9%ba%e7%9a%84%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="c11"><![CDATA[基础__C++11]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[neve_meta_content_width]]></wp:meta_key>
		<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_content_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[60]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_oembed_bed0fc79f4ce8ea0ee5ad880f8fdcaab]]></wp:meta_key>
		<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>矩阵快速幂</title>
		<link>https://sdnuqp.cn/%e7%9f%a9%e9%98%b5%e5%bf%ab%e9%80%9f%e5%b9%82/</link>
		<pubDate>Fri, 29 Mar 2019 13:40:15 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=161</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>貌似很难，其实极其简单。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>核心思想仍是找递推式，通过矩阵表示递推式罢了。。。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>Fibonacci（最简单的）</h4>
<!-- /wp:heading -->

<!-- wp:code -->
<pre class="wp-block-code"><code>Description
In the Fibonacci integer sequence, F0 = 0, F1 = 1, and Fn = Fn − 1 + Fn − 2 for n ≥ 2.

Input
a single line containing n (where 0 ≤ n ≤ 100,000,000,000)

Output
print Fn mod 1000000007 in a single line.

Sample Input
99999999999

Sample Output
669753982</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>代码：</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>#include &lt;bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll MOD = 1000000007;

struct mat {
    ll a[2][2];
};

mat mat_mul(mat a,mat b) {
    mat res;
    memset(res.a,0,sizeof(res.a));
    for(int i=0; i&lt;=1 ; i++) {
        for(int j = 0; j &lt;=1; j++) {
            for(int k = 0; k&lt;=1 ; k++) {
                res.a[i][j] = (res.a[i][j] + a.a[i][k]*b.a[k][j])%MOD;
            }
        }
    }
    return res;
}

ll mat_pow(ll n){
    mat c,res;
    c.a[0][0] = 1;
    c.a[0][1] = 1;
    c.a[1][0] = 1;
    c.a[1][1] = 0;
    memset(res.a,0,sizeof(res.a));
    res.a[0][0] = 1;
    res.a[1][1] = 1;
    while(n){
        if(n&amp;1){
            res = mat_mul(res,c);
        }
        c = mat_mul(c,c);
        n >>=1 ;
    }
    return res.a[0][1]%MOD;
}

int main() {
    ll n;
    scanf("%lld",&amp;n);

    ll ans = mat_pow(n);

    printf("%lld",ans);
}</code></pre>
<!-- /wp:code -->

<!-- wp:heading {"level":3} -->
<h3>更复杂点的F（n）= F（n-1）+F（n-2）+F（n-3）</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p><a href="http://www.acmicpc.sdnu.edu.cn/problem/show/1085">SDNUOJ1085爬楼梯再加强版</a></p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>Description
WZ是个蛋痛的人，总是喜欢琢磨蛋痛的事，比如他最近想知道上楼梯总共有多少种方式。已知他一步可以迈一阶、两阶或者三阶，现在给你楼梯的阶数，让你计算总共有多少种方式。

Input
输入有多组数据，每组数据占一行，表示楼梯的阶数。(1&lt;=N&lt;=100,000,000,000)

Output
对于每组数据，输出一行，表示上楼方式的总数 % 1000000007。

Sample Input
1
2

Sample Output
1
2</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>代码：</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>#include &lt;bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll MOD = 1000000007;

struct mat {
    ll a[3][3];
};

mat mat_mul(mat a,mat b) {
    mat res;
    memset(res.a,0,sizeof(res.a));
    for(int i = 0; i&lt;=2 ; i++) {
        for(int j = 0; j&lt;=2 ; j++) {
            for(int k = 0; k&lt;=2 ; k++) {
                res.a[i][j] += ( a.a[i][k] * b.a[k][j])%MOD;
            }
        }
    }
    return res;
}

ll mat_pow(ll n) {
    mat c,res;
    memset(c.a,0,sizeof(c.a));
    memset(res.a,0,sizeof(res.a));
    c.a[0][0] = 1;
    c.a[0][1] = 1;
    c.a[0][2] = 1;
    c.a[1][0] = 1;
    c.a[2][1] = 1;
    for(int i=0; i&lt;3 ; i++) {
        res.a[i][i] = 1;
    }
    while(n) {
        if(n&amp;1) {
            res = mat_mul(res,c);
        }
        c = mat_mul(c,c);
        n >>= 1;
    }
    return (res.a[0][0])%MOD;
}

int main() {
    ll n;
    while(scanf("%lld",&amp;n)!=EOF) {

//    n -= 1;

        ll ans = mat_pow(n);

        printf("%lld\n",ans);

    }
}</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>懒得多说，代码表达。</p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>161</wp:post_id>
		<wp:post_date><![CDATA[2019-03-29 21:40:15]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-03-29 13:40:15]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e7%9f%a9%e9%98%b5%e5%bf%ab%e9%80%9f%e5%b9%82]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="sundry"><![CDATA[杂项]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[neve_meta_content_width]]></wp:meta_key>
		<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_content_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[90]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>最大连续子序列和</title>
		<link>https://sdnuqp.cn/%e6%9c%80%e5%a4%a7%e8%bf%9e%e7%bb%ad%e5%ad%90%e5%ba%8f%e5%88%97%e5%92%8c/</link>
		<pubDate>Tue, 02 Apr 2019 13:16:27 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=169</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>问题描述：一排数，要你找其中的一段子序列和的最大值。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>最无脑的做法是O(n^2)算法暴力。。。。枚举所有子段，然后计算比较。。。。。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>对于这个问题有很多方法，时间复杂度，空间复杂度 各 有 不 同 。其实，只要会了最简单的O(n)的算法就好了，利用动态规划的思想！</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>long maxSubSum4(const vector&lt;int>&amp; a) ///复制别人的，就不自己写了
{ 
       long maxSum = 0, thisSum = 0; 
       for (int j = 0; j &lt; a.size(); j++) 
       { 
              thisSum += a[j]; 
              if (thisSum > maxSum) 
                     maxSum = thisSum; 
              else if (thisSum &lt; 0) 
                     thisSum = 0; 
       } 
       return maxSum; 
} 
</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>169</wp:post_id>
		<wp:post_date><![CDATA[2019-04-02 21:16:27]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-04-02 13:16:27]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%9c%80%e5%a4%a7%e8%bf%9e%e7%bb%ad%e5%ad%90%e5%ba%8f%e5%88%97%e5%92%8c]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="dynamic-programming"><![CDATA[基本策略__动态规划]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[neve_meta_content_width]]></wp:meta_key>
		<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_content_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[90]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>获取键入值（_kbhit()函数）</title>
		<link>https://sdnuqp.cn/%e8%8e%b7%e5%8f%96%e9%94%ae%e5%85%a5%e5%80%bc%ef%bc%88_kbhit%e5%87%bd%e6%95%b0%ef%bc%89/</link>
		<pubDate>Thu, 04 Apr 2019 13:03:19 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=175</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>该函数包含在头文件conio.h中，注意这个头文件并不是一个C标准库中的头文件，也就是说bits/stc++.h中没有它。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>函数返回一个数值，称为键码，每个键位均对应着一个键码。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>与_getch()配合使用</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>#include &lt;bits/stdc++.h>
#include &lt;conio.h>
using namespace std;

int main() {
    int x ;
    while(1) {
        if(_kbhit()) {
            x = _getch();
            cout&lt;&lt;x&lt;&lt;'\n';
            if(x == 27) {
                break;
            }
        }
    }
    return 0;
}</code></pre>
<!-- /wp:code -->

<!-- wp:image -->
<figure class="wp-block-image"><img src="http://images2015.cnblogs.com/blog/508750/201705/508750-20170504102336211-524432927.png" alt=""/></figure>
<!-- /wp:image -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>175</wp:post_id>
		<wp:post_date><![CDATA[2019-04-04 21:03:19]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-04-04 13:03:19]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e8%8e%b7%e5%8f%96%e9%94%ae%e5%85%a5%e5%80%bc%ef%bc%88_kbhit%e5%87%bd%e6%95%b0%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="sundry"><![CDATA[杂项]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[neve_meta_content_width]]></wp:meta_key>
		<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_content_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[90]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>获取键盘事件有趣小程序</title>
		<link>https://sdnuqp.cn/%e8%8e%b7%e5%8f%96%e9%94%ae%e7%9b%98%e4%ba%8b%e4%bb%b6/</link>
		<pubDate>Fri, 05 Apr 2019 02:06:01 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=177</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>这么6的代码当然是别人写的。。。。。像我这种菜鸡只会用system（“color XX”）;</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph {"customTextColor":"#70132f","backgroundColor":"white"} -->
<p style="color:#70132f" class="has-text-color has-background has-white-background-color">这个函数只有惨淡的16种颜色变化（16进制）。。。。。而下买你的代码有255种颜色变化。。。。Orz</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>这个程序缺点也很明显，没法获取其他字符，并不是真正意义上的获取键盘事件。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>用getch()函数应该也可以</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p></p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>#include &lt;iostream>
#include &lt;windows.h>
#include &lt;conio.h>
#define KEY_DOWN(VK_NONAME) ((GetAsyncKeyState(VK_NONAME) &amp; 0x8000) ? 1:0) //必要的，我是背下来的

using namespace std;

void color(int a) { //改变输出的颜色，比system("color x")快得多
    SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),a);
    /*
    &lt;span style="white-space:pre">	&lt;/span>字
    	1	深蓝色
    	2	深绿色
    	3	深青色
    	4	深红色
    	5	深粉色
    	6	黄色
    	7	深白色
    	8	灰色
    	9	浅蓝色
    	10	浅绿色
    	11	浅青色
    	12	浅红色
    	13	浅粉色
    	14	浅黄色
    	15	浅白色

    	背景
    	1~15		黑色
    	16~31		深蓝色
    	32~47		深绿色
    	48~63		深青色
    	64~79		深红色
    	80~95		深粉色
    	96~111		深黄色
    	112~127 	深白色
    	128~143 	灰色
    	144~159 	浅蓝色
    	160~175 	浅绿色
    	176~191 	浅青色
    	192~207 	浅红色
    	208~223 	浅粉色
    	224~239 	浅黄色
    	240~255 	浅白色
    */
}

void check(char c) { //检测某个按键是否按下，按下就改变输出颜色
    if(!KEY_DOWN(c))
        color(7);
    else
        color(112);
    printf("  %c  ",c);
    color(7);
}

int main() {
    while(1) {
        check('1');
        check('2');
        check('3');
        check('4');
        check('5');
        check('6');
        check('7');
        check('8');
        check('9');
        check('0');
        printf("\n\n ");
        check('Q');
        check('W');
        check('E');
        check('R');
        check('T');
        check('Y');
        check('U');
        check('I');
        check('O');
        check('P');
        printf("\n\n  ");
        check('A');
        check('S');
        check('D');
        check('F');
        check('G');
        check('H');
        check('J');
        check('K');
        check('L');
        printf("\n\n   ");
        check('Z');
        check('X');
        check('C');
        check('V');
        check('B');
        check('N');
        check('M');
        Sleep(20);//循环时间间隔，防止太占内存
        system("cls");//清屏
    }
    return 0;
}
///                                                     BY everlasting__</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>177</wp:post_id>
		<wp:post_date><![CDATA[2019-04-05 10:06:01]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-04-05 02:06:01]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e8%8e%b7%e5%8f%96%e9%94%ae%e7%9b%98%e4%ba%8b%e4%bb%b6]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="sundry"><![CDATA[杂项]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[neve_meta_content_width]]></wp:meta_key>
		<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_content_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[90]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>线段树</title>
		<link>https://sdnuqp.cn/%e7%ba%bf%e6%ae%b5%e6%a0%91/</link>
		<pubDate>Tue, 09 Apr 2019 11:25:49 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=185</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>无力打更多的字了</p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>185</wp:post_id>
		<wp:post_date><![CDATA[2019-04-09 19:25:49]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-04-09 11:25:49]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e7%ba%bf%e6%ae%b5%e6%a0%91]]></wp:post_name>
		<wp:status><![CDATA[private]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="data-structure"><![CDATA[数据结构__基础]]></category>
		<category domain="category" nicename="segment-tree"><![CDATA[数据结构__线段树]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[neve_meta_content_width]]></wp:meta_key>
		<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_content_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[60]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>高级数据结构——树状数组</title>
		<link>https://sdnuqp.cn/%e9%ab%98%e7%ba%a7%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84-%e6%a0%91%e7%8a%b6%e6%95%b0%e7%bb%84/</link>
		<pubDate>Wed, 10 Apr 2019 15:08:28 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=189</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>膜拜bin巨<br>
第二篇 树状数组</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>1 - 基础，获得树状数组的值<br>
与线段树很像，各有优点，它编程的复杂度低于线段树，并且比线段树节省空间，但是它的使用范围较小。<br>
也就是说，用树状数组看可以做的题，用线段树一定可以做，而用线段树做得题，用树状数组不一定能做。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>（学习之前建议先学一下前缀和，很简单的东西，不多说。）</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>树状数组可比线段树简单多了，一个是XX数组，另一个是XX树，本质不一样。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>学习博客：https://blog.csdn.net/Small_Orange_glory/article/details/81290634<br>
首先看树状数组中的元素，c[]是树状数组，a[]是原数组。<br>
c[1] = a[1];<br>
c[2] = a[1] + a[2];<br>
c[3] = a[3];<br>
c[4] = a[1] + a[2] + a[3] + a[4];<br>
c[5] = a[5];<br>
c[6] = a[5] + a[6];<br>
c[7] = a[7];<br>
c[8] = a[1] + a[2] + a[3] + a[4] + a[5] + a[6] + a[7] + a[8];</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>是不是很有意思？至于为什么要这么装，规律是什么？</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>来看，先将每一个数字写成二进制形式：<br>
1 -&gt; 0001<br>
2 -&gt; 0010<br>
3 -&gt; 0011<br>
4 -&gt; 0100<br>
5 -&gt; 0101<br>
6 -&gt; 0110<br>
7 -&gt; 0111<br>
8 -&gt; 1000</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>再来看每一个二进制数 从后向前数有几个0蛋,并计算2^k(k是0蛋数)</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>n    k    2^k<br>
1 -&gt; 0    1<br>
2 -&gt; 1    2<br>
3 -&gt; 0    1<br>
4 -&gt; 2    4<br>
5 -&gt; 0    1<br>
6 -&gt; 1    2<br>
7 -&gt; 0    1<br>
8 -&gt; 3    8</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>这时候再看c数组，知道c[n]的值怎么来得了吧，c[n] = a[n] + … +a[n-2^k+1];(即从a[n]往前数k-1个，共k项)<br>
树状数组说白了就是对二进制的应用。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>为求k(最低位的1)，写出下列函数:</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>&amp; 与运算符，只有同为1，才为1.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>int lowbit(int x){
     return x&amp;(x^(x-1));
 }</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>利用补码特性也可以写成：<br></p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code> int lowbit(int x){
     return x&amp;-x;
 }</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>2 - 单点更新</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>1 -&gt; 001 c[1] += a[1];</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>lowbit(1) == 001<br>
1 + 001 == 010 -&gt; 2 c[2] += a[1];</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>lowbit(2) == 010<br>
2 + 010 == 100 -&gt; 4 c[4] += a[1];</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>lowbit(4) == 100<br>
4 + 100 == 1000-&gt; 8 c[8] += a[1];</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>写出下列函数：</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>void updata(int x,int y,int n){
     for(int i = x ; i &lt;= n ; i += lowbit(i)){
         c[i] += y;
     }
 }</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>3 - 区间查询</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>区间查询是的单点更新的逆过程。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>先给出例子：</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code> num[7] = a[1] + a[2] + a[3] + a[4] + a[5] + a[6] + a[7];
 num[7] = c[4] + c[6] + c[7];
 num[111] = c[100] + c[110] + c[111];</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>上面三个式子等价。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>观察最后一个式子，简单来说，num[n] = n的二进制逐位去1，依然需要用到lowbit函数</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>通过树状数组求区间和的时间复杂度明显降低，原来可是从a[1]加到a[7]，现在只有四项相加!</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>写出下列函数：</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>int GetSum(){
     int ans = 0;
     for(int i = x ; i > 0 ; i -= lowbit(i)){
         ans += c[i];
     }
     return ans;
 }</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>189</wp:post_id>
		<wp:post_date><![CDATA[2019-04-10 23:08:28]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-04-10 15:08:28]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e9%ab%98%e7%ba%a7%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84-%e6%a0%91%e7%8a%b6%e6%95%b0%e7%bb%84]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="bit"><![CDATA[数据结构__树状数组]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[neve_meta_content_width]]></wp:meta_key>
		<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_content_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[90]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[题解]HDU-1556-Color the ball (前缀和&#124;&#124;树状数组&#124;&#124;线段树)</title>
		<link>https://sdnuqp.cn/hdu-1556-color-the-ball-%e5%89%8d%e7%bc%80%e5%92%8c%e6%a0%91%e7%8a%b6%e6%95%b0%e7%bb%84%e7%ba%bf%e6%ae%b5%e6%a0%91/</link>
		<pubDate>Thu, 11 Apr 2019 08:56:41 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=193</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>这道题并不是单纯的模板题，我敲了一个模板就交了，结果肯定超时了，树状数组处理区间单点数值的问题，不能单纯用基础模板。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>树状数组练习：https://vjudge.net/contest/287770#problem/C</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>前缀和 || 树状数组 || 线段树 都可以做</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>1-前缀和：</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>只是对区间开头和结尾进行处理，太巧妙了，想不到啊！！！Orz</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>代码：<br></p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>#include &lt;bits/stdc++.h>
using namespace std;
const int maxn = 1e5 +10;

int c[maxn];

int main(){
    int l;
    int n,m;
    int ans;
    while(~scanf("%d",&amp;l)&amp;&amp;l){
        memset(c,0,sizeof c);
        for(int j = 1 ; j &lt;= l ; j++){
            scanf("%d%d",&amp;n,&amp;m);
            c[n]++;
            c[m+1]--;
        }
        ans = 0;
        for(int i = 1 ; i &lt;= l ; i++){
            ans += c[i];
            printf("%d",ans);
            printf(i != l?" ":"\n");
        }
    }
    return 0;
}</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>2 - 树状数组</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>代码：</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>#include &lt;bits/stdc++.h>
using namespace std;
const int maxn = 1e5 + 10;

int c[maxn];
int sum[maxn];

int lowbit(int x) {
    return x&amp;(-x);
}

int update(int x, int y,int n) {
    while(x &lt;= n) {
        c[x] += y;
        x += lowbit(x);
    }
}

int getsum(int x ){
    int ans = 0;
    while(x >= 1){
        ans += c[x];
        x -= lowbit(x);
    }
    return ans;
}

int main() {
    int t;
    int n,m;
    int ans;
    while(~scanf("%d",&amp;t)&amp;&amp;t) {
        memset(c,0,sizeof c);

        for(int j = 1 ; j&lt;= t ;j++) {
            scanf("%d %d",&amp;n,&amp;m);
            update(n,1,t);
            update(m+1,-1,t);
        }

        for(int i = 1 ; i &lt;= t ; i++){
            ans = getsum(i);           ///与第一种方法操作相同，都是要求1到当前点的和。
            printf(i == t?"%d":"%d ",ans);
        }
        printf("\n");
    }
    return 0;
}</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>3 - 线段树</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>刚学了线段树，还是感觉很虚。</p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>193</wp:post_id>
		<wp:post_date><![CDATA[2019-04-11 16:56:41]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-04-11 08:56:41]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu-1556-color-the-ball-%e5%89%8d%e7%bc%80%e5%92%8c%e6%a0%91%e7%8a%b6%e6%95%b0%e7%bb%84%e7%ba%bf%e6%ae%b5%e6%a0%91]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="bit"><![CDATA[数据结构__树状数组]]></category>
		<category domain="category" nicename="segment-tree"><![CDATA[数据结构__线段树]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[neve_meta_content_width]]></wp:meta_key>
		<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_content_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[90]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[题解]POJ-2155-Matrix (二维树状数组)</title>
		<link>https://sdnuqp.cn/%e9%a2%98%e8%a7%a3poj-2155-matrix-%e4%ba%8c%e7%bb%b4%e6%a0%91%e7%8a%b6%e6%95%b0%e7%bb%84/</link>
		<pubDate>Fri, 12 Apr 2019 13:46:59 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=202</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>我想说POJ怎么还不完蛋。。。有时候题都交不了，很烦。</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>
#include &lt;bits/stdc++.h>
using namespace std;
const int maxn = 1e4 +10;

char s[2];
int a,b,c,d;
int m,k;
int cc[maxn][maxn];

int lowbit(int x) {
    return x&amp;(-x);
}

void Not(int x,int y) {
    int j;
    while(x &lt;= m) {
        j = y;
        while(j &lt;= m) {
            cc[x][j]++;
            j += lowbit(j);
        }
        x += lowbit(x);
    }
}

int query(int x,int y ) {
    int ans = 0,j;
    while(x >= 1) {
        j = y;
        while(j >= 1) {
            ans += cc[x][j];
            j -= lowbit(j);
        }
        x -= lowbit(x);
    }
    return ans;
}

int main() {
    int t;
    scanf("%d",&amp;t);
    while(t--) {
        memset(cc,0,sizeof(cc));
        scanf("%d %d",&amp;m,&amp;k);
        while(k--) {
            scanf("%s",s);
            if(s[0] == 'Q') {
                scanf("%d %d",&amp;a,&amp;b);
                printf("%d\n",query(a,b)%2);
            } else {
                scanf("%d %d %d %d",&amp;a,&amp;b,&amp;c,&amp;d);
                Not(a,b);
                Not(c+1,b);
                Not(a,d+1);
                Not(c+1,d+1);
            }
        }
        if(t)
            printf("\n");
    }
    return 0;
}
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>很神奇的玩意，神奇的二进制，为什么最后答案等于query(a,b)%2??????这就要看一篇长达29页的论文了。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>文章：《浅谈信息学竞赛中的“0”和“1”——二进制思想在信息学竞赛中的应用》——武森（石家庄二中）</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>高中生写的。。。。。。Orz。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>我TM。。。菜</p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>202</wp:post_id>
		<wp:post_date><![CDATA[2019-04-12 21:46:59]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-04-12 13:46:59]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e9%a2%98%e8%a7%a3poj-2155-matrix-%e4%ba%8c%e7%bb%b4%e6%a0%91%e7%8a%b6%e6%95%b0%e7%bb%84]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="tijie"><![CDATA[题解]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[neve_meta_content_width]]></wp:meta_key>
		<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_content_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[90]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[题解]牛客小白月赛13-D-位运算</title>
		<link>https://sdnuqp.cn/%e9%a2%98%e8%a7%a3%e7%89%9b%e5%ae%a2%e5%b0%8f%e7%99%bd%e6%9c%88%e8%b5%9b13-d-%e4%bd%8d%e8%bf%90%e7%ae%97/</link>
		<pubDate>Mon, 15 Apr 2019 14:14:51 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=206</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>这个题冥思苦想也没做出来<br>
最后看了别人题解，才明白原来前缀和还可以这样用！</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>AC code:
#include &lt;bits/stdc++.h>
using namespace std;
const int maxn = 5e6 + 10;

int a[maxn],b[maxn],c[maxn];

int main(){
    int n;
    scanf("%d",&amp;n);
    for(int i = 1 ; i &lt;= n ; i++){
        scanf("%d",&amp;a[i]);
    }
    for(int i = 1 ; i &lt;= n ; i++){//求前i个元素|运算结果
        b[i] = b[i-1] | a[i];
    }
    for(int i = n ; i >= 1 ; i--){//求第i到n个元素|运算结果
        c[i] = c[i+1] | a[i];
    }
    int maxx  = 0 ;
    for(int i = 1 ; i &lt;= n ; i++){//遍历第i个不要，求max.
        maxx = max(maxx , b[i-1] | c[i+1]);
    }
    printf("%d",maxx);
    return 0;
}</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>前缀和并不一定是前多少个元素相加，还可以是|,*之类的，思维要扩出去啊。<br> 了解这个后，题就很简单了，就不多赘述了。</p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>206</wp:post_id>
		<wp:post_date><![CDATA[2019-04-15 22:14:51]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-04-15 14:14:51]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e9%a2%98%e8%a7%a3%e7%89%9b%e5%ae%a2%e5%b0%8f%e7%99%bd%e6%9c%88%e8%b5%9b13-d-%e4%bd%8d%e8%bf%90%e7%ae%97]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="tijie"><![CDATA[题解]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[neve_meta_content_width]]></wp:meta_key>
		<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_content_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[90]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>“浪潮杯”第十届山东ACM省赛赛后总结</title>
		<link>https://sdnuqp.cn/?p=283</link>
		<pubDate>Wed, 15 May 2019 11:03:50 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=283</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>emmmmmm。。。比赛在5月12日，总结拖到今日才写。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>今年的比赛有307支队参加，好多人。。。250支参与排名，而我们队是那幸运的150支有牌队之一，虽然是个铜牌，没有多少用，但至少是一年的付出后的收获啦。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>++++++++++++++++++++</p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>283</wp:post_id>
		<wp:post_date><![CDATA[2019-05-15 19:03:50]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-05-15 11:03:50]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[]]></wp:post_name>
		<wp:status><![CDATA[draft]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="sundry"><![CDATA[杂项]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[题解]ZOJ-3944-People counting-思维</title>
		<link>https://sdnuqp.cn/%e9%a2%98%e8%a7%a3zoj-3944-people-counting-%e6%80%9d%e7%bb%b4/</link>
		<pubDate>Mon, 15 Apr 2019 14:16:21 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=209</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>这道题还是不难的，我想的是通过遍历每一个位置，然后对其他位置进行标记，但是WA了<br>
我写的很复杂，先判断当前位置是身体那一部分，然后对其它部分判断，如果数组对应位置是他对应的身体部分，就标记，不然说明这部分被别人挡住了。<br>
然而，WA了</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>换了队友敲，一他边过了，我的代码就不管了，太低级了。</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>AC code：
#include &lt;bits/stdc++.h>

using namespace std;
typedef long long ll;
const int INF = 0x3f3f3f3f;
const int N = 1e5;
char c[105][105];

bool pd(int i,int j)
{
    if(c[i][j] == '|')
        return 1;
    if(c[i-1][j] == 'O')
        return 1;
    if(c[i][j-1] == '/')
        return 1;
    if(c[i][j+1] == '\\')
        return 1;
    if(c[i+1][j-1] == '(')
        return 1;
    if(c[i+1][j+1] == ')')
        return 1;
    return 0;
}

int main()
{
    int t;
    cin >> t;
    while(t--)
    {
        memset(c,0,sizeof(c));
        int x,y,sum = 0;
        cin >> x >> y;
        for(int i = 1; i &lt;= x; i++)
        {
            for(int j = 1; j &lt;= y; j++)
            {
                cin >> c[i][j];
            }
        }
        for(int i = 0; i &lt;= x + 1; i++)
        {
            for(int j = 0; j &lt;= y + 1; j++)
            {
                if(pd(i,j))
                {
                    sum++;
                }
            }
        }
        cout &lt;&lt; sum &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>最好的部分就是这个函数了，非常棒的想法。<br> pd函数，是判断在当前位置是否有个人，就当c[i][j]是他的肚子，最后仍然是遍历。<br> 想的太棒了，Orz。(๑•̀ㅂ•́)و✧</p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>209</wp:post_id>
		<wp:post_date><![CDATA[2019-04-15 22:16:21]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-04-15 14:16:21]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e9%a2%98%e8%a7%a3zoj-3944-people-counting-%e6%80%9d%e7%bb%b4]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="tijie"><![CDATA[题解]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[neve_meta_content_width]]></wp:meta_key>
		<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_content_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[90]]></wp:meta_value>
		</wp:postmeta>
							<wp:comment>
			<wp:comment_id>12</wp:comment_id>
			<wp:comment_author><![CDATA[ccwss]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[me@example.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[223.104.2.190]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2019-04-19 12:02:33]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2019-04-19 04:02:33]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[这想法好妙啊]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
							</wp:comment>
					</item>
					<item>
		<title>根据日期计算星期</title>
		<link>https://sdnuqp.cn/%e6%a0%b9%e6%8d%ae%e6%97%a5%e6%9c%9f%e8%ae%a1%e7%ae%97%e6%98%9f%e6%9c%9f/</link>
		<pubDate>Mon, 15 Apr 2019 14:17:53 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=212</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>首先介绍一个计算XX年XX月XX日是星期几的公式：</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>吉姆拉尔森计算公式：<br>
1752年9月3日前：<br>
    w = (d + 2<em>m + 3</em>(m+1)/5 + y + y/4 + 5) % 7;<br>
1752年9月3日后：<br>
    w = (d + 2<em>m + 3</em>(m+1)/5 + y + y/4 - y/100 + y/400 )%7;<br>
（英国从这之后才宣布采用新历法）<br>
0是星期一，6是星期天</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>偶然间，又发现另一个计算星期的公式，叫蔡勒公式：</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>1582年10月4日后：<br>
    w = ( y + y/4 + c/4 - 2<em>c + 26</em>(m+1)/10 + d - 1 )%7;<br>
1582年10月4日前：<br>
    W = ( y + y/4 + c/4 - 2<em>c + 13</em>(m+1)/5 + d + 2 )%7;<br>
(c是世纪数(年前两位数)，y是年后两位数)</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>（至于为什么被一个日期分开，与更换历法有关，导致有几天没有过）<br>
1是星期一，0是星期天</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>两个公式有个相同又特殊的地方，就是要将本年的1月2月，当作上一年的13，14月来计算算。<br>
2010.1.1当作2009.13.1<br>
网上有很多讲这个公式的，+1，-1的都有，很乱，公式我调整过，大概就这样子了，用的时候先带入当天看一看。</p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>212</wp:post_id>
		<wp:post_date><![CDATA[2019-04-15 22:17:53]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-04-15 14:17:53]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%a0%b9%e6%8d%ae%e6%97%a5%e6%9c%9f%e8%ae%a1%e7%ae%97%e6%98%9f%e6%9c%9f]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="sundry"><![CDATA[杂项]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[neve_meta_content_width]]></wp:meta_key>
		<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_content_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[90]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[题解]ZOJ-3768-Continuous Login-二分</title>
		<link>https://sdnuqp.cn/%e9%a2%98%e8%a7%a3zoj-3768-continuous-login-%e4%ba%8c%e5%88%86/</link>
		<pubDate>Wed, 24 Apr 2019 12:30:15 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=218</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>这个题完全没找到规律，搜了一篇题解，说枚举前20个数，发现一个数最多分成三个数，然后暴力二分。。。<br></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p> 我以为是个递归，我规律找错了。。看了这个，就很好做了，很水嘛O。O，没看别人的code，自己写了一个程序，一遍了。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>AC code :</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>#include &lt;bits/stdc++.h>
using namespace std;
const int maxn = 123456789;

int a[16000];

int one(int x,int maxx) {
    for(int i = 1 ; i &lt;= maxx ; i++) {
        if(a[i] == x) {
            printf("%d\n",i);
            return 1;
        }
    }
    return 0;
}

int two(int x, int maxx) {
    int l,mid,r;
    for(int i = 1 ; i &lt;= maxx ; i++) {
        l = i;
        r = maxx;
        mid = (l + r)/2;
        while(l &lt; r) {
            if(a[mid] > x - a[i]) {
                r = mid ;
                mid = (l + r)/2;
            } else if(a[mid] &lt; x - a[i]) {
                l = mid;
                mid = (l + r)/2;
            } else {
                printf("%d %d",i,mid);
                return 1;
            }
            if(r - l == 1) {
                mid = (r+l)/2;
                if(a[mid] == x - a[i]) {
                    printf("%d %d",i,mid);
                    return 1;
                }
                break;
            }
        }
    }
    return 0;
}
int three(int x,int maxx) {
    for(int i = 1 ; i &lt;= maxx ; i++) {
        if(two(x-a[i],maxx)) {
            printf(" %d\n",i);
            return 0;
        }
    }
    return 1;
}

int main() {
    int i;
    a[1] = 1;
    for(i = 2 ;; i++) {
        a[i] = a[i-1]+i;
        if(a[i] >= maxn)
            break;
    }
    i-- ;
    int t;
    scanf("%d",&amp;t);
    int z;
    while(t--) {
        scanf("%d",&amp;z);
        if(one(z,i)) {
//            cout&lt;&lt;"(1)"&lt;&lt;'\n';
            ;
        } else if(two(z,i)) {
            printf("\n");
//            cout&lt;&lt;"(2)"&lt;&lt;'\n';
            ;
        } else {
//            cout&lt;&lt;"(3)"&lt;&lt;'\n';
            three(z,i);
        }
    }
    return 0;
}


////OK;
</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>218</wp:post_id>
		<wp:post_date><![CDATA[2019-04-24 20:30:15]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-04-24 12:30:15]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e9%a2%98%e8%a7%a3zoj-3768-continuous-login-%e4%ba%8c%e5%88%86]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="tijie"><![CDATA[题解]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[neve_meta_content_width]]></wp:meta_key>
		<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_content_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[90]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>foreach?</title>
		<link>https://sdnuqp.cn/foreach/</link>
		<pubDate>Tue, 30 Apr 2019 11:38:28 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=223</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>今天学java时学到了一个叫foreach的东西，突然想起来C++中也有类似的结构，很好用，但我没用过。。。</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>#include &lt;bits/stdc++.h>
using namespace std;

int x,y;

int main(){
    int z[6] = {0,1,2,3};
    for(int i : z){
        printf("%d ",z[i]);
    }
}</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>stl容器迭代和数组都可以用。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>输出：0，1，2，3，0，0.</p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>223</wp:post_id>
		<wp:post_date><![CDATA[2019-04-30 19:38:28]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-04-30 11:38:28]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[foreach]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="sundry"><![CDATA[杂项]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[neve_meta_content_width]]></wp:meta_key>
		<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_content_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[90]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>普里姆算法(Prim)-求最小生成树(MST)</title>
		<link>https://sdnuqp.cn/%e6%99%ae%e9%87%8c%e5%a7%86%e7%ae%97%e6%b3%95prim-%e6%b1%82%e6%9c%80%e5%b0%8f%e7%94%9f%e6%88%90%e6%a0%91mst/</link>
		<pubDate>Tue, 30 Apr 2019 12:28:25 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=226</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>注意对比克鲁斯卡尔算法!</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>时间复杂度O(n^2)(基础方法：邻接矩阵存图)，优化不会。。。适用于密集图。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>该算法被数个人于不同时间发现，普里姆不是第一个，也不是第二个。。。(别问我为什么以他的名字命名O_O)</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><del>数据结构课本上讲的真的是一坨屎。</del></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>正文：</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>首先，任选一点当作起始点，选哪个都一样。有两个集合，一个U，另一个V(别管课本怎么命名，怎么讲的了！)。 </p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>U集合存的是已经连起来的点(即当前构建的MST)，V存剩下的点，U刚开始只有一个起始点。 </p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>图图图图图图图图图图图(课本上的图，网上讲Prim的也都是这张图图，自己去搜吧，各种颜色各种大小都有，真棒！滑稽.jpg)</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">lowcost[]数组：<br>
lowcost[i],表示当前构建的MST到i点的权值，如果lowcost[i] == 0，说明i点已经在当前的MST中了。<br>
if lowcost[i] = INF,意为当前MST到i点无路径(就是没一条线直接连着).</pre>
<!-- /wp:preformatted -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">mst[]数组：<br>
mst[i],表示V中能直接连上MST的点的有最小权值那一条路径的终点(U中的点)(fuck!看例子),mst[i] == 0表示i点连上了 </pre>
<!-- /wp:preformatted -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">例：当只有一个v1点时，<br>
MST(U)上只有1个点v1时。<br>
此时mst[]数组均初始化为1.<br>
lowcost[2] == 6 ;<br>
lowcost[3] == 1 ;<br>
lowcost[4] == 5;<br>
lowcost[5] == INF;<br>
lowcost[6] == INF;<br>
由图可知，(v1和v2)，(v1和v3)，(v1和v4)直接相连，而(v1和v5)，(v1和v6)没有直接相连。<br>
有最小权值显然是到v3点，连上。<br>
MST上又两个点了，更新lowbit[]和mst[]数组。<br>
lowcost[2] == 5;<br>
lowcost[3] == 0;<br>
lowcost[4] == 5;<br>
lowcost[5] == 6;<br>
lowcost[6] == 4;<br>
mst[2] == 3;///v2点到MST当前有两条线，(v2,v1)权值为6，(v2,v3)权值为5，显然到v3点权值小，所以mst[2] == 3;<br>
mst[3] == 0;///v3已经连上了，所以到MST的权值为0<br>
mst[4] == 1;///v4点到v1和到v3的权值一样，就没必要更新<br>
mst[5] == 3;<br>
mst[6] == 3;</pre>
<!-- /wp:preformatted -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">往后自己类推。<br>
算法思想其实很简单，一个贪心策略而已，关键是他的算法很巧妙，我只会自己用暴力写出这颗MST来，囧rz。<br>
滑稽.jpg.</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>好了code来了。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Code:</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>#include &lt;bits/stdc++.h>
using namespace std;
const int INF = 0x3f3f3f3f;
const int maxn = 1000 + 10;

int n;
int G[maxn][maxn];
int lowcost[maxn];
int mst[maxn];

int Prim(int sum,int G[][maxn]){
    for(int i = 1 ; i &lt;= n ; i++){///初始化mst数组和lowcost数组
        mst[i] = 1;
        lowcost[i] = G[1][i];
    }
    mst[1] = 0;
    ///
    int min_value , min_id;
    for(int i = 2 ; i &lt;= n ; i++){
        min_value = INF;
        min_id = 0;
        for(int j = 2 ; j &lt;= n ; j++){
            if(min_value > lowcost[j] &amp;&amp; lowcost[j] != 0){
                min_value = lowcost[j];
                min_id = j;
            }
        }
        ///
        cout&lt;&lt; "从点v" &lt;&lt; mst[min_id] &lt;&lt; "到点v" &lt;&lt; min_id &lt;&lt; "  权值 = " &lt;&lt; min_value &lt;&lt;'\n';
        ///mst数组记录上一个点(U中),以便输出路径,mst数组作用在此体现。
        ///
        sum += min_value;
        lowcost[min_id] = 0;
        for(int j = 2 ; j &lt;= n ; j++){///真暴力啊。
            if(lowcost[j] > G[min_id][j]){
                lowcost[j] = G[min_id][j];
                mst[j] = min_id;
            }
        }
    }
    return sum;
}

int main(){
    int t;
    scanf("%d %d",&amp;n,&amp;t);///n个点,t条边
    ///
    for(int i = 1 ; i &lt;= n ; i++){///初始化图G
        for(int j = 1 ; j &lt;= n ; j++){
            G[i][j] = INF;
        }
    }
    ///
    int a,b,c;
    for(int i = 1; i &lt;= t ; i++){///更新数据
        scanf("%d %d %d",&amp;a,&amp;b,&amp;c);
        G[a][b] = c;
        G[b][a] = c;
    }
    ///
//    for(int i = 1; i &lt;= n ; i++){///输出图,检测是否正确
//        for(int j = 1; j&lt;= n ;j++){
//            printf("%d ",G[i][j]);
//        }
//        printf("\n");
//    }
    ///
    cout&lt;&lt;"路径:\n";
    int z = Prim(0,G);
    ///
    cout&lt;&lt;"MST_value = "&lt;&lt;z&lt;&lt;'\n';
}
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>学会了之后，最好自己敲一遍，因为我的代码习惯和大多数人不同，所以我看别人的博客明白后，自己敲了我自己的风格的代码，舒服。。。。。</p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>226</wp:post_id>
		<wp:post_date><![CDATA[2019-04-30 20:28:25]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-04-30 12:28:25]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%99%ae%e9%87%8c%e5%a7%86%e7%ae%97%e6%b3%95prim-%e6%b1%82%e6%9c%80%e5%b0%8f%e7%94%9f%e6%88%90%e6%a0%91mst]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="mst"><![CDATA[图论__最小生成树]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[neve_meta_content_width]]></wp:meta_key>
		<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_content_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[90]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>克鲁斯卡尔算法(Kruskal)-求MST</title>
		<link>https://sdnuqp.cn/%e5%85%8b%e9%b2%81%e6%96%af%e5%8d%a1%e5%b0%94%e7%ae%97%e6%b3%95kruskal-%e6%b1%82mst/</link>
		<pubDate>Sat, 04 May 2019 13:13:29 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=234</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>注意对比普里姆算法</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>“加边法”<br>
时间复杂度O(eloge),e是边数,更适用于稀疏图。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>依然是基于贪心策略的算法。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>推荐讲解：</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>https://blog.csdn.net/junya_zhang/article/details/83584592(讲的很好)<br></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>http://data.biancheng.net/view/41.html(他的讲解也很好，代码就。。太乱了。。柑橘好高级)</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>code:


#include &lt;bits/stdc++.h>
using namespace std;

struct Point{
    int ver1;
    int ver2;
//    int edge;
    int weight;
}a[1010];

bool cmp(struct Point a, struct Point b){
    return a.weight &lt; b.weight;
}

int parent[1010];

int Find(int z){
    while(parent[z] > 0){
        z = parent[z];
    }
    return z;
}

void Kruskal(int _end){
    int n,m;
    for(int i = 1; i &lt;= _end ; i++){
        n = Find(a[i].ver1);
        m = Find(a[i].ver2);
        if(n != m){
            parent[n] = m;
            printf("%d %d %d\n",a[i].ver1,a[i].ver2,a[i].weight);
        }
    }
}

int main(){
    int n1,n2;///点数和边数
    scanf("%d %d",&amp;n1,&amp;n2);
    for(int i = 1 ; i &lt;= n2 ; i++){
        scanf("%d %d %d",&amp;a[i].ver1,&amp;a[i].ver2,&amp;a[i].weight);
    }
    sort(a+1,a+1+n2,cmp);

    Kruskal(n2);

    return 0 ;
}

/*

9 15
5 8 7
3 9 8
1 2 10
1 6 11
2 9 12
4 8 16
2 7 16
6 7 17
2 3 18
7 8 19
4 5 20
4 9 21
3 4 22
4 7 24
5 6 26

*/
</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>234</wp:post_id>
		<wp:post_date><![CDATA[2019-05-04 21:13:29]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-05-04 13:13:29]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%85%8b%e9%b2%81%e6%96%af%e5%8d%a1%e5%b0%94%e7%ae%97%e6%b3%95kruskal-%e6%b1%82mst]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="mst"><![CDATA[图论__最小生成树]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_oembed_9e67cc25b16f5858a1c9ef07b155ce22]]></wp:meta_key>
		<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[neve_meta_content_width]]></wp:meta_key>
		<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_content_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[90]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wp_old_slug]]></wp:meta_key>
		<wp:meta_value><![CDATA[%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84-%e5%85%8b%e9%b2%81%e6%96%af%e5%8d%a1%e5%b0%94-kruskal%e7%ae%97%e6%b3%95-%e6%b1%82mst]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wp_old_slug]]></wp:meta_key>
		<wp:meta_value><![CDATA[%e5%85%8b%e9%b2%81%e6%96%af%e5%8d%a1%e5%b0%94%e7%ae%97%e6%b3%95%ef%bc%88kruskal%ef%bc%89-%e6%b1%82mst]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_oembed_e24326d7a8e49081694a82faff875b52]]></wp:meta_key>
		<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>POJ-2481-Cows-树状数组</title>
		<link>https://sdnuqp.cn/poj-2481-cows-%e6%a0%91%e7%8a%b6%e6%95%b0%e7%bb%84/</link>
		<pubDate>Sun, 05 May 2019 08:14:51 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=237</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>我想说，我 TMD 终于把这题过了。。。。。。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>这道题并不难，莫名其妙的持续大脑混乱，样例死活不对。。。。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>AC code(附赠几个样例，滑稽.jpg)：</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>#include &lt;cstdio>
#include &lt;iostream>
#include &lt;algorithm>
#include &lt;cstring>
//#include &lt;bits/stdc++.h>
using namespace std;
const int maxn = 1e5 + 10;

int c[maxn];
int num[maxn];
int revise[maxn];
//int vis[maxn];
struct pp{
    int l;
    int r;
    int id;
}a[maxn];

bool cmp(struct pp a,struct pp b){
    if(a.r != b.r)
        return a.r > b.r;
    else
        return a.l &lt; b.l;
}

int lowbit(int x){
    return x&amp;(-x);
}

void update(int x,int y){
    while(x &lt;= y){
        c[x] += 1;
        x += lowbit(x);
    }
}

int getsum(int x){
    int ans = 0;
    while(x >= 1){
        ans += c[x];
        x -= lowbit(x);
    }
    return ans;
}

int main(){
    int n;
    int cnt ;
    int z;
    int maxx ;
    while(scanf("%d",&amp;n) &amp;&amp; n){
        maxx = -1;
        memset(c,0,sizeof c);
        memset(num,0,sizeof num);
        memset(revise,0, sizeof revise);
//        memset(vis,0,sizeof vis);
        for(int i = 1 ; i &lt;= n ; i++){
            scanf("%d %d",&amp;a[i].l,&amp;a[i].r);
            a[i].l += 1;
            a[i].r += 1;
            a[i].id = i;
            if(maxx &lt; a[i].r){
                maxx = a[i].r;
            }
        }
        sort(a+1,a+1+n,cmp);
        for(int i = 1 ; i &lt;= n ; i++){                   /////算有多少相同的区间(看看后面第二个样例)
            if(a[i].l == a[i-1].l &amp;&amp; a[i].r == a[i-1].r){
                if(a[i-1].l == a[i-2].l &amp;&amp; a[i-1].r == a[i-2].r){
                    revise[i] = revise[i-1] + 1;
                }
                else{
                    revise[i]++;
                }
            }
        }

        for(int i = 1 ; i &lt;= n ; i++){
//            if(vis[a[i].l] == 0){
                update(a[i].l,maxx);
//                vis[a[i].l] = 1;
//            }
            z = getsum(a[i].l);
//            printf("(%d %d)\n",getsum(maxx),getsum(a[i].l));
//            num[a[i].id] = z-1 ;                
            num[a[i].id] = z-1 - revise[i];      //////// z-1 ：去掉当前点
        }

        for(int i = 1 ; i &lt;= n ; i++){
            printf(i != n+1?"%d ":"%d",num[i]);
        }
        cout&lt;&lt;"\n";
    }
    return 0;
}



/*


3
1 2
0 3
3 4
0

7
3 4
0 3
0 3
0 2
0 2
0 2
1 2
0

4
0 4
1 2
0 3
3 4
0

*/</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>我刚开始想的是用二维数组的，但是明显的，要用10^10大小的数组，开不了。<br></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>正确思路应该是先排序，我是以区间右端从大到小排序，然后用区间左端更新区间，求前缀和。<br></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>思路一定要清晰！代码放这了。</p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>237</wp:post_id>
		<wp:post_date><![CDATA[2019-05-05 16:14:51]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-05-05 08:14:51]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[poj-2481-cows-%e6%a0%91%e7%8a%b6%e6%95%b0%e7%bb%84]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="bit"><![CDATA[数据结构__树状数组]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[neve_meta_content_width]]></wp:meta_key>
		<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_content_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[90]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>ZOJ-3492-Kagome Kagome-Java处理字符串</title>
		<link>https://sdnuqp.cn/zoj-3492-kagome-kagome-java%e5%a4%84%e7%90%86%e5%ad%97%e7%ac%a6%e4%b8%b2/</link>
		<pubDate>Sun, 05 May 2019 08:54:44 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=242</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>Visual code快让我崩溃了。我总是忘记保存，完全没有提示，下次打开，望着一个空文件，凌乱。。。。。。。。。。。。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>用java处理字符串比较麻烦</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>简单读取：</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">String s = in.nextLine();</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>但是像下面那个题一样给了几个字符串：XXXX XXX XXXXX<br></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>这就gg了。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>in.nextline直接读一行。<br></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>这是就要用切割字符串：<br></p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">String s = in.nextLine(); <br>String[] ss = new String[100];  <br>ss = s.split(" "); ///以“ ”(空格)作为切割点。<br></pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p> 切割成的子串只能以字符串数组来接受！</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>例题：</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>ZOJ-3492-Kagome Kagome</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>AC code:</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>import java.io.*;
import java.util.*;

public class Main {
	public static void main(String[] args) {
		Scanner in = new Scanner(new BufferedInputStream(System.in));
		int n;
		n = in.nextInt();
		int flag;
		int z;
		String s,sss,ssz;
		String[] sz = new String[110];
		String[] ss = new String[110];
		while(n-- >= 1) {
			z = in.nextInt();
			ssz = in.nextLine();
			sz = ssz.split(" ");
			ssz = sz[1];
//			System.out.println(z);
//			System.out.println(sz[1]);
			flag = 0;
			sss = in.nextLine();
			ss = sss.split(" ");
			for(int i = 0 ; i &lt; ss.length ; i++) {
				if(ss[i].equals(ssz)) {
					flag = i + ss.length/2;
					if(flag >= ss.length) {
						flag %= ss.length;
					}
				}
			}
			System.out.println(ss[flag]);
		}
	}
}</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p></p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>242</wp:post_id>
		<wp:post_date><![CDATA[2019-05-05 16:54:44]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-05-05 08:54:44]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[zoj-3492-kagome-kagome-java%e5%a4%84%e7%90%86%e5%ad%97%e7%ac%a6%e4%b8%b2]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="java"><![CDATA[基础__JAVA]]></category>
		<category domain="category" nicename="tijie"><![CDATA[题解]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[neve_meta_content_width]]></wp:meta_key>
		<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_content_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[90]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>ZOJ-4107-Singing Everywhere-BY Java</title>
		<link>https://sdnuqp.cn/244-2/</link>
		<pubDate>Sun, 05 May 2019 08:59:44 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=244</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>题目本身是一个模拟，水题，但我脑抽用了Java，正常输入输出超时，还要加上输入输出挂。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>AC code：</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>import java.io.*;
import java.math.*;
import java.util.*;

public class Main {

	public static void main(String[] args) {
//		Scanner in = new Scanner(new BufferedInputStream(System.in));
		InputReader in = new InputReader();
        PrintWriter out = new PrintWriter(System.out);
		int t = in.nextInt();
		int n;
		int sum, maxx;/*0/1/2*/
		int[] a = new int[100010];
		while (t-- >= 1) {
			sum = 0;
			n = in.nextInt();
			for (int i = 1; i &lt;= n; i++) {
				a[i] = in.nextInt();
			}
			if (n == 1 || n == 2 || n == 3) {
				System.out.println(0);
				continue;
			}
			for (int i = 2; i &lt;= n-1; i++) {
				if (a[i - 1] &lt; a[i] &amp;&amp; a[i] > a[i + 1]) {
					sum++;
				}
			}
			if (sum == 0) {
				System.out.println(0);
				continue;
			}
//			System.out.println(sum);
			maxx = 0;
			if (a[1] &lt; a[2] &amp;&amp; a[2] > a[3]) {
				maxx = 1;
			} else if (a[n - 2] &lt; a[n - 1] &amp;&amp; a[n - 1] > a[n]) {
				maxx = 1;
			} else {
				;
			}
			for (int i = 2; i &lt;= n - 1; i++) {
				if (a[i - 1] &lt; a[i] &amp;&amp; a[i] > a[i + 1]) {
					if (a[i - 1] != a[i + 1]) {
						if (i >= 3) {
							if (a[i - 1] > a[i + 1] &amp;&amp; a[i - 2] >= a[i - 1]) {
								maxx = Math.max(maxx, 1);
							}
						} else if (i >= n - 2) {
							if (a[i - 1] &lt; a[i + 1] &amp;&amp; a[i + 1] &lt;= a[i + 2]) {
								maxx = Math.max(maxx, 1);
							}
						}
					}
				} else if (i >= 3 &amp;&amp; i &lt;= n - 2) {
					if (a[i - 2] &lt; a[i - 1] &amp;&amp; a[i - 1] > a[i] &amp;&amp; a[i] &lt; a[i + 1] &amp; a[i + 1] > a[i + 2]) {
						if (a[i - 1] == a[i + 1])
							maxx = 2;
						else
							maxx = Math.max(maxx, 1);
					}
				}
			}
//			System.out.println(maxx);
			System.out.println(sum - maxx);
		}
        out.close();
	}
}

class InputReader
{
    BufferedReader buf;
    StringTokenizer tok;
    InputReader()
    {
        buf = new BufferedReader(new InputStreamReader(System.in));
    }
    boolean hasNext()
    {
        while(tok == null || !tok.hasMoreElements()) 
        {
            try
            {
                tok = new StringTokenizer(buf.readLine());
            } 
            catch(Exception e) 
            {
                return false;
            }
        }
        return true;
    }
    String next()
    {
        if(hasNext()) return tok.nextToken();
        return null;
    }
    int nextInt()
    {
        return Integer.parseInt(next());
    }
    long nextLong()
    {
        return Long.parseLong(next());
    }
    double nextDouble()
    {
        return Double.parseDouble(next());
    }
    BigInteger nextBigInteger()
    {
        return new BigInteger(next());
    }
    BigDecimal nextBigDecimal()
    {
        return new BigDecimal(next());
    }
}</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>244</wp:post_id>
		<wp:post_date><![CDATA[2019-05-05 16:59:44]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-05-05 08:59:44]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[244-2]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="java"><![CDATA[基础__JAVA]]></category>
		<category domain="category" nicename="tijie"><![CDATA[题解]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[neve_meta_content_width]]></wp:meta_key>
		<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_content_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[90]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>ZOJ-4108-Fibonacci in the Pocket-Java大数取余</title>
		<link>https://sdnuqp.cn/248-2/</link>
		<pubDate>Sun, 05 May 2019 09:06:32 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=248</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:preformatted -->
<pre class="wp-block-preformatted">一个模拟，我WA了好几次，崩溃。<br> 要注意的是大数取余：<br> BigInteger a = in.nextBigInteger();<br> BigInteger three = BigInteger.valueOf(3);<br> BigInteger num1[] = a.divideAndRemainder(three);<br> 用一个数组调用divideAndRemainder方法能够同时获得大数除，和余数。<br> num[0] 是除的结果，num[1] 是余数<br></pre>
<!-- /wp:preformatted -->

<!-- wp:code -->
<pre class="wp-block-code"><code>AC code:
import java.io.*;
import java.math.*;
import java.util.Scanner;

public class Main {

	public static void main(String args[]) {
		Scanner in = new Scanner(new BufferedInputStream(System.in));
		int t = in.nextInt();
		while (t-- >= 1) {
			BigInteger a = in.nextBigInteger();
			BigInteger b = in.nextBigInteger();
			BigInteger num1[] = a.divideAndRemainder((BigInteger.valueOf(3)));
			BigInteger num2[] = b.divideAndRemainder((BigInteger.valueOf(3)));
			if (num1[0].compareTo(num2[0]) == 0) {
				if (num1[1].compareTo(num2[1]) == 0) {
					if (num1[1].compareTo(BigInteger.valueOf(1)) == 0 || num2[1].compareTo(BigInteger.valueOf(2)) == 0)
						System.out.println(1);
					else if (num1[1].compareTo(BigInteger.valueOf(0)) == 0)
						System.out.println(0);
				} else {
					if ((num1[1].compareTo(BigInteger.valueOf(1)) == 0) &amp;&amp; (num2[1].compareTo(BigInteger.valueOf(2)) == 0))
						System.out.println(0);
					else if ((num1[1].compareTo(BigInteger.valueOf(1)) == 0) &amp;&amp; (num2[1].compareTo(BigInteger.valueOf(0)) == 0))
						System.out.println(0);
					else if ((num1[1].compareTo(BigInteger.valueOf(2)) == 0) &amp;&amp; (num2[1].compareTo(BigInteger.valueOf(0)) == 0))
						System.out.println(1);
				}
				continue;
			}
			if (num1[1].compareTo(BigInteger.valueOf(1)) == 0) {
				if (num2[1].compareTo(BigInteger.valueOf(1)) == 0) {
					System.out.println(1);
				} else if (num2[1].compareTo(BigInteger.valueOf(2)) == 0) {
					System.out.println(0);
				} else {
					System.out.println(0);
				}
			} else if (num1[1].compareTo(BigInteger.valueOf(2)) == 0) {
				if (num2[1].compareTo(BigInteger.valueOf(1)) == 0) {
					System.out.println(0);
				} else if (num2[1].compareTo(BigInteger.valueOf(2)) == 0) {
					System.out.println(1);
				} else {
					System.out.println(1);
				}
			} else {
				if (num2[1].compareTo(BigInteger.valueOf(1)) == 0)
					System.out.println(1);
				else if (num2[1].compareTo(BigInteger.valueOf(2)) == 0) {
					System.out.println(0);
				} else {
					System.out.println(0);
				}
			}
		}
	}
}</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>248</wp:post_id>
		<wp:post_date><![CDATA[2019-05-05 17:06:32]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-05-05 09:06:32]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[248-2]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="java"><![CDATA[基础__JAVA]]></category>
		<category domain="category" nicename="tijie"><![CDATA[题解]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[neve_meta_content_width]]></wp:meta_key>
		<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_content_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[60]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>高斯消元法</title>
		<link>https://sdnuqp.cn/%e9%ab%98%e6%96%af%e6%b6%88%e5%85%83%e6%b3%95/</link>
		<pubDate>Sun, 05 May 2019 13:56:45 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=252</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>我的依然有很多漏洞的算法：</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>


///
#include &lt;bits/stdc++.h>
using namespace std;
#define Elemtype double
const int maxn = 1000;
const Elemtype eps = 1e-8;
Elemtype a[maxn][maxn];
Elemtype vis[maxn];
int num[maxn];

void matrix(Elemtype a[][maxn],int n, int m) {
    for(int i = 1 ; i &lt;= n ; i++) {
        for(int j = 1; j &lt;= m ; j++) {
            printf("%f ",a[i][j]);
        }
        printf("\n");
    }
    cout&lt;&lt;"\n";
}

void Guass(Elemtype a[][maxn], int n,int m) {
    for(int i = 1 ; i &lt;= n ; i++) {
        if(fabs(a[i][i]) &lt;= eps) {
            continue;
        }

        matrix(a,n,m);
        for(int k = i+1 ; k &lt;= n ; k++) {
            vis[k] = a[k][i]/a[i][i];
        }

        for(int k = i+1 ; k &lt;= n ; k++){
            for(int j = i ; j &lt;= m ; j++){
                a[k][j] -= vis[k]*a[i][j];
            }
        }
    }
}

int solution(Elemtype a[][maxn],int n, int m){
    for(int i = n ; i >= 1; i--){
        for(int j = m-1 ; j >= 1 ; j--){
            if(fabs(a[i][j]) > eps){
                num[i]++;
            }
        }
    }

//    for(int i = 1; i &lt;= n ; i++){
//        printf("%d \n",num[i]);
//    }
    for(int i = n ; i >= 1 ; i--){
        if(num[i] == 0 &amp;&amp; a[i][m] > 0){
            return -1;
        }
        if(num[i] > m-i){
            return 1;
        }
    }

    return 0;
}

int main() {
    int n,m ;
    scanf("%d %d",&amp;n,&amp;m);
    for(int i = 1; i &lt;= n ; i++) {
        for(int j = 1 ; j &lt;= m ; j++) {
            scanf("%lf",&amp;a[i][j]);
        }
    }
    cout&lt;&lt;"\n";

    Guass(a,n,m);

    int flag = solution(a,n,m);

    if(flag > 0){
        printf("有无数个解");
    }
    else if(flag &lt; 0){
        printf("无解");
    }
    else{
        printf("有解");
    }
    return 0;
}

/*

3 3
1 1 2
1 -2 -1
0 1 2

*/

</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>252</wp:post_id>
		<wp:post_date><![CDATA[2019-05-05 21:56:45]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-05-05 13:56:45]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e9%ab%98%e6%96%af%e6%b6%88%e5%85%83%e6%b3%95]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e6%95%b0%e8%ae%ba__%e9%ab%98%e6%96%af%e6%b6%88%e5%85%83"><![CDATA[数论__高斯消元]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[neve_meta_content_width]]></wp:meta_key>
		<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_content_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[60]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>N阶行列式计算器</title>
		<link>https://sdnuqp.cn/n%e9%98%b6%e8%a1%8c%e5%88%97%e5%bc%8f%e8%ae%a1%e7%ae%97%e5%99%a8/</link>
		<pubDate>Tue, 07 May 2019 10:41:37 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=255</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:code -->
<pre class="wp-block-code"><code>#include &lt;bits/stdc++.h>
using namespace std;

int a[101][101];
int b[101];

int main()
{
    int n,sum=0;
    printf("请输入几阶行列式：");
    scanf("%d",&amp;n);
    for(int i=1;i&lt;=n;i++){
        for(int j=1;j&lt;=n;j++){
            scanf("%d",&amp;a[i][j]);
        }
    }

    for(int i=1;i&lt;=n;i++){
        b[i]=i;
    }
    int ci=1;
    for(int i=1;i&lt;=n;i++){
        ci*=i;
    }
    for(int k=1;k&lt;=ci;k++){
        int flag=0;
        for(int i=1; i&lt;=n; i++){
            for(int j=n;j>=i;j--){
                if(b[j]>b[i]){
                    flag++;
                }
            }
        }
        int x=1;
        for(int h=1; h&lt;=n; h++){
            x*=a[h][b[h]];
        }
        if(flag%2){//+
            sum+=x;
        }
        else{//-
            sum-=x;
        }
        next_permutation(b+1,b+1+n);
    }
    printf("%d",sum);
}</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>255</wp:post_id>
		<wp:post_date><![CDATA[2019-05-07 18:41:37]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-05-07 10:41:37]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[n%e9%98%b6%e8%a1%8c%e5%88%97%e5%bc%8f%e8%ae%a1%e7%ae%97%e5%99%a8]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="sundry"><![CDATA[杂项]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[neve_meta_content_width]]></wp:meta_key>
		<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_content_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[60]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>HDU-5056-Boring count-尺取(滑动窗口)</title>
		<link>https://sdnuqp.cn/hdu-5056-boring-count-%e5%b0%ba%e5%8f%96%e6%bb%91%e5%8a%a8%e7%aa%97%e5%8f%a3/</link>
		<pubDate>Tue, 07 May 2019 10:54:39 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=258</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>这个题刚开时毫无头绪，后来才知道这种算法。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>这个题有个漏洞，不同位置截出来的相同子串，算是两个子串。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>其他的没什么了，注意 long long int</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>#include &lt;cstdio>
#include &lt;iostream>
#include &lt;cstring>
#include &lt;algorithm>
using namespace std;

int N,pre,n,sum,x;
int a[27];
char s[100010];

int main() {
    scanf("%d",&amp;N);
    while(N--) {
        scanf("%s",&amp;s);
        scanf("%d",&amp;n);
        pre = 0;
        long long sum = 0;
        memset(a,0,sizeof(a));
        x = strlen(s);
        for(int i = 0; i &lt; x; i++) {
            a[s[i]-'a']++;
            while(a[s[i]-'a']>n) {
                a[s[pre]-'a']--;
                pre++;
            }
            sum += i - pre + 1;
        }
        printf("%lld\n",sum);
    }
    return 0;
}</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>258</wp:post_id>
		<wp:post_date><![CDATA[2019-05-07 18:54:39]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-05-07 10:54:39]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu-5056-boring-count-%e5%b0%ba%e5%8f%96%e6%bb%91%e5%8a%a8%e7%aa%97%e5%8f%a3]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="tijie"><![CDATA[题解]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[neve_meta_content_width]]></wp:meta_key>
		<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_content_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[90]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>ZOJ-3950-How Many Nines-思维+模拟</title>
		<link>https://sdnuqp.cn/zoj-3950-how-many-nines-%e6%80%9d%e7%bb%b4%e6%a8%a1%e6%8b%9f/</link>
		<pubDate>Wed, 08 May 2019 14:07:24 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=264</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>代码极长，WA了三次，第一次忘记了同年的情况，第二次忘记了同月的情况，第三次是有一个地方忘了润年平年分情况。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>好垃圾的代码，打了5个表，结果好好没有发挥它的用处。。。后面一堆分类判断应该写函数的。。。好菜</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":266,"width":1109,"height":28} -->
<figure class="wp-block-image is-resized"><img src="https://sdnuqp.cn/wp-content/uploads/2019/05/TIM截图20190508220948-1024x26.png" alt="" class="wp-image-266" width="1109" height="28"/></figure>
<!-- /wp:image -->

<!-- wp:code -->
<pre class="wp-block-code"><code>#include &lt;bits/stdc++.h>
using namespace std;

int mon1[13] = {0,31,29,31,30,31,30,31,31,30,31,30,31};
int mon2[13] = {0,31,28,31,30,31,30,31,31,30,31,30,31};
int is_mon[13] = {0,3,3,3,3,3,3,3,3,33,3,3,3};///闰年
int no_mon[13] = {0,3,2,3,3,3,3,3,3,33,3,3,3};
struct pp {
    int n9;
    int is;
} leap[10010];

int isleap(int year) { //1->29 0->28
    if(year%4 == 0 &amp;&amp; year%100 != 0) {
        return 1;
    } else if(year%400 == 0) {
        return 1;
    }
    return 0;
}

void fff() {
    int flag = 0;
    int n = 0;
    for(int i = 2000 ; i &lt;= 9999 ; i++) {
        leap[i].is = isleap(i);
        n = i;
        while(n) {
            flag = n%10;
            if(flag == 9) {
                leap[i].n9++;
            }
            n /= 10;
        }
    }
}


int main() {
    int n;
    int y1,y2,m1,m2,d1,d2;
    fff();
//    for(int i = 2000 ; i &lt;= 9999 ; i++){
//        printf("%d %d %d\n",i,leap[i].is,leap[i].n9);
//    }
    scanf("%d",&amp;n);
    int sum = 0;
    int is_y = 30 + 33 + 3;
    int no_y = 30 + 33 + 2;
    int is_yy = 366;
    int no_yy = 365;
    while(n--) {
        sum = 0;
        scanf("%d %d %d %d %d %d",&amp;y1,&amp;m1,&amp;d1,&amp;y2,&amp;m2,&amp;d2);
        if(y1 == y2 &amp;&amp; m1 == m2) { ///同年同月
            if(d1 &lt;= 9) {
                if(d2 >= 29) {
                    sum += 3;
                } else if(d2 >= 19) {
                    sum += 2;
                } else if(d2 >= 9) {
                    sum += 1;
                }
            } else if(d1 &lt;= 19) {
                if(d2 >= 29) {
                    sum += 2;
                } else if(d2 >= 19) {
                    sum += 1;
                }
            } else if(d1 &lt;= 29) {
                if(d2 >= 29) {
                    sum += 1;
                }
            }

            if(m1 == 9)
                sum += d2 - d1 + 1;
            sum += leap[y1].n9 * (d2-d1+1);
            printf("%d\n",sum);
            continue;
        }


        if(y1 != y2) {         ///年份不同
            for(int i = y1+1 ; i &lt;= y2-1 ; i++) {
                if(leap[i].is == 1) {
                    sum += is_y;
                } else
                    sum += no_y;

                if(leap[i].is) {
                    sum += leap[i].n9 * is_yy;
                } else {
                    sum += leap[i].n9 * no_yy;
                }
            }

            int num1 = 0,num2 = 0;
            for(int i = m1+1 ; i &lt;= 12; i++) {
                if(leap[y1].is) {
                    sum += is_mon[i];
                    num1 += mon1[i];
                } else {
                    sum += no_mon[i];
                    num1 += mon2[i];
                }
            }
            if(leap[y1].is){
                num1 += mon1[m1] - d1 + 1;
            }
            else{
                num1 += mon2[m1] - d1 + 1;
            }
            sum += leap[y1].n9 * num1;

            for(int i = 1 ; i &lt;= m2-1 ; i++) {
                if(leap[y2].is) {
                    sum += is_mon[i];
                    num2 += mon1[i];
                } else {
                    sum += no_mon[i];
                    num2 += mon2[i];
                }
            }
            num2 += d2;
            sum += leap[y2].n9 * num2;

        } else {    ///年份相同
            int num = 0 ;
            if(leap[y1].is) {
                for(int i = m1+1 ; i&lt;= m2-1 ; i++) {
                    num += mon1[i];
                }
                num += mon1[m1] - d1 + 1;
            } else {
                for(int i = m1+1 ; i&lt;= m2-1 ; i++) {
                    num += mon2[i];
                }
                num += mon2[m1] - d1 + 1;
            }
            num += d2 ;
            sum += num * leap[y1].n9 ;
            for(int i = m1+1 ; i &lt;= m2-1 ; i++) {
                if(leap[y2].is) {
                    sum += is_mon[i];
                } else {
                    sum += no_mon[i];
                }
            }
        }

//        printf("%d\n",sum);
        if(leap[y1].is == 0) {
            if(m1 == 2) {
                if(d1 &lt;= 9) {
                    sum += 2;
                } else if(d1 &lt;= 19) {
                    sum += 1;
                } else
                    ;
            } else if(m1 == 9) {
                if(d1 &lt;= 9) {
                    sum += 3;
                } else if(d1 &lt;= 19) {
                    sum += 2;
                } else if(d1 &lt;= 29) {
                    sum += 1;
                }
                sum += 30 - d1 + 1;
            } else {
                if(d1 &lt;= 9) {
                    sum += 3;
                } else if(d1 &lt;= 19) {
                    sum += 2;
                } else if(d1 &lt;= 29) {
                    sum += 1;
                }
            }
        } else {
            if(m1 == 2) {
                if(d1 &lt;= 9) {
                    sum += 3;
                } else if(d1 &lt;= 19) {
                    sum += 2;
                } else
                    sum += 1;
            } else if(m1 == 9) {
                if(d1 &lt;= 9) {
                    sum += 3;
                } else if(d1 &lt;= 19) {
                    sum += 2;
                } else if(d1 &lt;= 29) {
                    sum += 1;
                }
                sum += 30 - d1 + 1;
            } else {
                if(d1 &lt;= 9) {
                    sum += 3;
                } else if(d1 &lt;= 19) {
                    sum += 2;
                } else if(d1 &lt;= 29) {
                    sum += 1;
                }
            }
        }



//        printf("%d\n",sum);
        if(leap[y2].is == 0) {
            if(m2 == 2) {
                if(d2 >= 19) {
                    sum += 2;
                } else if(d2 >= 9) {
                    sum += 1;
                } else
                    ;
            } else if(m2 == 9) {
                if(d2 >= 29) {
                    sum += 3;
                } else if(d2 >= 19) {
                    sum += 2;
                } else if(d2 >= 9) {
                    sum += 1;
                }
                sum += d2;
            } else {
                if(d2 >= 29) {
                    sum += 3;
                } else if(d2 >= 19) {
                    sum += 2;
                } else if(d2 >= 9) {
                    sum += 1;
                }
            }
        } else {
            if(m2 == 2) {
                if(d2 >= 29) {
                    sum += 3;
                } else if(d2 >= 19) {
                    sum += 2;
                } else if(d2 >= 9) {
                    sum += 1;
                } else
                    ;
            } else if(m2 == 9) {
                if(d2 >= 29) {
                    sum += 3;
                } else if(d2 >= 19) {
                    sum += 2;
                } else if(d2 >= 9) {
                    sum += 1;
                }
                sum += d2;
            } else {
                if(d2 >= 29) {
                    sum += 3;
                } else if(d2 >= 19) {
                    sum += 2;
                } else if(d2 >= 9) {
                    sum += 1;
                }
            }
        }
        printf("%d\n",sum);
    }
}</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>虽然很菜，但这是我努力的结果，谁都不能否定！</p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>264</wp:post_id>
		<wp:post_date><![CDATA[2019-05-08 22:07:24]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-05-08 14:07:24]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[zoj-3950-how-many-nines-%e6%80%9d%e7%bb%b4%e6%a8%a1%e6%8b%9f]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="tijie"><![CDATA[题解]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[neve_meta_content_width]]></wp:meta_key>
		<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>最短路总结</title>
		<link>https://sdnuqp.cn/%e6%9c%80%e7%9f%ad%e8%b7%af%e6%80%bb%e7%bb%93/</link>
		<pubDate>Thu, 09 May 2019 11:22:06 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=269</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>传送门还没写好。。。</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">主要有3种{<br>     1.Dijkstra<br>     2.Frody<br>     3.Bellman-Ford<br> }及其优化。<br> 1 - 迪杰斯特拉算法(Dijkstra){<br>     1.1 邻接矩阵/临界表{<br>         ……<br>     }<br>     1.2 优先队列{<br>         ……<br>     }<br>     1.3 二叉堆优化{<br>         ……<br>     }<br> }<br> 2 - 弗洛伊德算法(Flody){<br>     ……<br> }<br> 2.2 按情况适当优化(从别人的博客摘的){<br>     1.跳过不存在的路径<br>     2.只用矩阵下三角<br>     3.利用矩阵对称性<br>     4.避免循环中大量调用函数。<br> }<br> 3 - 贝尔曼-福特算法(Bellman-Ford){<br>     3.1 基础算法{<br>         ……<br>     }<br>     3.2 队列优化，又名SPFA{<br>         3.2.1 SLF(Small Label First)，双端队列优化{<br>             ……<br>         }<br>         3.2.2 LLL(Large Label Last){<br>             ……<br>        }    <br>     }<br> }</pre>
<!-- /wp:preformatted -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>269</wp:post_id>
		<wp:post_date><![CDATA[2019-05-09 19:22:06]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-05-09 11:22:06]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%9c%80%e7%9f%ad%e8%b7%af%e6%80%bb%e7%bb%93]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="algorithm"><![CDATA[算法]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[neve_meta_content_width]]></wp:meta_key>
		<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>迪杰斯特拉算法(Dijkstra)</title>
		<link>https://sdnuqp.cn/%e8%bf%aa%e6%9d%b0%e6%96%af%e7%89%b9%e6%8b%89%e7%ae%97%e6%b3%95dijkstra/</link>
		<pubDate>Thu, 09 May 2019 11:28:21 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=271</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:code -->
<pre class="wp-block-code"><code>

#include &lt;bits/stdc++.h>
using namespace std;
const int maxn = 100 + 10;
const int INF = 0x3f3f3f3f;

int edge[maxn][maxn];
int dis[maxn];
int vis[maxn];

void Trausal(int *dis,int n);

void Dijkstra(int edge[][maxn],int n) {
    int minn;
    int id ;
    for(int i = 1; i &lt; n ; i++) {
        minn = INF;
        for(int j = 1; j &lt;= n; j++) {
            if(vis[j] == 0 &amp;&amp; dis[j] &lt; minn) {
                minn = dis[j];
                id = j;
            }
        }
        if(minn == INF) {
            break;
        }
        vis[id] = 1;
        for(int j = 1; j &lt;= n; j++)
            if(vis[j] == 0)
                dis[j] = min(dis[j],dis[id] + edge[id][j]);
    }
//    Trausal(dis,n);
    printf("%d\n",dis[n]);
}


void Trausal(int *dis,int n) {
    printf(">>>>>");
    for(int i = 1 ; i &lt;= n ; i++) {
        printf(" %d ",dis[i]);
    }
    printf("&lt;&lt;&lt;&lt;&lt;&lt;\n");
}

int main() {
    int n,m;
    int a,b,c;
    while(~scanf("%d %d",&amp;n,&amp;m) &amp;&amp; (n || m) ) {
        memset(vis,0,sizeof vis );
        memset(edge,0x3f,sizeof edge);
        memset(dis,0,sizeof dis);
        for(int i = 1; i &lt;= n ; i++) {
            edge[i][i] = 0;
        }

//        printf("%d\n",edge[1][2]);
        for(int i = 1; i &lt;= m ; i++) {
            scanf("%d %d %d",&amp;a,&amp;b,&amp;c);
            if(c &lt; edge[a][b]) {//可能有重边，有个题这里我没判重边，WA惨了。
                edge[a][b] = c;
                edge[b][a] = c;
            }
        }

        vis[1] = 1;
        for(int i = 1; i &lt;= n; i++) {
            dis[i] = edge[1][i];
        }

        Dijkstra(edge,n);
    }
    return 0 ;
}
</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>271</wp:post_id>
		<wp:post_date><![CDATA[2019-05-09 19:28:21]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-05-09 11:28:21]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e8%bf%aa%e6%9d%b0%e6%96%af%e7%89%b9%e6%8b%89%e7%ae%97%e6%b3%95dijkstra]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="data-structure"><![CDATA[数据结构__基础]]></category>
		<category domain="category" nicename="algorithm"><![CDATA[算法]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[neve_meta_content_width]]></wp:meta_key>
		<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
							<wp:comment>
			<wp:comment_id>27</wp:comment_id>
			<wp:comment_author><![CDATA[秦鹏]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1047907457@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://sdnuqp.cn</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[223.99.197.195]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2019-06-05 20:23:07]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2019-06-05 12:23:07]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[emmmmmm]]></wp:comment_content>
			<wp:comment_approved><![CDATA[0]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
							</wp:comment>
					</item>
					<item>
		<title>HDU-2553-N皇后问题-DFS</title>
		<link>https://sdnuqp.cn/hdu-2553-n%e7%9a%87%e5%90%8e%e9%97%ae%e9%a2%98-dfs/</link>
		<pubDate>Thu, 09 May 2019 13:34:13 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=273</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>这个题是个基础DFS深搜<br></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>但是这个题有个坑。<br></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>别看它给了N &lt;= 10 ,他问的可不只10次。。。。直接1到10打表存在数组里，他问什么O(1)复杂度直接输出。<br></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>秒过！，不然测试样例大概是问了你很多很多次N=10的时候。。。。。于是超时。。。。太TM奸诈了!?<br></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>这个题好久之前，刚学DFS和BFS时做的，那时我单独把10拿了出来才A了。。。。没想到啊，出题人如此奸诈，Orz.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>r_c[ ]数组：标记左斜；</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>c_r[ ]数组：标记右斜；</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>col[ ]数组：标记列；</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>从第一行往下深搜，所以不用标记行，每一次递推，就是往下移动一行，不用多说了吧，很简单那。</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>/*
N皇后问题
*/
#include &lt;bits/stdc++.h>
using namespace std;

int num[11];
int sum;
int N;
int way;
int col[25];
int c_r[25];
int r_c[25];

void DFS(int n){
    if(way == N){
        sum++;
        return;
    }
    if(n > N){
        return ;
    }
    for(int i = 1; i &lt;= N ; i++){
        if(!col[i] &amp;&amp; !c_r[N + n - i] &amp;&amp; !r_c[i+n]){
            col[i] = 1;
            c_r[N+n-i] = 1;
        r_c[i+n] = 1;
            way++;
            DFS(n+1);
            col[i] = 0;
            c_r[N+n-i] = 0;
        r_c[i+n] = 0;
            way--;
        }
    }
}

int main(){
    ios::sync_with_stdio(0);
    
    for(int i = 1; i &lt;= 10 ; i++){
        N = i;
        sum = 0;
        way = 0;
        memset(col,0,sizeof col);
        memset(r_c,0,sizeof r_c);
        memset(c_r,0,sizeof c_r);
        DFS(1);
        num[i] = sum;
    }
    while(cin>>N &amp;&amp; N){
        cout&lt;&lt;num[N]&lt;&lt;'\n';
    }
    return 0;
}</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p></p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>273</wp:post_id>
		<wp:post_date><![CDATA[2019-05-09 21:34:13]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-05-09 13:34:13]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu-2553-n%e7%9a%87%e5%90%8e%e9%97%ae%e9%a2%98-dfs]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="tijie"><![CDATA[题解]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[neve_meta_content_width]]></wp:meta_key>
		<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>“浪潮杯”第十届山东ACM省赛</title>
		<link>https://sdnuqp.cn/%e6%b5%aa%e6%bd%ae%e6%9d%af%e7%ac%ac%e5%8d%81%e5%b1%8a%e5%b1%b1%e4%b8%9cacm%e7%9c%81%e8%b5%9b/</link>
		<pubDate>Wed, 15 May 2019 11:44:20 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=284</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>5月12日比赛如期举行，307支队伍参赛，250支队伍排名，我们是幸运的150支队之一，虽然只是一个铜牌，但也很开心啦，到现在还觉得有点虚幻，去年3银1铜，今年2银5铜！比赛前真的没想过拿牌的，嘿，嘿嘿。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>比赛算是有惊无险吧，刚开始的3道水题，有一道因为边界条件TLE了两次，真的很难受，两次就是20*2分钟，第一次忘记x == 1的情况，然后改了，锤头顿足很遗憾，交了，又TLE了，一看题，x == 0 时也没考虑。。。直接心拔凉拔凉的。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>后来另一道水题，我光去注意题目给的一句话：结果不会超过10^6。所以没有用long long，但其实中间过程的数&lt;=10^19!结果是中间数除一个数后的结果。。。。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>菜是原罪。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>比赛后期，明显感觉力不从心，滚榜时看到大约银牌往哪上都是在最后一小时AC1到2道难题，铜牌区都Attempped后失败。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>我们队最后一直在做L题，做了大约2个小时也没能做出来。真的，正如老师所言，弱校拿牌全靠罚时，我们罚时很高，主要是有一道思维题，队友一语道破天机，啪啪啪，打完提交直接过了！拉回一些时间。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>这次本来觉得是济南大学两日游的，结果拿了个铜，比赛就是要放平心态，心态很重要，比赛时认真发挥就好了。</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":285,"align":"left","width":440,"height":585} -->
<div class="wp-block-image"><figure class="alignleft is-resized"><img src="https://sdnuqp.cn/wp-content/uploads/2019/05/IMG_20190512_165014-768x1024.jpg" alt="" class="wp-image-285" width="440" height="585"/><figcaption>fbtmdn</figcaption></figure></div>
<!-- /wp:image -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>284</wp:post_id>
		<wp:post_date><![CDATA[2019-05-15 19:44:20]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-05-15 11:44:20]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%b5%aa%e6%bd%ae%e6%9d%af%e7%ac%ac%e5%8d%81%e5%b1%8a%e5%b1%b1%e4%b8%9cacm%e7%9c%81%e8%b5%9b]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="sundry"><![CDATA[杂项]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[neve_meta_content_width]]></wp:meta_key>
		<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[专题一：简单搜索]POJ-1321-棋盘问题-DFS</title>
		<link>https://sdnuqp.cn/kaungbin%e5%b8%a6%e6%88%91%e9%a3%9e%e4%b8%93%e9%a2%98%e4%b8%80%ef%bc%9a%e7%ae%80%e5%8d%95%e6%90%9c%e7%b4%a2-1-poj-1321-%e6%a3%8b%e7%9b%98%e9%97%ae%e9%a2%98-dfs/</link>
		<pubDate>Thu, 16 May 2019 12:56:36 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=297</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:code -->
<pre class="wp-block-code"><code>#include &lt;cstdio>
#include &lt;iostream>
//#include &lt;bits/stdc++.h>
using namespace std;

int n,k;
int cnt;
char c[10][10];
bool vis[10][10];
bool cc[10];

void dfs(int x,int way){
    if(way == k){
        cnt++;
        return ;
    }
    if(x > n)
        return ;
    for(int i = 1; i &lt;= n ; i++){
        if(c[x][i] == '#' &amp;&amp; cc[i] == 0){
            cc[i] = 1;
            dfs(x+1,way+1);
            cc[i] = 0;
        }
    }
    dfs(x+1,way);
}

int main(){
    char chr;
    while(scanf("%d %d",&amp;n,&amp;k)!=EOF){
        if(n == -1 &amp;&amp; k == -1){
            break;
        }
        cnt = 0;
        getchar();
        for(int i = 1 ; i &lt;= n ; i++){
            for(int j = 1 ; j &lt;= n ; j++){
                scanf("%c",&amp;chr);
                c[i][j] = chr;
                if(chr == '#'){
                    vis[i][j] = 1;
                }
                else{
                    vis[i][j] = 0;
                }
            }
            getchar();
        }
        dfs(0,0);
        printf("%d\n",cnt);
    }
    return 0;
}</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>297</wp:post_id>
		<wp:post_date><![CDATA[2019-05-16 20:56:36]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-05-16 12:56:36]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[kaungbin%e5%b8%a6%e6%88%91%e9%a3%9e%e4%b8%93%e9%a2%98%e4%b8%80%ef%bc%9a%e7%ae%80%e5%8d%95%e6%90%9c%e7%b4%a2-1-poj-1321-%e6%a3%8b%e7%9b%98%e9%97%ae%e9%a2%98-dfs]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="kuangbin"><![CDATA[kuangbin专题]]></category>
		<category domain="category" nicename="tijie"><![CDATA[题解]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[neve_meta_content_width]]></wp:meta_key>
		<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wp_old_slug]]></wp:meta_key>
		<wp:meta_value><![CDATA[kaungbin%e4%b8%93%e9%a2%98%e4%b8%80%ef%bc%9a%e7%ae%80%e5%8d%95%e6%90%9c%e7%b4%a2-1-poj-1321-%e6%a3%8b%e7%9b%98%e9%97%ae%e9%a2%98-dfs]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[专题一：简单搜索]POJ-2251-Dungeon Master-BFS</title>
		<link>https://sdnuqp.cn/kuangbin%e5%b8%a6%e6%88%91%e9%a3%9e%e4%b8%93%e9%a2%98%e4%b8%80%ef%bc%9a%e7%ae%80%e5%8d%95%e6%90%9c%e7%b4%a2-2-poj-2251-dungeon-master-bfs/</link>
		<pubDate>Thu, 16 May 2019 12:58:40 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=299</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>刚开始忘记将搜过的点标记为0了，MLE。</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>#include &lt;cstdio>
#include &lt;queue>
using namespace std;

int L,R,C;
int zz,xx,yy;
int maxx;
int c[35][35][35];
bool vis[35][35][35];
int des[7][3] = {{0,0,0},{0,1,0},{0,-1,0},{1,0,0},{-1,0,0},{0,0,1},{0,0,-1}};
struct p {
    int z;
    int x;
    int y;
    int sum;
};
queue&lt;p>q;

bool check(p pq) {
    if(vis[pq.z][pq.x][pq.y] == 1 &amp;&amp; pq.x &lt;= R &amp;&amp; pq.x >= 1 &amp;&amp; pq.y &lt;= C &amp;&amp; pq.y >= 1 &amp;&amp; pq.z >= 1 &amp;&amp; pq.z &lt;= L) {
        return 1;
    } else
        return 0;
}

void bfs() {
    while(!q.empty()) {
        p ppp;
        p pp = q.front();
        q.pop();
        if(pp.x == xx &amp;&amp; pp.y == yy &amp;&amp; pp.z == zz) {
            maxx = pp.sum;
            return;
        }
        for(int i = 1 ; i &lt;= 6 ; i++) {
            ppp.z = pp.z + des[i][0];
            ppp.x = pp.x + des[i][1];
            ppp.y = pp.y + des[i][2];
            ppp.sum = pp.sum + 1;
            if(check(ppp) == 1) {
                q.push(ppp);
                vis[ppp.z][ppp.x][ppp.y] = 0;
            }
        }
    }
    return ;
}

int main() {
    while(scanf("%d %d %d",&amp;L,&amp;R,&amp;C)!=EOF &amp;&amp; (L||R||C)) {
        maxx = 10000;
        getchar();
        for(int k = 1; k &lt;= L ; k++) {
            for(int i = 1; i &lt;= R ; i++) {
                for(int j = 1 ; j &lt;= C ; j++) {
                    scanf("%c",&amp;c[k][i][j]);
                    if(c[k][i][j] == 'S') {
                        p pp;
                        pp.x = i;
                        pp.y = j;
                        pp.z = k;
                        pp.sum = 0;
                        q.push(pp);
                        c[k][i][j] = '.';
                    }
                    if(c[k][i][j] == 'E') {
                        c[k][i][j] = '.';
                        zz = k;
                        xx = i;
                        yy = j;
                    }
                    if(c[k][i][j] == '.') {
                        vis[k][i][j] = 1;
                    } else
                        vis[k][i][j] = 0;
                }
                getchar();
            }
            getchar();
        }
        bfs();
        while(!q.empty()) {
            q.pop();
        }

        printf(maxx == 10000?"Trapped!\n":"Escaped in %d minute(s).\n",maxx);

    }
    return 0;
}</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>299</wp:post_id>
		<wp:post_date><![CDATA[2019-05-16 20:58:40]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-05-16 12:58:40]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[kuangbin%e5%b8%a6%e6%88%91%e9%a3%9e%e4%b8%93%e9%a2%98%e4%b8%80%ef%bc%9a%e7%ae%80%e5%8d%95%e6%90%9c%e7%b4%a2-2-poj-2251-dungeon-master-bfs]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="kuangbin"><![CDATA[kuangbin专题]]></category>
		<category domain="category" nicename="tijie"><![CDATA[题解]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[neve_meta_content_width]]></wp:meta_key>
		<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[专题一：简单搜索]POJ-3278-Catch That Cow-BFS</title>
		<link>https://sdnuqp.cn/poj-3278-catch-that-cow-bfs/</link>
		<pubDate>Sun, 19 May 2019 13:43:08 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=302</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:code -->
<pre class="wp-block-code"><code>


#include &lt;cstdio>
#include &lt;queue>
//#include &lt;bits/stdc++.h>
using namespace std;

int n,k;
bool vis[100010];
struct p{
    int sum ;
    int x;
};
queue&lt;p>q;

bool check(p pp){
    if(pp.x >= 0 &amp;&amp; pp.x &lt;= 100000 &amp;&amp; vis[pp.x] == 0){
        return 1;
    }
    else{
        return 0;
    }
}

void bfs(){
    while(!q.empty()){
        p pp = q.front();
        q.pop();
        p pz;

        if(pp.x == k){
            printf("%d\n",pp.sum);
            return;
        }

        pz.x = pp.x * 2;
        pz.sum = pp.sum + 1;
        if(check(pz) == 1){
            vis[pz.x] = 1;
            q.push(pz);
        }

        pz.x = pp.x + 1;
        pz.sum = pp.sum + 1;
        if(check(pz) == 1){
            vis[pz.x] = 1;
            q.push(pz);
        }

        pz.x = pp.x - 1;
        pz.sum = pp.sum + 1;
        if(check(pz) == 1){
            vis[pz.x] = 1;
            q.push(pz);
        }
    }
    return ;
}

int main(){
    scanf("%d %d",&amp;n,&amp;k);

    p pp;
    pp.x = n;
    pp.sum = 0;
    q.push(pp);
    bfs();

    return 0;
}</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>302</wp:post_id>
		<wp:post_date><![CDATA[2019-05-19 21:43:08]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-05-19 13:43:08]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[poj-3278-catch-that-cow-bfs]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="kuangbin"><![CDATA[kuangbin专题]]></category>
		<category domain="category" nicename="tijie"><![CDATA[题解]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[neve_meta_content_width]]></wp:meta_key>
		<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[专题一：简单搜索]POJ-3126-Prime Path-BFS</title>
		<link>https://sdnuqp.cn/poj-3126-prime-path-bfs/</link>
		<pubDate>Sun, 19 May 2019 13:47:05 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=304</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:code -->
<pre class="wp-block-code"><code>


//#include &lt;bits/stdc++.h>
#include &lt;cstdio>
#include &lt;queue>
#include &lt;algorithm>
#include &lt;cstring>
using namespace std;

int a,b;
int n;
int prime[10010];
int vis[10010];

struct p {
    int num;
    int id;
};

void isprime() {
    for(int i = 2 ; i &lt;= 10000 ; i++) {
        if(prime[i] == 0) {
            for(int j = 2 * i ; j &lt;= 10000 ; j += i) {
                prime[j] = 1;
            }
        }
    }
}

queue&lt;p>q;

int bfs(int x) {
    p pz;
    pz.num = x;
    pz.id = 0;
    q.push(pz);
    int nm;
    while(!q.empty()) {
        p z = q.front();
        q.pop();

        if(z.num == b) {
            printf("%d\n",z.id);
            while(!q.empty()) {
                q.pop();
            }
            return 1;
        }

        nm = z.num % 10;
        for(int i = 1 ; i &lt;= 9 - nm ; i++) {
            if(!prime[z.num + i] &amp;&amp; !vis[z.num + i]) {
                p zz = z;
                zz.id = z.id + 1;
                zz.num = z.num + i;
                vis[z.num + i] = 1 ;
                q.push(zz);
            }
        }

        nm = z.num / 10 % 10 ;
        for(int i = 1 ; i &lt;= 9 - nm ; i++) {
            if(!prime[z.num + i * 10] &amp;&amp; !vis[z.num + i * 10]) {
                p zz = z;
                zz.id = z.id + 1;
                zz.num = z.num + i * 10;
                vis[z.num + i * 10] = 1;
                q.push(zz);
            }
        }

        nm = z.num / 100 % 10 ;
        for(int i = 1 ; i &lt;= 9 - nm ; i++) {
            if(!prime[z.num + i * 100] &amp;&amp; !vis[z.num + i * 100]) {
                p zz = z;
                zz.id = z.id + 1;
                zz.num = z.num + i * 100;
                vis[z.num + i * 100] = 1;
                q.push(zz);
            }
        }

        nm = z.num / 1000;
        for(int i = 1 ; i &lt;= 9 - nm ; i++) {
            if(!prime[z.num + i * 1000] &amp;&amp; !vis[z.num + i * 1000]) {
                p zz = z;
                zz.id = z.id + 1;
                zz.num = z.num + i * 1000;
                vis[z.num + i * 1000] = 1;
                q.push(zz);
            }
        }
        ///
        nm = z.num % 10;

//        printf(">>>\n");
        for(int i = 1 ; i &lt; nm ; i++) {
            i *= -1;
            if(!prime[z.num + i] &amp;&amp; !vis[z.num + i]) {
                p zz = z;
                zz.id = z.id + 1;
                zz.num = z.num + i;
                vis[z.num + i] = 1 ;
                q.push(zz);
            }
            i *= -1;
        }

        nm = z.num / 10 % 10 ;
        for(int i = 1 ; i &lt;= nm ; i++) {
            i *= -1;
            if(!prime[z.num + i * 10] &amp;&amp; !vis[z.num + i * 10]) {
                p zz = z;
                zz.id = z.id + 1;
                zz.num = z.num + i * 10;
                vis[z.num + i * 10] = 1;
                q.push(zz);
            }
            i *= -1;
        }

        nm = z.num / 100 % 10 ;
        for(int i = 1 ; i &lt;= nm ; i++) {
            i *= -1;
            if(!prime[z.num + i * 100] &amp;&amp; !vis[z.num + i * 100]) {
                p zz = z;
                zz.id = z.id + 1;
                zz.num = z.num + i * 100;
                vis[z.num + i * 100] = 1;
                q.push(zz);
            }
            i *= -1;
        }

        nm = z.num / 1000;
        for(int i = 1 ; i &lt; nm ; i++) {
            i *= -1;
            if(!prime[z.num + i * 1000] &amp;&amp; !vis[z.num + i * 1000]) {
                p zz = z;
                zz.id = z.id + 1;
                zz.num = z.num + i * 1000;
                vis[z.num + i * 1000] = 1;
                q.push(zz);
            }
            i *= -1;
        }

        ///

    }
    return 0;
}

int main() {
    scanf("%d",&amp;n);
    isprime();
//    for(int i = 2; i &lt;= 10000 ; i++){
//        if(!prime[i])
//            printf("%d\n",i);
//    }
    for(int i = 1; i &lt;= n ; i++) {
        memset(vis,0,sizeof vis);
        scanf("%d %d",&amp;a,&amp;b);
        if(bfs(a)) {
            ;
        } else {
            printf("IMPOSSIBLE\n");
        }
    }
    return 0;
}


/*

1
1033 8179

1
1373 8017

*/
</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>304</wp:post_id>
		<wp:post_date><![CDATA[2019-05-19 21:47:05]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-05-19 13:47:05]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[poj-3126-prime-path-bfs]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="kuangbin"><![CDATA[kuangbin专题]]></category>
		<category domain="category" nicename="tijie"><![CDATA[题解]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[neve_meta_content_width]]></wp:meta_key>
		<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[专题一：简单搜索]POJ-3279-Fliptile-二进制枚举</title>
		<link>https://sdnuqp.cn/poj-3279-fliptile-%e4%ba%8c%e8%bf%9b%e5%88%b6%e6%9e%9a%e4%b8%be/</link>
		<pubDate>Sun, 19 May 2019 13:48:19 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=306</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:code -->
<pre class="wp-block-code"><code>



#include &lt;cstdio>
#include &lt;iostream>
#include &lt;cstring>
#include &lt;algorithm>
using namespace std;

int m,n;
int a[20][20];
int mp[20][20];
int vis[20][20];
int fl[20];
int fg;

void mark(int x,int y,int mp[][20]) {
    if(x >= 0 &amp;&amp; x &lt; m &amp;&amp; y >= 0 &amp;&amp; y &lt; n) {
        mp[x][y] = 1 - mp[x][y];
    }
}

void check_it(int x,int y,int mp[][20]) {
    vis[x][y] = 1;
    mark(x,y,mp);
    mark(x-1,y,mp);
    mark(x+1,y,mp);
    mark(x,y+1,mp);
    mark(x,y-1,mp);
}

int main() {
    scanf("%d %d",&amp;m,&amp;n);
    for(int i = 0;  i &lt; m; i++) {
        for(int j = 0; j &lt; n ; j++) {
            scanf("%d",&amp;a[i][j]);
        }
    }

    int ll = 1 ;
    for(int i = 0; i &lt; (1 &lt;&lt; n) ; i++) {
        for(int j = 0 ; j &lt; n ; j++) {
            if(i &amp; (1 &lt;&lt; j)) {
                fl[j] = 1;
            } else
                fl[j] = 0;
        }

        for(int j = 0 ; j &lt; m ; j++) {
            for(int k = 0 ; k &lt; n ; k++) {
                mp[j][k] = a[j][k];
            }
        }

        for(int j = 0 ; j &lt; n ; j++) {
            if(fl[j]) {
                check_it(0,j,mp);
            }
        }

//        printf("&lt;&lt;&lt;\n");
//        for(int j = 0 ; j &lt; n ; j++) {
//            printf("%d ",fl[j]);
//        }
//        printf("\n");
//        printf(">>\n");
//
//        for(int j = 0 ; j &lt; m ; j++) {
//            for(int k = 0; k &lt; n ; k++) {
//                printf("%d ",mp[j][k]);
//            }
//            printf("\n");
//        }
//        printf("&lt;>\n");

        for(int j = 1 ; j &lt; m ; j++) {
            for(int k = 0 ; k &lt; n ; k++) {
                if(mp[j-1][k] == 1) {
                    check_it(j,k,mp);
                }
            }
        }

//        for(int j = 0 ; j &lt; m ; j++) {
//            for(int k = 0; k &lt; n ; k++) {
//                printf("%d ",mp[j][k]);
//            }
//            printf("\n");
//        }
//        printf("&lt;>\n");

        int zl = 1;

        for(int j = 0 ; j &lt; n ; j++) {
            if(mp[m-1][j] == 1) {
                zl = 0;
            }
        }

//        printf("(%d)\n",zl);
//        for(int j = 0 ; j &lt; m ; j++) {
//            for(int k = 0; k &lt; n ; k++) {
//                printf("%d ",mp[j][k]);
//            }
//            printf("\n");
//        }
//        printf("&lt;>\n");

        if(zl == 0) {
            memset(vis,0,sizeof vis);
            continue;
        } else {
            ll = 0;
        }
        if(ll == 0) {
            for(int j = 0 ; j &lt; m ; j++) {
                for(int k = 0 ; k &lt; n ; k++) {
                    printf(k == n-1?"%d":"%d ",vis[j][k]);
                }
                printf("\n");
            }
            break;
        } else {
            memset(vis,0,sizeof vis);
        }
    }
    if(ll) {
        printf("IMPOSSIBLE");
    }
    return 0;
}

/*
4 2
1 1
1 0
0 0
0 0
*/</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>306</wp:post_id>
		<wp:post_date><![CDATA[2019-05-19 21:48:19]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-05-19 13:48:19]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[poj-3279-fliptile-%e4%ba%8c%e8%bf%9b%e5%88%b6%e6%9e%9a%e4%b8%be]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="kuangbin"><![CDATA[kuangbin专题]]></category>
		<category domain="category" nicename="tijie"><![CDATA[题解]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[neve_meta_content_width]]></wp:meta_key>
		<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[专题一：简单搜索]POJ-1426-Find The Multiple-DFS/BFS</title>
		<link>https://sdnuqp.cn/poj-1426-find-the-multiple-dfs-bfs/</link>
		<pubDate>Wed, 22 May 2019 11:57:09 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=314</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:code -->
<pre class="wp-block-code"><code>/// 1

#include &lt;bits/stdc++.h>
using namespace std;

const int M = (int)1e2;

bool flag;
int ans[M + 5];

void dfs(int pos, int k, int n) {
    if(flag || pos > M)
        return;
    if(!k) {
        flag = 1;
        ans[pos] = -1;
        return;
    }
    ans[pos] = 0;
    dfs(pos + 1, (k * 10) % n, n);
    if(flag || pos > M)
        return;
    ans[pos] = 1;
    dfs(pos + 1, (k * 10 + 1) % n, n);
    if(flag || pos > M)
        return;
}

int main() {
    int n;
    while(~scanf("%d",&amp;n) &amp;&amp; n) {
        memset(ans,  0, sizeof(ans));
        flag = 0;
        ans[1] = 1;
        dfs(2, 1 % n, n);
        for(int i = 1; ~ans[i]; ++i)
            printf("%d", ans[i]);
        printf("\n");
    }
    return 0;
}


/// 2

#include&lt;iostream>
#include&lt;stdio.h>
#include&lt;queue>
using namespace std;
void bfs(int n)
{
    queue&lt;long long>q;
    q.push(1);
    while(!q.empty())
    {
        int i;
        long long x;
        x=q.front();
        q.pop();
        if(x%n==0)
        {
            printf("%lld\n",x);
            return ;
        }
        q.push(x*10);
        q.push(x*10+1);
    }
}
int main()
{
    int n;
    while(scanf("%d",&amp;n)&amp;&amp;n)
    {
        bfs(n);
    }
    return 0;
}</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>314</wp:post_id>
		<wp:post_date><![CDATA[2019-05-22 19:57:09]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-05-22 11:57:09]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[poj-1426-find-the-multiple-dfs-bfs]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="kuangbin"><![CDATA[kuangbin专题]]></category>
		<category domain="category" nicename="tijie"><![CDATA[题解]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[neve_meta_content_width]]></wp:meta_key>
		<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[专题一：简单搜索]UVA-11624-Fire!-BFS</title>
		<link>https://sdnuqp.cn/uva-11624-fire-bfs/</link>
		<pubDate>Wed, 22 May 2019 11:57:52 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=316</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:code -->
<pre class="wp-block-code"><code>
#include &lt;bits/stdc++.h>
using namespace std;

int n,m;
int cx,cy;
int fx,fy;
int c[1010][1010];
int vis[1010][1010];
int mark[1010][1010];
int des[5][2] = {{0,0},{0,1},{0,-1},{1,0},{-1,0}};

struct p {
    int x;
    int y;
};

bool check(int x,int y){
    if(x >= 1 &amp;&amp; x &lt;= n &amp;&amp; y >= 1 &amp;&amp; y &lt;= m &amp;&amp; c[x][y] == '.' &amp;&amp; vis[x][y] == 0){
        return 1 ;
    }
    return 0;
}

bool ex_check(int x,int y){
    if(x >= 1 &amp;&amp; x &lt;= n &amp;&amp; y >= 1 &amp;&amp; y &lt;= m &amp;&amp; c[x][y] == '.'){
        return 1 ;
    }
    return 0;
}

queue&lt;p>q1;///火

void bfs(){
//    p p1;
//    p1.x = x;
//    p1.y = y;
//    vis[x][y] = 1;
//    q1.push(p1);
//    p p2;
//    p2.x = fx;
//    p2.y = fy;
    while(!q1.empty()){
        p pp = q1.front();
        q1.pop() ;
        p pz ;
//        printf("%d %d\n",pp.x,pp.y);
        for(int i = 1; i &lt;= 4 ; i++){
            pz.x = pp.x + des[i][0] ;
            pz.y = pp.y + des[i][1] ;
            if(check(pz.x,pz.y)){
                if(vis[pz.x][pz.y] == 0)
                    vis[pz.x][pz.y] = vis[pp.x][pp.y] + 1;
                else{
                    vis[pz.x][pz.y] = min(vis[pz.x][pz.y],vis[pp.x][pp.y] + 1);
                }
                q1.push(pz) ;
            }
        }
    }
}

struct person {
    int x;
    int y;
    int cnt;
};

queue&lt;person>q2;///人
int ex_bfs(int x,int y){
    person pr;
    pr.x = x;
    pr.y = y;
    pr.cnt = 1;
    q2.push(pr);
    int minn = 1000000;
    while(!q2.empty()){
        person p2 = q2.front();
        q2.pop();
        person pz;
//        printf("%d %d\n",p2.x,p2.y);
        if(p2.x == 1 || p2.x == n || p2.y == 1 || p2.y == m){
            minn = min(minn,p2.cnt);
            continue;
        }
        for(int i = 1; i &lt;= 4 ; i++){
            pz.x = p2.x + des[i][0];
            pz.y = p2.y + des[i][1];
            pz.cnt = p2.cnt + 1;
            if(ex_check(pz.x,pz.y) &amp;&amp; mark[pz.x][pz.y] == 0 &amp;&amp; ((vis[pz.x][pz.y] > pz.cnt)|| vis[pz.x][pz.y] == 0)){
                mark[pz.x][pz.y] = 1;
                q2.push(pz);
            }
        }
    }
    return minn;
}

int main(){
    int t;
    scanf("%d",&amp;t);
    while(t--){
        scanf("%d %d",&amp;n,&amp;m);
        getchar();
        memset(vis,0,sizeof vis);
        memset(mark,0,sizeof mark);

        for(int i = 1; i &lt;= n ; i++){
            for(int j = 1 ; j &lt;= m ; j++){
                scanf("%c",&amp;c[i][j]);
                if(c[i][j] == 'J'){
                    c[i][j] = '.';
                    cx = i;
                    cy = j;
                }
                if(c[i][j] == 'F'){
                    c[i][j] = '.';
                    vis[i][j] = 1;
                    p pp;
                    pp.x = i;
                    pp.y = j;
                    q1.push(pp);
                }
            }
            getchar();
        }

        bfs();
//        for(int i = 1; i &lt;= n ; i++){
//            for(int j = 1; j &lt;= m ; j++){
//                printf("%d",vis[i][j]);
//            }
//            printf("\n");
//        }
        int z = ex_bfs(cx,cy);
        if(z == 1000000){
            printf("IMPOSSIBLE\n");
        }
        else{
            printf("%d\n",z);
        }

    }
}

/*

2
4 4
####
#JF#
#..#
#..#
3 3
###
#J.
#.F


5
4 4
####
#JF#
#..#
#..#
3 3
###
#J.
#.F
4 4
####
#JF#
#..#
#..#
3 3
###
#J.
#.F
5 5
#####
..#..
.J#F.
..#..
#####

*/</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>316</wp:post_id>
		<wp:post_date><![CDATA[2019-05-22 19:57:52]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-05-22 11:57:52]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[uva-11624-fire-bfs]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="kuangbin"><![CDATA[kuangbin专题]]></category>
		<category domain="category" nicename="tijie"><![CDATA[题解]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[neve_meta_content_width]]></wp:meta_key>
		<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[专题一：简单搜索]POJ-3984-迷宫问题-BFS</title>
		<link>https://sdnuqp.cn/poj-3984-%e8%bf%b7%e5%ae%ab%e9%97%ae%e9%a2%98-bfs/</link>
		<pubDate>Wed, 22 May 2019 11:58:17 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=318</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:code -->
<pre class="wp-block-code"><code>

#include &lt;cstdio>
#include &lt;queue>
using namespace std;

int n,m;
int vis[5][5];
int des[5][2] = {{0,0},{1,0},{-1,0},{0,1},{0,-1}};

struct p{
    int x;
    int y;
    int pre[50][2];
    int w;
};
int maze[5][5];
bool check(int x,int y){
    if(x >= 0 &amp;&amp; x &lt;= 4 &amp;&amp; y >= 0 &amp;&amp; y &lt;= 4 &amp;&amp; vis[x][y] == 0 &amp;&amp; maze[x][y] == 0)
        return 1;
    return 0;
}

queue&lt;p>q;
void dfs(){
    p p1;
    p1.x = 0;
    p1.y = 0;
    p1.w = 0;
    p1.pre[p1.w][0] = p1.x;
    p1.pre[p1.w][1] = p1.y;
    q.push(p1);
    while(!q.empty()){
        p pp ;
        pp = q.front();
        q.pop();
//        printf("%d %d\n",pp.x,pp.y);
        if(pp.x == 4 &amp;&amp; pp.y == 4){
            for(int i = 0 ; i &lt;= pp.w ; i++){
                printf("(%d, %d)\n",pp.pre[i][0],pp.pre[i][1]);
            }
        }
        p pz;
        for(int i = 1;  i &lt;= 4 ; i++){
            pz = pp;
            pz.w = pp.w + 1;
            pz.x = pp.x + des[i][0];
            pz.y = pp.y + des[i][1];
            pz.pre[pz.w][0] = pz.x;
            pz.pre[pz.w][1] = pz.y;
            if(check(pz.x,pz.y)){
                vis[pz.x][pz.y] = 1;
                q.push(pz);
            }
        }
    }
//    printf("OK\n");
}

int main() {
    for(int i = 0 ; i &lt; 5 ; i++){
        for(int j= 0 ; j &lt; 5 ; j++){
            scanf("%d",&amp;maze[i][j]);
        }
    }
    dfs();
}</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>318</wp:post_id>
		<wp:post_date><![CDATA[2019-05-22 19:58:17]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-05-22 11:58:17]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[poj-3984-%e8%bf%b7%e5%ae%ab%e9%97%ae%e9%a2%98-bfs]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="kuangbin"><![CDATA[kuangbin专题]]></category>
		<category domain="category" nicename="tijie"><![CDATA[题解]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[neve_meta_content_width]]></wp:meta_key>
		<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[专题一：简单搜索]POJ-3414-Pots-BFS+记录路径</title>
		<link>https://sdnuqp.cn/poj-3414-pots-bfs%e8%ae%b0%e5%bd%95%e8%b7%af%e5%be%84/</link>
		<pubDate>Wed, 22 May 2019 11:59:02 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=320</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:code -->
<pre class="wp-block-code"><code>



#include &lt;cstdio>
#include &lt;queue>
#include &lt;stack>
#include &lt;cstring>
#include &lt;algorithm>
using namespace std;

int a,b,c;
int vis[102][102];

struct p {
    int x;
    int y;
    int cnt;
    int pre[102];
};

void check(int x) {
    if(x == 11)
        printf("DROP(1)\n");
    else if(x == 12)
        printf("DROP(2)\n");
    else if(x == 21)
        printf("FILL(1)\n");
    else if(x == 22)
        printf("FILL(2)\n");
    else if(x == 32)
        printf("POUR(1,2)\n");
    else if(x == 31)
        printf("POUR(2,1)\n");
}

queue&lt;p>q;

int dfs() {
    p p1;
    p1.x = 0;
    p1.y = 0;
    p1.cnt = 0;
    q.push(p1);
    while(!q.empty()) {
        p pp = q.front();
        q.pop();
//        printf("%d %d %d\n",pp.x,pp.y,pp.cnt);
        if(pp.x == c || pp.y == c) {
            printf("%d\n",pp.cnt);
            for(int i = 0 ; i &lt;= pp.cnt ; i++) {
                check(pp.pre[i]);
            }
            while(!q.empty()){
                q.pop();
            }
            return 1;
        }
        p pz = pp;
        pz.cnt = pp.cnt + 1;

//        printf("&lt;%d>\n",pz.cnt);
        ///DROP(1)
        pz.x = 0;
        pz.y = pp.y;
        pz.pre[pz.cnt] = 11;
        if(vis[pz.x][pz.y] == 0) {
            q.push(pz);
            vis[pz.x][pz.y] = 1;
        }
        ///DROP(2)
//        pz = pp;
        pz.x = pp.x;
        pz.y = 0;
        pz.pre[pz.cnt] = 12;
        if(vis[pz.x][pz.y] == 0) {
            q.push(pz);
            vis[pz.x][pz.y] = 1;
        }

        ///FILL(1)
//        pz = pp;
        pz.x = a;
        pz.y = pp.y;
        pz.pre[pz.cnt] = 21;
        if(vis[pz.x][pz.y] == 0) {
            q.push(pz);
            vis[pz.x][pz.y] = 1;
        }

        ///FILL(2)
//        pz = pp;
        pz.x = pp.x;
        pz.y = b;
        pz.pre[pz.cnt] = 22;
        if(vis[pz.x][pz.y] == 0) {
            q.push(pz);
            vis[pz.x][pz.y] = 1;
        }
        ///POUR(2,1)

//        pz = pp;
        pz.pre[pz.cnt] = 31;
        if(pp.y >= a-pp.x) {
            pz.x = a;
            pz.y = pp.y - (a-pp.x);
            if(vis[pz.x][pz.y] == 0) {
                vis[pz.x][pz.y] = 1;
                q.push(pz);
            }
        } else {
            pz.x = pp.x + pp.y;
            pz.y = 0;
            if(vis[pz.x][pz.y] == 0) {
                vis[pz.x][pz.y] = 1;
                q.push(pz);
            }
        }
        ///POUR(1,2)
//        pz = pp;
        pz.pre[pz.cnt] = 32;
        if(pp.x >= b - pp.y) {
            pz.x = pp.x - (b - pp.y);
            pz.y = b;
            if(vis[pz.x][pz.y] == 0) {
                vis[pz.x][pz.y] = 1;
                q.push(pz);
            }
        } else {
            pz.x = 0;
            pz.y = pp.y + pp.x;
            if(vis[pz.x][pz.y] == 0) {
                vis[pz.x][pz.y] = 1;
                q.push(pz);
            }
        }
    }
    return 0;
}

int main() {
    scanf("%d %d %d",&amp;a,&amp;b,&amp;c);
    if(dfs())
        ;
    else{
        printf("impossible\n");
    }
}

/*
6
FILL(2)
POUR(2,1)
DROP(1)
POUR(2,1)
FILL(2)
POUR(2,1)
*/</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>320</wp:post_id>
		<wp:post_date><![CDATA[2019-05-22 19:59:02]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-05-22 11:59:02]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[poj-3414-pots-bfs%e8%ae%b0%e5%bd%95%e8%b7%af%e5%be%84]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="kuangbin"><![CDATA[kuangbin专题]]></category>
		<category domain="category" nicename="tijie"><![CDATA[题解]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[neve_meta_content_width]]></wp:meta_key>
		<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[专题一：简单搜索]HDU-1495-非常可乐-DFS</title>
		<link>https://sdnuqp.cn/hdu-1495-%e9%9d%9e%e5%b8%b8%e5%8f%af%e4%b9%90-dfs/</link>
		<pubDate>Wed, 22 May 2019 12:02:03 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=329</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:code -->
<pre class="wp-block-code"><code>
//交C++200ms，交G++TLE;
//#pragma GCC optimize(2)


#include &lt;cstdio>
#include &lt;iostream>
#include &lt;algorithm>
#include &lt;cstring>
#include &lt;queue>
using namespace std;

int a,b,c;
int vis[110][110][110];
struct p {
    int L1;
    int L2;
    int L3;
    int cnt;
};

queue&lt;p>q;

void bfs() {
    p p1;
    p1.cnt = 0;
    p1.L1 = a;
    p1.L2 = 0;
    p1.L3 = 0;
    q.push(p1);
    vis[a][0][0] = 1;
    while(!q.empty()) {
        p pp = q.front();
        q.pop();
        if((pp.L1 == a/2 &amp;&amp; pp.L2 == a/2) || (pp.L1 == a/2 &amp;&amp; pp.L3 == a/2) || (pp.L2 == a/2 &amp;&amp; pp.L3 == a/2)) {
            printf("%d\n",pp.cnt);
            while(!q.empty()){
                q.pop();
            }
            return ;
        }
        p pz;
        pz.cnt = pp.cnt + 1;

        if(b - pp.L2 >= pp.L1) {
            pz.L1 = 0;
            pz.L2 = pp.L2 + pp.L1;
        } else {
            pz.L1 = pp.L1 - (b - pp.L2);
            pz.L2 = b;
        }
        pz.L3 = pp.L3;
        if(vis[pz.L1][pz.L2][pz.L3] == 0) {  /// 1 -> 2
            q.push(pz);
            vis[pz.L1][pz.L2][pz.L3] = 1;
        }

        if(c - pp.L3 >= pp.L1) {
            pz.L1 = 0;
            pz.L3 = pp.L3 + pp.L1;
        } else {
            pz.L1 = pp.L1 - (c - pp.L3);
            pz.L3 = c;
        }
        pz.L2 = pp.L2;
        if(vis[pz.L1][pz.L2][pz.L3] == 0) {  /// 1 -> 3
            q.push(pz);
            vis[pz.L1][pz.L2][pz.L3] = 1;
        }

        if(a - pp.L1 >= pp.L2) {
            pz.L1 = pp.L1 + pp.L2;
            pz.L2 = 0;
        } else {
            pz.L1 = a;
            pz.L2 = pp.L2 - (a - pp.L1);
        }
        pz.L3 = pp.L3;
        if(vis[pz.L1][pz.L2][pz.L3] == 0) {  /// 2 -> 1
            q.push(pz);
            vis[pz.L1][pz.L2][pz.L3] = 1;
        }

        if(c - pp.L3 >= pp.L2) {
            pz.L2 = 0;
            pz.L3 = pp.L3 + pp.L2;
        } else {
            pz.L2 = pp.L2 - (c - pp.L3);
            pz.L3 = c;
        }
        pz.L1 = pp.L1;
        if(vis[pz.L1][pz.L2][pz.L3] == 0) {  /// 2 -> 3
            q.push(pz);
            vis[pz.L1][pz.L2][pz.L3] = 1;
        }

        if(a - pp.L1 >= pp.L3) {/////
            pz.L1 = pp.L1 + pp.L3;
            pz.L3 = 0;
        } else {
            pz.L1 = a;
            pz.L3 = pp.L3 - (a - pp.L1);
        }
        pz.L2 = pp.L2;
        if(vis[pz.L1][pz.L2][pz.L3] == 0) {  /// 3 -> 1
            q.push(pz);
            vis[pz.L1][pz.L2][pz.L3] = 1;
        }

        if(b - pp.L2 >= pp.L3) {
            pz.L2 = pp.L2 + pp.L3;
            pz.L3 = 0;
        } else {
            pz.L2 = b;
            pz.L3 = pp.L3 - (b - pp.L2);
        }
        pz.L1 = pp.L1;
        if(vis[pz.L1][pz.L2][pz.L3] == 0) {  /// 3 -> 2
            q.push(pz);
            vis[pz.L1][pz.L2][pz.L3] = 1;
        }
    }
    printf("NO\n");
}

int main() {
    while(scanf("%d %d %d",&amp;a,&amp;b,&amp;c)!=EOF &amp;&amp; (a&amp;&amp;b&amp;&amp;c)) {
        memset(vis,0,sizeof vis);
        if(a % 2 == 1) {
            printf("NO\n");
            continue;
        }
        bfs();
    }
    return 0;
}</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>329</wp:post_id>
		<wp:post_date><![CDATA[2019-05-22 20:02:03]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-05-22 12:02:03]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu-1495-%e9%9d%9e%e5%b8%b8%e5%8f%af%e4%b9%90-dfs]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="kuangbin"><![CDATA[kuangbin专题]]></category>
		<category domain="category" nicename="tijie"><![CDATA[题解]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[neve_meta_content_width]]></wp:meta_key>
		<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[专题一：简单搜索]HDU-1241-Oil Deposits-BFS</title>
		<link>https://sdnuqp.cn/hdu-1241-oil-deposits-bfs/</link>
		<pubDate>Wed, 22 May 2019 12:02:43 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=331</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:code -->
<pre class="wp-block-code"><code>



#include &lt;bits/stdc++.h>
using namespace std;

int n,m;
int c[110][110];
int vis[110][110];
int des[9][2] = {{0,0},{1,0},{1,1},{1,-1},{-1,0},{-1,1},{-1,-1},{0,1},{0,-1}};

struct p {
    int x;
    int y;
};

bool check(int x,int y) {
    if(x >= 1 &amp;&amp; x &lt;= n &amp;&amp; y >= 1 &amp;&amp; y &lt;= m &amp;&amp; vis[x][y] == 1)
        return 1;
    return 0;
}

queue&lt;p>q;
int bfs(int i,int j) {
    p pd;
    pd.x = i;
    pd.y = j;
    vis[pd.x][pd.y] = 0;
    q.push(pd);
    while(!q.empty()) {
        p pp;
        pp = q.front();
        q.pop();
        p pz;
        for(int i = 1; i &lt;= 8 ; i++) {
            pz.x = pp.x + des[i][0];
            pz.y = pp.y + des[i][1];
            if(check(pz.x,pz.y)) {
                vis[pz.x][pz.y] = 0;
                q.push(pz);
            }
        }
    }
}

int main() {
    while(scanf("%d %d",&amp;n,&amp;m) &amp;&amp; (n&amp;&amp;m)) {
        getchar();
        for(int i = 1; i &lt;= n ; i++) {
            for(int j = 1; j &lt;= m ; j++) {
                scanf("%c",&amp;c[i][j]);
                c[i][j] == '@'?vis[i][j] = 1:vis[i][j] = 0;
            }
            getchar();
        }
//            getchar();
        int cnt = 0;
        for(int i = 1; i &lt;= n ; i ++) {
            for(int j = 1; j &lt;= m ; j++) {
                if(vis[i][j] == 1) {
                    cnt++;
                    bfs(i,j);
                }
            }
        }
        printf("%d\n",cnt);
//        getchar();
    }
}


/*
1 1
*
3 5
*@*@*
**@**
*@*@*
1 8
@@****@*
5 5
****@
*@@*@
*@**@
@@@*@
@@**@
0 0
*/</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>331</wp:post_id>
		<wp:post_date><![CDATA[2019-05-22 20:02:43]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-05-22 12:02:43]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu-1241-oil-deposits-bfs]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="kuangbin"><![CDATA[kuangbin专题]]></category>
		<category domain="category" nicename="tijie"><![CDATA[题解]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[neve_meta_content_width]]></wp:meta_key>
		<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[专题一：简单搜索]FZU-2150-Fire Game-BFS</title>
		<link>https://sdnuqp.cn/fzu-2150-fire-game-bfs/</link>
		<pubDate>Wed, 22 May 2019 12:03:16 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=333</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:code -->
<pre class="wp-block-code"><code>



#include &lt;cstdio>
#include &lt;iostream>
#include &lt;cstring>
#include &lt;algorithm>
#include &lt;queue>
using namespace std;

int n,m;
int vis[20][20];
char c[20][20];
int des[5][2] = {{0,0},{0,1},{0,-1},{1,0},{-1,0}};

bool find_zero() {
    int flag = 0;
    for(int i = 1;  i&lt;= n ; i++) {
        for(int j = 1 ; j&lt;= m ; j++) {
            if(vis[i][j] == 0 &amp;&amp; c[i][j] == '#') {
                return 1;
            }
        }
    }
    return 0;
}

struct node {
    int x;
    int y;
    int cnt ;
};

queue&lt;node>q;
int bfs(int x, int y, int xx, int yy) {
    node p;
    p.x = x;
    p.y = y;
    p.cnt = 0;
    vis[x][y] = 1;
    q.push(p);
    node p2;
    p2.x = xx;
    p2.y = yy;
    p2.cnt = 0;
    q.push(p2);
    vis[xx][yy] = 1;
    int maxx = -1;
    while(!q.empty()) {
        node p = q.front();
        q.pop();
        maxx = max(maxx,p.cnt);
        node pp;
        for(int i = 1; i &lt;= 4 ; i++) {
            pp.x = p.x + des[i][0];
            pp.y = p.y + des[i][1];
            pp.cnt = p.cnt + 1;
            if(pp.x > n || pp.y > m || pp.x  &lt;= 0 || pp.x &lt;= 0)
                continue;
            if(c[pp.x][pp.y] == '#' &amp;&amp; vis[pp.x][pp.y] == 0) {
                vis[pp.x][pp.y] = 1;
                q.push(pp);
            }
        }
    }
    return maxx;
}


int main() {
    int t;
    scanf("%d",&amp;t);
    int maxx = 111111;
    for(int k = 1; k &lt;= t ; k++) {
        maxx = 111111;
        scanf("%d %d",&amp;n,&amp;m);
        getchar();
        for(int i = 1; i &lt;= n ; i++) {
            for(int  j = 1; j &lt;= m ; j++) {
                scanf("%c",&amp;c[i][j]);
            }
            getchar();
        }
        for(int i = 1 ; i &lt;= n ; i++) {
            for(int j = 1 ; j &lt;= m ; j++) {
                if(c[i][j] == '.')
                    continue;
                for(int l = 1 ; l &lt;= n ; l++) {
                    for(int p = 1; p &lt;= m ; p++) {
                        if(c[l][p] == '.') {
                            continue;
                        }
                        memset(vis,0,sizeof vis);
                        int z = bfs(i,j,l,p);
                        if(find_zero()) {
                            continue;
                        }
//                        printf("%d %d %d %d\n",i,j,l,p);
//                        printf("%d\n",z);
                        maxx = min(maxx,z);
                    }
                }
            }
        }
        if(maxx == 111111) {
            printf("Case %d: -1\n",k);
        } else {
            printf("Case %d: %d\n",k,maxx);
        }
    }

}

/*
2
1 5
#####
5 1
#
#
#
#
#


*/

//                        printf("%d\n",z);
//                        for(int i = 1 ; i&lt;= n ; i++){
//                            for(int j = 1; j&lt;= m ;j++){
//                                printf("%d ",vis[i][j]);
//                            }
//                            printf("\n");
//                        }</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>333</wp:post_id>
		<wp:post_date><![CDATA[2019-05-22 20:03:16]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-05-22 12:03:16]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[fzu-2150-fire-game-bfs]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="kuangbin"><![CDATA[kuangbin专题]]></category>
		<category domain="category" nicename="tijie"><![CDATA[题解]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[neve_meta_content_width]]></wp:meta_key>
		<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[专题一：简单搜索]HDU-2612-Find a way-BFS</title>
		<link>https://sdnuqp.cn/hdu-2612-find-a-way-bfs/</link>
		<pubDate>Wed, 22 May 2019 12:04:09 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=335</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:code -->
<pre class="wp-block-code"><code>
#include &lt;bits/stdc++.h>
using namespace std;

int n,m;
int cx,cy;
int fx,fy;
int c[1010][1010];
int vis1[1010][1010];
int vis2[1010][1010];
int des[5][2] = {{0,0},{0,1},{0,-1},{1,0},{-1,0}};

struct p {
    int x;
    int y;
};

bool check(int x,int y){
    if(x >= 1 &amp;&amp; x &lt;= n &amp;&amp; y >= 1 &amp;&amp; y &lt;= m &amp;&amp; (c[x][y] == '.'||c[x][y] == '@')){
        return 1 ;
    }
    return 0;
}


queue&lt;p>q1;

void bfs1(){
    while(!q1.empty()){
        p pp = q1.front();
        q1.pop();
        p pz;
        for(int i = 1; i &lt;= 4 ; i++){
            pz.x = pp.x + des[i][0] ;
            pz.y = pp.y + des[i][1] ;
            if(check(pz.x,pz.y)){
                if(vis1[pz.x][pz.y] == 0){
                    vis1[pz.x][pz.y] = vis1[pp.x][pp.y] + 1;
                    q1.push(pz) ;
                }
            }
        }
    }
}

queue&lt;p>q2;

void bfs2(){
    while(!q2.empty()){
        p pp = q2.front();
        q2.pop();
        p pz;
        for(int i = 1; i &lt;= 4 ; i++){
            pz.x = pp.x + des[i][0] ;
            pz.y = pp.y + des[i][1] ;
            if(check(pz.x,pz.y)){
                if(vis2[pz.x][pz.y] == 0){
                    vis2[pz.x][pz.y] = vis2[pp.x][pp.y] + 1;
                    q2.push(pz) ;
                }
            }
        }
    }
}

struct person {
    int x;
    int y;
    int cnt;
};

int main(){
    while(scanf("%d %d",&amp;n,&amp;m) != EOF){
        getchar();
        memset(vis1,0,sizeof vis1);
        memset(vis2,0,sizeof vis2);

        for(int i = 1; i &lt;= n ; i++){
            for(int j = 1 ; j &lt;= m ; j++){
                scanf("%c",&amp;c[i][j]);
                if(c[i][j] == 'Y'){
                    c[i][j] = '.';
                    vis1[i][j] = 1;
                    p pp;
                    pp.x = i;
                    pp.y = j;
                    q1.push(pp);
                }
                if(c[i][j] == 'M'){
                    c[i][j] = '.';
                    vis2[i][j] = 1;
                    p pp;
                    pp.x = i;
                    pp.y = j;
                    q2.push(pp);
                }
            }
            getchar();
        }

        bfs1();
        bfs2();
//        for(int i = 1; i &lt;= n ; i++){
//            for(int j = 1 ; j &lt;= m ; j++){
//                printf("%d ",vis1[i][j]);
//            }
//            printf("\n");
//        }
//        for(int i = 1; i &lt;= n ; i++){
//            for(int j = 1 ; j &lt;= m ; j++){
//                printf("%d ",vis2[i][j]);
//            }
//            printf("\n");
//        }

        int maxx = 10000;
        for(int i = 1; i &lt;= n ; i++){
            for(int j = 1; j &lt;= m ; j++){
                if(c[i][j] == '@' &amp;&amp; vis1[i][j] != 0 &amp;&amp; vis2[i][j] != 0){
                    maxx = min(maxx,vis1[i][j] + vis2[i][j] -2);
                }
            }
        }
        printf("%d\n",maxx*11);
    }
}

/*

4 4
Y.#@
....
.#..
@..M
4 4
Y.#@
....
.#..
@#.M
5 5
Y..@.
.#...
.#...
@..M.
#...#

*/</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>335</wp:post_id>
		<wp:post_date><![CDATA[2019-05-22 20:04:09]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-05-22 12:04:09]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu-2612-find-a-way-bfs]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="kuangbin"><![CDATA[kuangbin专题]]></category>
		<category domain="category" nicename="tijie"><![CDATA[题解]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[neve_meta_content_width]]></wp:meta_key>
		<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[专题一：简单搜索]POJ-3087-Shuffle&#039;m Up-模拟</title>
		<link>https://sdnuqp.cn/poj-3087-shufflem-up-%e6%a8%a1%e6%8b%9f/</link>
		<pubDate>Wed, 22 May 2019 12:05:01 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=337</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:code -->
<pre class="wp-block-code"><code>

#include &lt;cstdio>
#include &lt;iostream>
#include &lt;cstring>
#include &lt;algorithm>
//#include &lt;bits/stdc++.h>
using namespace std;

char s1[110];
char s2[110];
char s3[110];
char s12[220];
char s21[220];

int main() {
    int n,t;
    scanf("%d",&amp;t);
    for(int k = 1; k &lt;= t ; k++) {
        scanf("%d",&amp;n);
        getchar();
        scanf("%s",s1);
        getchar();
        scanf("%s",s2);
        getchar();
        scanf("%s",s12);

        strcpy(s3,s1);
        int cnt = 0;
        int is_find = 0;
        while(1) {
            cnt++;
//            printf("%d>>>>\n",cnt);
//            printf("%s\n",s1+1);
//            printf("%s\n",s2+1);
            if(cnt > 1 &amp;&amp; strcmp(s1,s3) == 0){
                break;
            }

            for(int i = 0 ; i &lt; n*2 ; i++) {
                if(i%2 == 0) {
                    s21[i] = s2[i/2];
                } else {
                    s21[i] = s1[i/2];
                }
            }
            s21[n*2] = '\0';
//            printf("%s\n",s21);
//            printf("%s\n",s12);
//            s12[0] = ' ';

//            printf("%s\n",s21);
//            printf("%s\n",s12);

            int flag = 1;

            if(strcmp(s21,s12) == 0){
                ;
            }
            else
                flag = 0;

            if(flag == 1){
                is_find = 1;
                break;
            }

            for(int i = 0 ; i &lt; n*2 ; i++) {
                if(i &lt; n) {
                    s1[i] = s21[i];
                } else
                    s2[i-n] = s21[i];
            }
            s1[n] = '\0';
            s2[n] = '\0';
        }

        if(is_find) {
            printf("%d %d\n",k,cnt);
        } else {
            printf("%d -1\n",k);
        }

    }
    return 0;
}</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>337</wp:post_id>
		<wp:post_date><![CDATA[2019-05-22 20:05:01]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-05-22 12:05:01]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[poj-3087-shufflem-up-%e6%a8%a1%e6%8b%9f]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="kuangbin"><![CDATA[kuangbin专题]]></category>
		<category domain="category" nicename="tijie"><![CDATA[题解]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[neve_meta_content_width]]></wp:meta_key>
		<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>A site about search</title>
		<link>https://sdnuqp.cn/a-site-about-search/</link>
		<pubDate>Wed, 22 May 2019 13:35:37 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=346</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p><a href="https://qiao.github.io/PathFinding.js/visual/">https://qiao.github.io/PathFinding.js/visual/</a></p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>346</wp:post_id>
		<wp:post_date><![CDATA[2019-05-22 21:35:37]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-05-22 13:35:37]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[a-site-about-search]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="sundry"><![CDATA[杂项]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[neve_meta_content_width]]></wp:meta_key>
		<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wp_old_slug]]></wp:meta_key>
		<wp:meta_value><![CDATA[a-website-about-%e6%90%9c%e7%b4%a2]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[专题二：搜索进阶]HDU-2181-哈密顿绕行世界问题-BFS+记录路径</title>
		<link>https://sdnuqp.cn/%e4%b8%93%e9%a2%98%e4%ba%8c%ef%bc%9a%e6%90%9c%e7%b4%a2%e8%bf%9b%e9%98%b6hdu-2181-%e5%93%88%e5%af%86%e9%a1%bf%e7%bb%95%e8%a1%8c%e4%b8%96%e7%95%8c%e9%97%ae%e9%a2%98-bfs%e8%ae%b0%e5%bd%95%e8%b7%af/</link>
		<pubDate>Wed, 22 May 2019 13:46:02 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=348</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:code -->
<pre class="wp-block-code"><code>
#include &lt;cstdio>
#include &lt;iostream>
#include &lt;cstring>
#include &lt;algorithm>
#include &lt;queue>
using namespace std;
int n ;
int mp[25][25];

struct p {
    int x;
    int w;
    int pre[21];
    int vis[21];
};

int cnt;
queue&lt;p>q;

void dfs() {
    p p1;
    p1.x = n;
    p1.w = 0;
    p1.pre[p1.w] = p1.x;
    memset(p1.vis,0,sizeof(p1.vis));
    memset(p1.pre,0,sizeof(p1.pre));
    q.push(p1);
    while(!q.empty()) {
        p pp = q.front();
        q.pop();

//        printf("&lt;%d %d>\n",pp.x,pp.w);
        if(pp.x == n &amp;&amp; pp.w == 20) {
            cnt++;
            printf("%d:  ",cnt);
            printf("%d",n);
            for(int i = 1 ; i &lt;= pp.w ; i++) {
                printf(" %d",pp.pre[i]);
            }
            printf("\n");
            continue;
        }

        for(int i = 1 ; i &lt;= 20 ; i ++) {
            if(mp[pp.x][i] == 1) {
                p pz;
                pz.x = i;
                pz.w = pp.w + 1;
                pz.pre[pz.w] = pz.x;
//                printf("(%d %d)\n",pz.x,pz.w);
                for(int j = 0; j &lt;= 20 ; j++) {
                    pz.pre[j] = pp.pre[j];
                    pz.vis[j] = pp.vis[j];
                }
//                for(int j = 1; j &lt;= 20 ; j++) {
//                    printf("%d ",pz.vis[j]);
//                }
//                printf("\n");
                if(pz.w &lt;= 20 &amp;&amp; pz.vis[i] == 0) {
                    pz.vis[pz.x] = 1;
                    pz.pre[pz.w] = pz.x;
                    q.push(pz);
                }
            }
        }
//        printf(">>>\n");
    }
}

int main() {
    int a,b,c;
    for(int i = 1 ; i &lt;= 20 ; i++) {
        scanf("%d %d %d",&amp;a,&amp;b,&amp;c);
        mp[i][a] = 1;
        mp[a][i] = 1;
        mp[i][b] = 1;
        mp[b][i] = 1;
        mp[i][c] = 1;
        mp[c][i] = 1;
    }

//    scanf("%d",&amp;n);

    while(scanf("%d",&amp;n)!=EOF &amp;&amp; n){
        cnt = 0;
        dfs();
    }
}


/*


2 5 20
1 3 12
2 4 10
3 5 8
1 4 6
5 7 19
6 8 17
4 7 9
8 10 16
3 9 11
10 12 15
2 11 13
12 14 20
13 15 18
11 14 16
9 15 17
7 16 18
14 17 19
6 18 20
1 13 19
5


*/</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>348</wp:post_id>
		<wp:post_date><![CDATA[2019-05-22 21:46:02]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-05-22 13:46:02]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e4%b8%93%e9%a2%98%e4%ba%8c%ef%bc%9a%e6%90%9c%e7%b4%a2%e8%bf%9b%e9%98%b6hdu-2181-%e5%93%88%e5%af%86%e9%a1%bf%e7%bb%95%e8%a1%8c%e4%b8%96%e7%95%8c%e9%97%ae%e9%a2%98-bfs%e8%ae%b0%e5%bd%95%e8%b7%af]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="kuangbin"><![CDATA[kuangbin专题]]></category>
		<category domain="category" nicename="tijie"><![CDATA[题解]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[neve_meta_content_width]]></wp:meta_key>
		<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[专题二：搜索进阶]HDU-3533-Escape-BFS+预处理</title>
		<link>https://sdnuqp.cn/%e4%b8%93%e9%a2%98%e4%ba%8c%ef%bc%9a%e6%90%9c%e7%b4%a2%e8%bf%9b%e9%98%b6hdu-3533-escape-bfs%e9%a2%84%e5%a4%84%e7%90%86/</link>
		<pubDate>Tue, 28 May 2019 08:17:08 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=357</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>这个题真的把我做崩了。删删减减至少写了1000行。。。。中间打表的部分死活做不对（做了几乎整整一晚上。。。），最后借鉴了一位大神的博客，Orz，我写废了的也跟在后面了。</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>


#pragma GCC optimize(2)

#include &lt;cstdio>
#include &lt;algorithm>
#include &lt;cstring>
#include &lt;queue>
using namespace std;
const int maxn = 100 + 2;

struct node {
    int x;
    int y;
    int sum;///能量
};

struct p {
    char chr;
    int t,v,x,y;
} store_fortress[101];

bool mark_fortress[maxn][maxn];
bool mark_map[maxn][maxn][1002];
bool mark_bullet[1002][maxn][maxn];

int m,n,k,d;
char dir;
int t,v,x,y;
int ds[5][2] = {{0,0},{1,0},{0,1},{-1,0},{0,-1}};

void treaval() {
    for(int t = 1; t &lt;= d ; t++) {
        printf("%d>>>\n",t);
        for(int i = 0 ; i &lt;=  m ; i++) {
            for(int j = 0 ; j &lt;= n ; j++) {
                printf("%d ",mark_bullet[t][i][j]);
            }
            printf("\n");
        }
        printf(">>>>>>>>>\n");
    }
}

void update(char id, int t,int v, int x,int y) {

    if(id == 'W') {
        int stop = 0;
//        for(int j = y - 1; j >= 0; j --) {
//            if(mark_fortress[x][j]) {
//                stop = j;
//                break;
//            }
//        }
        for(int j = y - v,ini = 1; j >= 0; j -= v,ini ++) {
            for(int k = ini; k &lt;= d; k += t) {
                mark_bullet[k][x][j] = true;
            }
            if(mark_fortress[x][j]){
                break;
            }
        }

    } else if(id == 'E') {
        for(int j = y + v,ini = 1; j &lt;= m; j += v,ini ++) {
            for(int k = ini; k &lt;= d; k += t) {
                mark_bullet[k][x][j] = true;
            }
            if(mark_fortress[x][j]) {
                break;
            }
        }
    } else if(id == 'N') {
        for(int j = x - v,ini = 1; j >= 0; j -= v,ini ++) {
            for(int k = ini; k &lt;= d; k += t) {
                mark_bullet[k][j][y] = true;
            }
            if(mark_fortress[j][y]) {
                break;
            }
        }
    } else if(id == 'S') {
        for(int j = x + v,ini = 1; j &lt;= n; j += v,ini ++) {
            for(int k = ini; k &lt;= d; k += t) {
                mark_bullet[k][j][y] = true;
            }
            if(mark_fortress[j][y]) {
                break;
            }
        }
    }
}

inline bool check(int x,int y,int t) {

    if(mark_map[x][y][t] == 0 &amp;&amp; mark_bullet[t][x][y] == 0 &amp;&amp; mark_fortress[x][y] == 0 &amp;&amp; x >= 0 &amp;&amp; y >= 0 &amp;&amp; x &lt;= m &amp;&amp; y &lt;= n)
        return 1;
    return 0;
}

queue&lt;node>q;
void bfs() {
    node p,t;
    p.x = 0 ;
    p.y = 0;
    p.sum = 0;
    q.push(p);
    mark_map[0][0][0] = 1;
    while(!q.empty()) {
        p = q.front();
        q.pop();
        if(p.x == m &amp;&amp; p.y == n) {
            printf("%d\n",p.sum);
            while(!q.empty()) {
                q.pop();
            }
            return ;
        }
        if(p.sum > d)
            continue;
        for(int i = 0 ; i &lt;= 2 ; i++) {
            t.x = p.x + ds[i][0];
            t.y = p.y + ds[i][1];
            t.sum = p.sum + 1;
            if(check(t.x, t.y, t.sum)) {
                mark_map[t.x][t.y][t.sum] = 1;
                q.push(t);
            }
        }
    }
    printf("Bad luck!\n");
    return ;
}
int main() {

    while(scanf("%d %d %d %d",&amp;m,&amp;n,&amp;k,&amp;d) != EOF) {
        getchar();
        memset(mark_fortress,0,sizeof mark_fortress);
        memset(mark_map,0,sizeof mark_map);
        memset(mark_bullet,0,sizeof mark_bullet);

//        fill(&amp;mark_fortress[0][0],&amp;mark_fortress[maxn-1][maxn-1],false);
//        fill(&amp;mark_bullet[0][0][0],&amp;mark_bullet[1001][maxn-1][maxn-1],false);
//        fill(&amp;mark_map[0][0][0],&amp;mark_map[maxn][maxn-1][1001],false);

        for(int i = 1 ; i &lt;= k ; i++) {
            scanf("%c %d %d %d %d",&amp;store_fortress[i].chr,&amp;store_fortress[i].t,&amp;store_fortress[i].v,&amp;store_fortress[i].x,&amp;store_fortress[i].y);
            getchar();
            mark_fortress[store_fortress[i].x][store_fortress[i].y] = 1;
        }

        for(int i = 1; i &lt;= k ; i++) {
            update(store_fortress[i].chr,store_fortress[i].t,store_fortress[i].v,store_fortress[i].x,store_fortress[i].y);
        }

        bfs();

//        treaval();

    }
    return 0;
}


/*
4 4 3 10
N 1 1 1 1
W 1 1 3 2
W 1 1 2 4
8

4 4 3 10
N 1 1 1 1
W 1 1 3 2
W 2 1 2 4
4 4 3 10
N 1 1 1 1
W 1 1 3 2
W 1 1 2 4

*/


/*
W3
E4
N1
S2
N
S
W
E



*/



/*
void update(int a[][5]) {
    for(int t = 1; t &lt;= d ; t++) {///时间轴
        for(int i = 1; i &lt;= k ; i++) {
            int id = a[i][0];///方向
            int cycle = a[i][1];///周期
            int one_dis = a[i][2];///速度
            int num_bullet = (t-1)/cycle+1;///子弹个数
            int len = t*one_dis;   ///最远的子弹离堡垒的距离
            int x = a[i][3];
            int y = a[i][4];

            if(id == 1) {      ///N
//                if(num_bullet * one_dis > x) {
//                    continue;
//                }
//                printf("1\n");
                for(int j = x-1 ; j >= 0 ; j--) {
                    if(mark_fortress[j][y] == 1) {
                        break;
                    }
                    if(num_bullet) {
                        if((x-j)%one_dis != 0)
                            continue;
                        num_bullet--;
                        mark_bullet[t][j][y] = 1;
                    } else {
                        break;
                    }
                }
            } else if(id == 2) { ///S
//                printf("2\n");
//                if(num_bullet * one_dis > m - x) {
//                    continue;
//                }
                for(int j = x+1 ; j &lt;= m ; j++) {
                    if(mark_fortress[j][y] == 1) {
                        break;
                    }
                    if(num_bullet) {
                        if((j-x)%one_dis != 0)
                            continue;
                        num_bullet--;
                        mark_bullet[t][j][y] = 1;
                    } else {
                        break;
                    }
                }
            } else if(id == 3) { ///W
//                printf("3\n");
//                if(num_bullet * one_dis > y) {
//                    continue;
//                }
                if(t%cycle != 0) {
                    for(int j = y - 1 ; j >= 0 ; j--) {
                        if(mark_fortress[x][j] == 1) {
                            break;
                        }
                        if(a[j] == 1) {
                            a[j] ==
                        }
                    }
                }
                for(int j = y-1 ; j >= 0 ; j--) {
                    if(mark_fortress[x][j] == 1) {
                        break;
                    }
                    if(num_bullet) {
                        num_bullet--;
                        mark_bullet[t][x][j] = 1;
                    } else {
                        break;
                    }
                }
            } else if(id == 4) { ///E
//                printf("4\n");
//                if(num_bullet * one_dis > n - y) {
//                    continue;
//                }
                for(int j = y+1 ; j &lt;= n ; j++) {
                    if(mark_fortress[x][j] == 1) {
                        break;
                    }
                    if(num_bullet) {
                        if((j-y)%one_dis != 0)
                            continue;
                        num_bullet--;
                        mark_bullet[t][x][j] = 1;
                    } else {
                        break;
                    }
                }
            }
        }
//        printf("ASDF\n");
    }
}



*/
</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>357</wp:post_id>
		<wp:post_date><![CDATA[2019-05-28 16:17:08]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-05-28 08:17:08]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e4%b8%93%e9%a2%98%e4%ba%8c%ef%bc%9a%e6%90%9c%e7%b4%a2%e8%bf%9b%e9%98%b6hdu-3533-escape-bfs%e9%a2%84%e5%a4%84%e7%90%86]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="kuangbin"><![CDATA[kuangbin专题]]></category>
		<category domain="category" nicename="tijie"><![CDATA[题解]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[neve_meta_content_width]]></wp:meta_key>
		<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>关于scanf()输入形式吃字符问题</title>
		<link>https://sdnuqp.cn/%e5%85%b3%e4%ba%8escanf%e8%be%93%e5%85%a5%e5%bd%a2%e5%bc%8f%e5%90%83%e5%ad%97%e7%ac%a6%e9%97%ae%e9%a2%98/</link>
		<pubDate>Sat, 01 Jun 2019 08:37:16 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=362</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:preformatted -->
<pre class="wp-block-preformatted">经常做到字符串的题，总是因为字符串读入浪费大量的时间，所以这次特别来整理一下scanf吃回车空格的问题。
 先看如下程序：
 include 
 using namespace std;
 int main(){
     int a,b;
     scanf("%d:%d",&amp;a,&amp;b);
     printf("%d %d\n",a,b);
     return 0;
 }
 输入:123:123回车
 输出:123 123
 输入:123:      123回车
 输出:123 123
 输入:123 :123回车
 输出:123 随机数；
 再来看如下程序：
 include 
 using namespace std;
 int main(){
     int n;
     scanf("%d\n",&amp;n);
     printf("%d\n",n);
     return 0;
 }
 输入:123回车
 程序未结束
 继续输入空白字符（回车，空格，制表符）程序未结束，输入其他字符，程序结束
 输出:123
 所以在scanf后面加个\n，能够吃掉后面连着的所有回车，而有些题输入第一行是空格，并且多组输入，所以就不对了，被坑惨了，555；
 以后吃一个回车，老实用getchar()就好了。</pre>
<!-- /wp:preformatted -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>362</wp:post_id>
		<wp:post_date><![CDATA[2019-06-01 16:37:16]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-06-01 08:37:16]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%85%b3%e4%ba%8escanf%e8%be%93%e5%85%a5%e5%bd%a2%e5%bc%8f%e5%90%83%e5%ad%97%e7%ac%a6%e9%97%ae%e9%a2%98]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="sundry"><![CDATA[杂项]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[neve_meta_content_width]]></wp:meta_key>
		<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>关于位运算</title>
		<link>https://sdnuqp.cn/%e5%85%b3%e4%ba%8e%e4%bd%8d%e8%bf%90%e7%ae%97/</link>
		<pubDate>Mon, 03 Jun 2019 11:07:03 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=366</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>一点小测试。</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>#include &lt;bits/stdc++.h>
using namespace std;

int lowbit(int x){
    return x &amp; -x;
}

int main() {
    int n;

    n = 16;

    printf("n = %d",n);
    printf("二进制:");
    while(n) {
        if(n &amp; 1)
            printf("1");
        else
            printf("0");
        n >>= 1;
    }
    printf("\n");

    n = 16;
    printf("n|1     : %d\n",n|1);///一个为1，则为1
    printf("n|(1&lt;&lt;3): %d\n",n|(1&lt;&lt;3));///特定位赋值
    printf("n|0     : %d\n",n|0);///它本身

    printf("n&amp;1     : %d\n",n&amp;1);///都为1，则为1
    printf("n&amp;0     : %d\n",n&amp;0);///0

    printf("n^1     : %d\n",n^1);///不同为1，相同为0
    printf("n^0     : %d\n",n^0);///它本身

    printf("-n      : %d\n",-n);
    printf("n&amp;-n    : %d\n",n&amp;(-n));///emmmmmm，不知怎么描述...lowbit数组操作

    if(-n == ~n + 1){   ///它们相等
        printf("~n+1      :%d ",~n+1);
    }

    return 0;
}

</code></pre>
<!-- /wp:code -->

<!-- wp:code -->
<pre class="wp-block-code"><code>
输出：
n = 16二进制:00001
n|1     : 17
n|(1&lt;&lt;3): 24
n|0     : 16
n&amp;1     : 0
n&amp;0     : 0
n^1     : 17
n^0     : 16
-n      : -16
n&amp;-n    : 16
~n+1      :-16
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>Bit Twidding Hacks（外国人写的文章）</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>汉译为：位运算骚操作</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>传送门：</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><a href="https://graphics.stanford.edu/~seander/bithacks.html">https://graphics.stanford.edu/~seander/bithacks.html</a></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p></p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>366</wp:post_id>
		<wp:post_date><![CDATA[2019-06-03 19:07:03]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-06-03 11:07:03]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%85%b3%e4%ba%8e%e4%bd%8d%e8%bf%90%e7%ae%97]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="stl"><![CDATA[基础__STL]]></category>
		<category domain="category" nicename="sundry"><![CDATA[杂项]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[neve_meta_content_width]]></wp:meta_key>
		<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>HYSBZ-1085-骑士精神-IDA_Star(DFS)</title>
		<link>https://sdnuqp.cn/hysbz-1085-%e9%aa%91%e5%a3%ab%e7%b2%be%e7%a5%9e-ida_stardfs-2/</link>
		<pubDate>Mon, 03 Jun 2019 11:09:25 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=368</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:code -->
<pre class="wp-block-code"><code>



#include &lt;bits/stdc++.h>
using namespace std;

int ans;
char c[6][6];
int m[6][6];
int mz[6][6];
int mm[6][6] = {
    0,0,0,0,0,0,
    0,1,1,1,1,1,
    0,0,1,1,1,1,
    0,0,0,2,1,1,
    0,0,0,0,0,1,
    0,0,0,0,0,0
};

int des[9][2] = {{0,0},{1,2},{1,-2},{-1,2},{-1,-2},{2,1},{2,-1},{-2,-1},{-2,1}};

int check() {
    int cnt = 0;
    for(int i = 1; i &lt;= 5 ; i++) {
        for(int j = 1 ; j &lt;= 5 ; j++) {
            if(m[i][j] != mm[i][j]) {
                cnt++;
            }
        }
    }
    return cnt;
}

void A_Star(int x,int y,int w,int en) {
    if(w == en) {
        if(!check()) {
            ans = w;
        }
        return;
    }
    for(int i = 1 ; i &lt;= 8 ; i++) {
        int xx = x + des[i][0];
        int yy = y + des[i][1];
        if(xx >= 1 &amp;&amp; yy >= 1 &amp;&amp; xx &lt;= 5 &amp;&amp; yy &lt;= 5) {
            swap(m[x][y],m[xx][yy]);
            if(check() + w &lt;= en) {
                A_Star(xx,yy,w+1,en);
            }
            swap(m[x][y],m[xx][yy]);
        }
    }
}

int main() {
    int tt;
    scanf("%d",&amp;tt);
    int xx,yy;
    getchar();
    for(int t = 1 ; t &lt;= tt ; t++) {
        for(int i = 1; i &lt;= 5 ; i++) {
            for(int j = 1; j &lt;= 5 ; j++) {
                scanf("%c",&amp;c[i][j]);
                if(c[i][j] == '*') {
                    m[i][j] = 2;
                    xx = i;
                    yy = j;
                } else
                    m[i][j] = c[i][j] - 48;
            }
            getchar();
        }
//        for(int i =1 ; i&lt;= 5 ; i++) {
//            for(int j = 1 ; j&lt;= 5 ; j++) {
//                printf("%d ",m[i][j]);
//            }
//            printf("\n");
//        }
        ans = -1;
        for(int i = 0 ; i &lt;= 15 ; i++) {
            A_Star(xx,yy,0,i);
            if(~ans)
                break;
        }
        printf("%d\n",ans);
    }
    return 0;
}

/*

2
10110
01*11
10111
01001
00000
01011
110*1
01110
01010
00100

*/</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>368</wp:post_id>
		<wp:post_date><![CDATA[2019-06-03 19:09:25]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-06-03 11:09:25]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[hysbz-1085-%e9%aa%91%e5%a3%ab%e7%b2%be%e7%a5%9e-ida_stardfs-2]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="tijie"><![CDATA[题解]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[neve_meta_content_width]]></wp:meta_key>
		<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wp_old_slug]]></wp:meta_key>
		<wp:meta_value><![CDATA[hysbz-1085-%e9%aa%91%e5%a3%ab%e7%b2%be%e7%a5%9e-ida_stardfs-2__trashed]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[好题!]HDU-5877-Weak Pair-树状数组+DFS+离散化</title>
		<link>https://sdnuqp.cn/%e5%a5%bd%e9%a2%98hdu-5877-weak-pair-%e6%a0%91%e7%8a%b6%e6%95%b0%e7%bb%84dfs%e7%a6%bb%e6%95%a3%e5%8c%96/</link>
		<pubDate>Mon, 03 Jun 2019 11:12:20 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=371</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>貌似是16年区域赛大连站的一道题，我们知道DFS要消除后效性，比如：vis[...] = 1,dfs(),vis[...] = 0.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>但这道题没有用这么低级的vis标记，而是与树状数组(或线段树)联系起来!</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>好题，没见过，真的想不到！！！！</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>




/*
1.树状数组在DFS中在线更新!
2.k/a[i] 加入要离散化的数组中!
3.树状数组维护小于a[i]的值的个数!

*/


#include &lt;bits/stdc++.h>
using namespace std;
const int maxn = 2e5 + 10;

int t;
int n;
long long k;
long long ans;
int u,v;
int a[maxn];    ///记录输入1-N
int c[maxn];    ///树状数组
struct node {
    vector &lt;int > child;
}tree[maxn];

int mark_root[maxn];///标记根节点

map &lt;int ,int > vis; ///标记节点的值(离散化时数据不重复)
vector &lt;int > vec;   ///离散化，利用vec.upperbound(???) - vec.begin()得到离散化后的编号(大佬的离散化,Orz)

int lowbit(int x){
    return x &amp; -x;
}

void update(int x ,int y){
    while(x &lt;= maxn){
        c[x] += y;
        x += lowbit(x);
    }
}

int getsum(int x){
    int ans = 0 ;
    while(x >= 1){
        ans += c[x];
        x -= lowbit(x);
    }
    return ans;
}

void init(){
    ans = 0L;
    vec.clear();
    vis.clear();
    for(int i = 1 ; i &lt;= maxn ; i++){
        tree[i].child.clear();
        mark_root[i] = 0;
        c[i] = 0;
    }
}

void DFS(int x){
    int len = tree[x].child.size();
    int pos = upper_bound(vec.begin(),vec.end(),k/a[x]) - vec.begin();   ///大佬的离散化。。。。
    int posthis = lower_bound(vec.begin(),vec.end(),a[x]) - vec.begin();

    ans += getsum(pos);

    update(posthis + 1,1);

    for(int i = 0 ; i &lt; len ; i++){
        DFS(tree[x].child[i]);
    }
    update(posthis + 1,-1);
}

int main() {
    scanf("%d",&amp;t);
    while(t--) {
        init();
        scanf("%d %lld",&amp;n,&amp;k);
        for(int i = 1; i &lt;= n ; i++){
            scanf("%d",&amp;a[i]);
            if(vis[a[i]] == 0){
                vec.push_back(a[i]);
                vis[a[i]] = 1 ;
            }
        }

        sort(vec.begin(),vec.end());
        for(int i = 1; i &lt; n ; i++){
            scanf("%d %d",&amp;u,&amp;v);
            mark_root[v] = 1;
            tree[u].child.push_back(v);
        }

        for(int i = 1; i &lt;= n ; i++){
            if(!mark_root[i]){
                DFS(i);
                break;
            }
        }
        printf("%lld\n",ans);
    }
}



</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>371</wp:post_id>
		<wp:post_date><![CDATA[2019-06-03 19:12:20]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-06-03 11:12:20]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%a5%bd%e9%a2%98hdu-5877-weak-pair-%e6%a0%91%e7%8a%b6%e6%95%b0%e7%bb%84dfs%e7%a6%bb%e6%95%a3%e5%8c%96]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="tijie"><![CDATA[题解]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[neve_meta_content_width]]></wp:meta_key>
		<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[专题二：搜索进阶]ZOJ - 2477-Magic Cube-IDA_Star</title>
		<link>https://sdnuqp.cn/zoj-2477-magic-cube-ida_star/</link>
		<pubDate>Mon, 03 Jun 2019 11:25:28 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=373</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:code -->
<pre class="wp-block-code"><code>

这个题可以用BFS，我本来写的BFS，但是！！！12次旋转太难写了！！！把我写崩了，提前打表的IDA*，这个表也不好打呀，出题人意图何在！？




#include&lt;cstdio>
#include&lt;algorithm>
#include&lt;iostream>
#include&lt;cstring>
#include&lt;cmath>

using namespace std;

int n,m,depth;
int ans[10],dir[10];
char a[100];

int centre[6]= {5,23,26,29,32,50};
int row[6][10] = {
    {1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 },
    {10, 11, 12, 22, 23, 24, 34, 35, 36},
    {13, 14, 15, 25, 26, 27, 37, 38, 39},
    {16, 17, 18, 28, 29, 30, 40, 41, 42},
    {19, 20, 21, 31, 32, 33, 43, 44, 45},
    {46, 47, 48, 49, 50, 51, 52, 53, 54}
};

int change[12][20]= { //12表示12种操作，20是因为每一种操作都会导致20个格子发生变化;
    {12, 24, 36, 35, 34, 22, 10, 11, 13, 25, 37, 46, 49, 52, 45, 33, 21, 1, 4, 7},
    {10, 11, 12, 24, 36, 35, 34, 22, 1, 4, 7, 13, 25, 37, 46, 49, 52, 45, 33, 21},
    {15, 27, 39, 38, 37, 25, 13, 14, 16, 28, 40, 48, 47, 46, 36, 24, 12, 7, 8, 9},
    {13, 14, 15, 27, 39, 38, 37, 25, 7, 8, 9, 16, 28, 40, 48, 47, 46, 36, 24, 12},
    {18, 30, 42, 41, 40, 28, 16, 17, 19, 31, 43, 54, 51, 48, 39, 27, 15, 9, 6, 3},
    {16, 17, 18, 30, 42, 41, 40, 28, 9, 6, 3, 19, 31, 43, 54, 51, 48, 39, 27, 15},
    {21, 33, 45, 44, 43, 31, 19, 20, 3, 2, 1, 10, 22, 34, 52, 53, 54, 42, 30, 18},
    {19, 20, 21, 33, 45, 44, 43, 31, 42, 30, 18, 3, 2, 1, 10, 22, 34, 52, 53, 54},
    {3, 6, 9, 8, 7, 4, 1, 2, 18, 17, 16, 15, 14, 13, 12, 11, 10, 21, 20, 19},
    {1, 2, 3, 6, 9, 8, 7, 4, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10},
    {48, 51, 54, 53, 52, 49, 46, 47, 40, 41, 42, 43, 44, 45, 34, 35, 36, 37, 38, 39},
    {46, 47, 48, 51, 54, 53, 52, 49, 37, 38, 39, 40, 41, 42, 43, 44, 45, 34, 35, 36}
};

int geth() {
    int sum=0;
    for(int i=0; i&lt;6; i++) {
        for(int j=0; j&lt;9; j++)
            if(a[row[i][j]]!=a[centre[i]])
                sum++;
    }
    return sum;
}

int solve(int d) {
    int h=geth();
    if(d+ceil(h/12.0)>depth)
        return 0;
    if(h==0)
        return 1;
    char maze[100];
    //memcpy(maze,a,sizeof(a));
    for(int i=0; i&lt;12; i++) {
        memcpy(maze,a,sizeof(a));
        for(int j = 0; j &lt; 20; j++)
            a[change[i][j]] = maze[change[i^1][j]];//这里的^是用来如果i为偶数则+1，若为奇数则i-1，这样使得在减小代码量的前提下进行魔方位置的模拟。
        
        ans[d]=i/2;
        
        if(!(i&amp;1))
            dir[d]=1;
        else
            dir[d]=-1;
        if(solve(d+1))
            return 1;
        memcpy(a,maze,sizeof(maze));
    }
    return 0;
}

int main() {
    int t;
    scanf("%d",&amp;t);
    while(t--) {
        for(int i=1; i&lt;=54; i++)
            cin>>a[i];
        if(!geth()) {
            printf("0\n");
            continue;
        }
        for(depth=1; depth&lt;=5; depth++)
            if(solve(0))
                break;
        if(depth==6)
            printf("-1\n");
        else {
            printf("%d\n",depth);
            for(int i=0; i&lt;depth; i++)
                printf("%d %d\n",ans[i],dir[i]);
        }
    }
    return 0;
}</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>373</wp:post_id>
		<wp:post_date><![CDATA[2019-06-03 19:25:28]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-06-03 11:25:28]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[zoj-2477-magic-cube-ida_star]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="kuangbin"><![CDATA[kuangbin专题]]></category>
		<category domain="category" nicename="tijie"><![CDATA[题解]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[neve_meta_content_width]]></wp:meta_key>
		<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[专题二：搜索进阶]HDU-3085-Nightmare Ⅱ-双向BFS</title>
		<link>https://sdnuqp.cn/hdu-3085-nightmare-%e2%85%a1-%e5%8f%8c%e5%90%91bfs/</link>
		<pubDate>Mon, 03 Jun 2019 11:26:00 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=376</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:code -->
<pre class="wp-block-code"><code>




#include &lt;cstdio>
#include &lt;iostream>
#include &lt;algorithm>
#include &lt;cstring>
#include &lt;queue>
using namespace std;
const int maxn = 810;

int n,m;
char c[maxn][maxn];
bool vis[2][maxn][maxn];
int ghost[3][2];
int mx,my;
int gx,gy;
int flag;
int dir[5][2] = {0,0, 0,1 ,0,-1, 1,0, -1,0};

struct node {
    int x;
    int y;
};
queue &lt;node> q[2];

bool judge(int x,int y, int time){
    if(abs(x - ghost[1][0]) + abs(y - ghost[1][1]) &lt;= 2 * time)
        return 0;
    if(abs(x - ghost[0][0]) + abs(y - ghost[0][1]) &lt;= 2 * time)
        return 0;
    return 1;
}

bool bfs(int id ,int time){
    int len = q[id].size();
    node p,t;
    while(len--){
        p = q[id].front();
        q[id].pop();
        if(!judge(p.x,p.y,time)){
            continue;
        }
        for(int i = 0; i &lt;= 4 ; i++){
            t.x = p.x + dir[i][0];
            t.y = p.y + dir[i][1];
            if(t.x >= 1 &amp;&amp; t.x &lt;= n &amp;&amp; t.y >= 1 &amp;&amp; t.y &lt;= m &amp;&amp; c[t.x][t.y] != 'X' &amp;&amp; c[t.x][t.y] != 'Z' &amp;&amp; vis[id][t.x][t.y] == 0 &amp;&amp; judge(t.x,t.y,time)){
                vis[id][t.x][t.y] = 1;
                if(vis[!id][t.x][t.y] == 1){
                    return 1;
                }
                q[id].push(t);
            }
        }
    }
    return 0;
}

void solve(){
    while(!q[0].empty()){
        q[0].pop();
    }
    while(!q[1].empty()){
        q[1].pop();
    }

    node p;
    p.x = mx;
    p.y = my;
    vis[0][p.x][p.y] = 1;
    q[0].push(p);

    p.x = gx;
    p.y = gy;
    vis[1][p.x][p.y] = 1;
    q[1].push(p);

    int time = 0;
    flag = 0;
    while(!q[0].empty() || !q[1].empty()){
        time++;
        for(int i = 1; i &lt;= 3 ; i++){
            if(bfs(0,time)){
                printf("%d\n",time);
                return ;
            }
        }
        if(bfs(1,time)){
            printf("%d\n",time);
            return ;
        }
    }
    printf("-1\n");
}

int main(){
    int t;
    scanf("%d ",&amp;t);
    while(t--){
        scanf("%d %d",&amp;n,&amp;m);
        getchar();
        memset(vis,0,sizeof vis);
        memset(ghost,0,sizeof ghost);
        for(int i = 1 ; i &lt;= n ; i++){
            scanf("%s",c[i]+1);
        }
        for(int i = 1; i &lt;= n ; i++){
            for(int j = 1; j &lt;= m ; j++){
                if(c[i][j] == 'Z'){
                    if(ghost[0][0] == 0){
                        ghost[0][0] = i;
                        ghost[0][1] = j;
                    }
                    else{
                        ghost[1][0] = i;
                        ghost[1][1] = j;
                    }
                }
                if(c[i][j] == 'G'){
                    gx = i;
                    gy = j;
                }
                if(c[i][j] == 'M'){
                    mx = i;
                    my = j;
                }
            }
        }

        solve();
    }
    return 0;
}



/*


3
5 6
XXXXXX
XZ..ZX
XXXXXX
M.G...
......
5 6
XXXXXX
XZZ..X
XXXXXX
M.....
..G...

10 10
..........
..X.......
..M.X...X.
X.........
.X..X.X.X.
.........X
..XX....X.
X....G...X
...ZX.X...
...Z..X..X


*/</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>376</wp:post_id>
		<wp:post_date><![CDATA[2019-06-03 19:26:00]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-06-03 11:26:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu-3085-nightmare-%e2%85%a1-%e5%8f%8c%e5%90%91bfs]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="kuangbin"><![CDATA[kuangbin专题]]></category>
		<category domain="category" nicename="tijie"><![CDATA[题解]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[neve_meta_content_width]]></wp:meta_key>
		<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[专题二：搜索进阶]HDU-3001-Travelling-状压DP(三进制)+BFS</title>
		<link>https://sdnuqp.cn/hdu-3001-travelling-%e7%8a%b6%e5%8e%8bdp%e4%b8%89%e8%bf%9b%e5%88%b6bfs/</link>
		<pubDate>Mon, 03 Jun 2019 11:26:51 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=379</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>你们看错，这题我不会</p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>379</wp:post_id>
		<wp:post_date><![CDATA[2019-06-03 19:26:51]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-06-03 11:26:51]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu-3001-travelling-%e7%8a%b6%e5%8e%8bdp%e4%b8%89%e8%bf%9b%e5%88%b6bfs]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="kuangbin"><![CDATA[kuangbin专题]]></category>
		<category domain="category" nicename="tijie"><![CDATA[题解]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[neve_meta_content_width]]></wp:meta_key>
		<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[专题二：搜索进阶]HDU-2102-A计划-BFS</title>
		<link>https://sdnuqp.cn/hdu-2102-a%e8%ae%a1%e5%88%92/</link>
		<pubDate>Mon, 03 Jun 2019 11:27:14 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=381</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:code -->
<pre class="wp-block-code"><code>

这题只是简单BFS，应该放在上一个专题吧。。。


#include &lt;bits/stdc++.h>
using namespace std;
const int maxn = 10 + 1;

int m,n,z;
char c[2][maxn][maxn];
int mark_map[2+1][maxn+1][maxn+1];
int dir[5][2] = {{0,0},{1,0},{-1,0},{0,1},{0,-1}};

int position_princess_x;
int position_princess_y;
int position_princess_z;

struct node {
    int x;
    int y;
    int z;
    int sum;
};

bool check(int x, int y, int z){
    if(x >= 0 &amp;&amp; x &lt; m &amp;&amp; y >= 0 &amp;&amp; y &lt; n &amp;&amp; z >= 0 &amp;&amp; z &lt; 2 &amp;&amp; mark_map[z][x][y] == 0){
        return 1;
    }
    return 0;
}

queue &lt;node >q;
void bfs(){
    node p,t;
    p.x = 0;
    p.y = 0;
    p.z = 0;
    p.sum = 0;
    mark_map[p.z][p.x][p.y] = 0;
    q.push(p);
    while(!q.empty()){
        p = q.front();
        q.pop();
        if(p.x == position_princess_x)
            if(p.y == position_princess_y)
                if(p.z == position_princess_z){
                    printf("YES\n");
                    while(!q.empty()){
                        q.pop();
                    }
                    return ;
                }
        if(p.sum >= z)
            continue;
        for(int i = 1 ; i &lt;= 4 ; i++){
            t.x = p.x + dir[i][0];
            t.y = p.y + dir[i][1];
            t.z = p.z;
            t.sum = p.sum + 1;
            if(check(t.x, t.y, t.z)){
                if(c[t.z][t.x][t.y] == '.'){
                    mark_map[t.z][t.x][t.y] = 1;
                    q.push(t);
                }
                else if(c[t.z][t.x][t.y] == '#'){
                    if(c[1-p.z][t.x][t.y] == '.' &amp;&amp; mark_map[1-p.z][t.x][t.y] == 0){
                        t.z = 1 - p.z ;
                        mark_map[t.z][t.x][t.y] = 1;
                        mark_map[1-p.z][t.x][t.y] = 1;
                        q.push(t);
                    }
                }
            }
        }
    }
    printf("NO\n");
    return ;
}

int main() {
    int t;
    scanf("%d",&amp;t);
    while(t--) {
        memset(mark_map,0,sizeof mark_map);
        scanf("%d %d %d",&amp;m,&amp;n,&amp;z);
        getchar();
        for(int k = 0 ; k &lt; 2 ; k++) {
            for(int i = 0 ; i &lt; m ; i++) {
                for(int j = 0 ; j &lt; n ; j++) {
                    scanf("%c",&amp;c[k][i][j]);
                    if(c[k][i][j] == 'P'){
                        position_princess_x = i;
                        position_princess_y = j;
                        position_princess_z = k;
                        c[k][i][j] = '.';
                    }
                }
                getchar();
            }
            !k?getchar():1;
        }
//        printf("\n>>>>\n");
//        for(int i = 0 ; i &lt; 2 ; i++){
//            for(int j = 0 ; j &lt; m ; j++){
//                printf("%s \n",c[i][j]);
//            }
//            printf("\n");
//        }

        bfs();


    }
    return 0;
}</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>381</wp:post_id>
		<wp:post_date><![CDATA[2019-06-03 19:27:14]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-06-03 11:27:14]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu-2102-a%e8%ae%a1%e5%88%92]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="kuangbin"><![CDATA[kuangbin专题]]></category>
		<category domain="category" nicename="tijie"><![CDATA[题解]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[neve_meta_content_width]]></wp:meta_key>
		<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
							<wp:comment>
			<wp:comment_id>271</wp:comment_id>
			<wp:comment_author><![CDATA[EleoMog]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[eleoImimuse@parkll.xyz]]></wp:comment_author_email>
			<wp:comment_author_url>http://abuycialisb.com</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[5.188.84.6]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2020-02-16 17:37:09]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2020-02-16 09:37:09]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Is Keflex Sulfur Drug  http://abuycialisb.com - Cialis Buy Generic Cialis  <a href="http://abuycialisb.com" rel="nofollow">Buy Cialis</a> Cialis 5mg Comprime]]></wp:comment_content>
			<wp:comment_approved><![CDATA[0]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
							</wp:comment>
					</item>
					<item>
		<title>[专题二：搜索进阶]HDU-1560-DNA sequence-IDA_Star</title>
		<link>https://sdnuqp.cn/hdu-1560-dna-sequence-ida_star/</link>
		<pubDate>Mon, 03 Jun 2019 11:28:01 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=384</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:preformatted -->
<pre class="wp-block-preformatted">///大部分这个题我用了，BFS，A<em>,结过给我一排MLE，这个题解和我写的差不多，只是他用的IDA</em>，直接交了，不做了 
 include 
 include 
 include 
 include 
 using namespace std;
 int n,deep;
 char c[10] = "ACGT";
 struct node
 {
     char s[10];
     int len;
 } a[10];
 int pos[10];
 int get_h()
 {
     int ans = 0;
     for(int i = 1; i&lt;=n; i++)
         ans = max(ans,a[i].len-pos[i]);
     return ans;
 }
 int dfs(int step)
 {
     if(step+get_h()>deep)
         return 0;
     if(!get_h())
         return 1;
     int i,j;
     int tem[10];
     for(i = 0; i&lt;4; i++)
     {
         int flag = 0;
         for(j = 1; j&lt;=n; j++)
             tem[j] = pos[j];
         for(j = 1; j&lt;=n; j++)
         {
             if(a[j].s[pos[j]] == c[i])
             {
                 flag = 1;
                 pos[j]++;
             }
         }
         if(flag)
         {
             if(dfs(step+1))
                 return 1;
             for(j = 1; j&lt;=n; j++)
                 pos[j] = tem[j];
         }
     }
     return 0;
 }
 int main()
 {
     int t,i,j,maxn;
     cin >> t;
     while(t--)
     {
         cin>>n;
         maxn = 0;
         for(i = 1; i&lt;=n; i++)         {             cin>>a[i].s;
             a[i].len = strlen(a[i].s);
             maxn = max(maxn,a[i].len);
             pos[i] = 0;
         }
         deep = maxn;
         while(1)
         {
             if(dfs(0))break;
             deep++;
         }
         cout &lt;&lt; deep &lt;&lt; endl;
     }
 <code>return 0;</code>
 }</pre>
<!-- /wp:preformatted -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>384</wp:post_id>
		<wp:post_date><![CDATA[2019-06-03 19:28:01]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-06-03 11:28:01]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu-1560-dna-sequence-ida_star]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="kuangbin"><![CDATA[kuangbin专题]]></category>
		<category domain="category" nicename="tijie"><![CDATA[题解]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[neve_meta_content_width]]></wp:meta_key>
		<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[专题二：搜索进阶]HDU-1067-GAP-BFS</title>
		<link>https://sdnuqp.cn/hdu-1067-gap-bfs/</link>
		<pubDate>Mon, 03 Jun 2019 11:28:58 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=386</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:code -->
<pre class="wp-block-code"><code>
题不难，输入是一坨屎。


#include &lt;bits/stdc++.h>
using namespace std;

char begin_c[5][9];
char end_c[4][8] = {
    11,12,13,14,15,16,17,8,
    21,22,23,24,25,26,27,8,
    31,32,33,34,35,36,37,8,
    41,42,43,44,45,46,47,8
};

char begin_str[50];
char end_str[50];

unordered_map&lt;string, bool>mp;

struct node {
    char c[40];
    int dir[5];
    int sum;
};

bool judge(node p) {

//    for(int i = 1 ; i &lt; strlen(end_str) ; i++) {
//        printf("%d ",end_str[i]);
//    }
//    printf(">>>\n");
//    for(int i = 1; i &lt; strlen(p.c) ; i++) {
//        printf("%d ",p.c[i]);
//    }
//    printf("\n");
    if(strcmp(p.c+1,end_str+1) == 0) {
        return 1;
    }
    return 0;
}

bool check(char *a, int pos) {
    if((int)a[pos-1]%10 &lt; 7) {
//        printf("b\n");
        return true;
    }
    return false;
}

int find_pos(char *a, int pos) {
    for(int i = 0 ; i &lt; 32 ; i++) {
        if(a[i] == a[pos]+1)
            return i;
    }
}

queue&lt;node>q;
void bfs() {
    node p,t;
    strcpy(p.c, begin_str);
//    printf("begin:  %d>>\n",strlen(p.c));
//    for(int j = 0 ; j &lt; strlen(p.c) ; j++) {
//        printf("%2d ",p.c[j]);
//        if((j+1)%8 == 0)
//            printf("\n");
//    }
//    printf(">>>>>>>>>>>>>>>\n");
    p.sum = 0;

    int cnt = 1;
    for(int i = 0; i &lt; 32 ; i++) {
        if(p.c[i] == 8) {
            p.dir[cnt++] = i;
        }
    }
    q.push(p);
    int z;
    while(!q.empty()) {
        p = q.front();
        q.pop();
        if(judge(p)) {
            printf("%d\n",p.sum);
            while(!q.empty()) {
                q.pop();
            }
            return ;
        }
        for(int i = 1; i &lt;= 4 ; i++) {
            strcpy(t.c,p.c);
            memcpy(t.dir, p.dir, sizeof p.dir);
//            for(int i = 1; i &lt;= 4 ; i++){
//                printf("%d ",t.dir[i]);
//            }
//            printf("\n");

//            for(int i = 0 ; i &lt;= 31 ; i++) {
//                printf("%d ",t.c[i]);
//                if((i+1)%8 == 0)
//                    printf("\n");
//            }
//            printf("sadf\n");
            t.sum = p.sum + 1;
            if(check(t.c,p.dir[i])) {
                z = find_pos(t.c, p.dir[i]-1);
//                printf("&lt;%d>\n",z);
                swap(t.c[z], t.c[t.dir[i]]);
                t.dir[i] = z;
                if(mp[t.c] == 0) {
                    mp[t.c] = 1;
//                    for(int i = 0 ; i &lt; 32 ; i++) {
//                        printf("%2d ",t.c[i]);
//                        if((i+1)%8 == 0)
//                            printf("\n");
//                    }
//                    printf(">>>\n");
                    q.push(t);
                }
            }
        }
    }
    printf("-1\n");
    return ;
}

int main() {
    int t;
    int x;
    int cnt;
    scanf("%d",&amp;t);
    while(t--) {
//        memset(begin_str,'\0',sizeof begin_str);
//        memset(end_str,'\0',sizeof end_str);
//        memset(begin_c,'\0',sizeof begin_c);
        mp.clear();

        getchar();
        cnt = 1;
        for(int i = 1 ; i &lt;= 4 ; i++) {
            for(int j = 2 ; j &lt;= 8 ; j++) {
                scanf("%d",&amp;x);
                begin_c[i][j] = x;
                if(begin_c[i][j]%10 == 1) {
                    begin_c[begin_c[i][j]/10][1] = begin_c[i][j];
                    begin_c[i][j] = 8;
                }
            }
        }

//        for(int i = 1 ; i &lt;= 4 ; i++){ ///输入测试
//            for(int j = 1; j &lt;= 8 ; j++){
//                printf("%2d ",begin_c[i][j]);
//            }
//            printf("\n");
//        }

        cnt = 0;
        for(int i = 1 ; i &lt;= 4 ; i++) {
            for(int j = 1 ; j &lt;= 8 ; j++) {
                begin_str[cnt++] = begin_c[i][j];
            }
        }

        cnt = 0;
        for(int i = 0 ; i &lt; 4 ; i++) {
            for(int j = 0 ; j &lt; 8 ; j++) {
                end_str[cnt++] = end_c[i][j];
            }
        }

        mp[begin_str] = true;
//
//        for(int i = 0 ; i &lt; 32 ; i++){   ///test
//            printf("%2d ",begin_str[i]);
//            if((i+1)%8 == 0)
//                printf("\n");
//        }
//
//        printf("end_str:\n");
//        for(int j = 0; j &lt; 32 ; j++){
//            printf("%2d ",end_str[j]);
//            if((j+1)%8 == 0)
//                printf("\n");
//        }
//        printf("\n");

        bfs();

    }
}


/*

4

12 13 14 15 16 17 21
22 23 24 25 26 27 31
32 33 34 35 36 37 41
42 43 44 45 46 47 11

26 31 13 44 21 24 42
17 45 23 25 41 36 11
46 34 14 12 37 32 47
16 43 27 35 22 33 15

17 12 16 13 15 14 11
27 22 26 23 25 24 21
37 32 36 33 35 34 31
47 42 46 43 45 44 41

27 14 22 35 32 46 33
13 17 36 24 44 21 15
43 16 45 47 23 11 26
25 37 41 34 42 12 31

*/</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>386</wp:post_id>
		<wp:post_date><![CDATA[2019-06-03 19:28:58]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-06-03 11:28:58]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu-1067-gap-bfs]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="kuangbin"><![CDATA[kuangbin专题]]></category>
		<category domain="category" nicename="tijie"><![CDATA[题解]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[neve_meta_content_width]]></wp:meta_key>
		<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[专题二：搜索进阶]HDU-3567-Eight II-hash+康托+bfs打表</title>
		<link>https://sdnuqp.cn/hdu-3567-eight-ii-hash%e5%ba%b7%e6%89%98bfs%e6%89%93%e8%a1%a8/</link>
		<pubDate>Mon, 03 Jun 2019 11:32:20 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=396</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:code -->
<pre class="wp-block-code"><code>因为一点小问题，vis[pl] = 1，写成了vis[pz] = 1，一直WA。。。。。。。。。。。。。。。。。。。



#include &lt;cstdio>
#include &lt;cstring>
#include &lt;algorithm>
#include &lt;queue>
#include &lt;stack>
using namespace std;
const int maxn = 5e5 + 10;

//int des[4][2] = {{0,1},{0,-1},{1,0},{-1,0}};
int des[4][2] = {{1,0},{0,-1},{0,1},{-1,0}};
//char ds[4] = {'l','r','u','d'};
char ds[4] = {'d','l','r','u'};
//int dz[4] = {-1,1,-3,3};
int dz[4] = {-3,1,-1,3};


struct p {
    int x;
    int y;
    int m[10];
};

struct p start,ed;

int son[11][maxn];
char dir[11][maxn];
bool vis[maxn*10];
char c[1000];
char c2[1000];
char c3[2000];
int xx[11];

int cantor(p pz) {
    int ans = 0;
    int fac = 40320;
    for(int i = 0 ; i &lt;= 8 ; i++) {
        int cnt = 0;
        for(int j = i + 1; j &lt;= 8 ; j++) {
            if(pz.m[i] > pz.m[j]) {
                cnt++;
            }
        }
        ans += cnt * fac;
        if(i == 8) {
            return ans;
        }
        fac /= 8-i;
    }
}

bool check(int x,int y) {
    if( x >= 0 &amp;&amp; y >= 0 &amp;&amp; x &lt;= 2 &amp;&amp; y &lt;= 2 )
        return 1;
    return 0;
}

void bfs(int id,p pl) {
    memset(vis,0,sizeof vis);
    p pz,pp;
    queue&lt;p>q;
    q.push(pl);
    int can1,can2;
    can1 = cantor(pl);
    vis[can1] = 1;
    while(!q.empty()) {
        pz = q.front();
        q.pop();
        can1 = cantor(pz);
        for(int i = 0 ; i &lt; 4 ; i++) {
            pp = pz;
            pp.x += des[i][0];
            pp.y += des[i][1];
            if(!check(pp.x,pp.y)) {
                continue;
            }
            int pos = pp.x * 3 + pp.y;
            swap(pp.m[pos],pp.m[pos+dz[i]]);
            can2 = cantor(pp);
            if(!vis[can2]) {
                vis[can2] = 1;
//                printf("%d %c>>\n",can2,ds[i]);
                dir[id][can2] = ds[i];
                son[id][can2] = can1;
                q.push(pp);
            }
        }
    }
}


void Preprocessing() {
    p t;
    for(int i = 0 ; i &lt; 9 ; i++) {
        t.m[i] = i + 1;
    }
    for(int i = 0 ; i &lt; 9 ; i++) {
        if(i)
            t.m[i-1] = i;
        t.m[i] = 0;
        t.x = i/3;
        t.y = i%3;
//        for(int j = 0 ; j &lt;= 8 ; j++){
//            printf("%d ",t.m[j]);
//        }
//        printf("\n");
        bfs(i,t);
    }

}

int main() {

    Preprocessing();

    int tt;
    scanf("%d",&amp;tt);
    getchar();
    int id;
    for(int t = 1 ; t &lt;= tt ; t ++) {
        gets(c);
        int cnt = 0;
        for(int i = 0 ; i &lt; strlen(c) ; i++) {
            if(c[i] >= 49 &amp;&amp; c[i] &lt;= 57) {
                start.m[cnt++] = c[i] - 48;
            } else if(c[i] == 'X')
                start.m[cnt++] = 0;
        }

        for(int i = 0 ; i &lt; 9 ; i++) {
            if(start.m[i]) {
                xx[start.m[i]] = i+1 ;
                start.m[i] = i+1 ;
            } else {
                id = i;
            }
        }

        gets(c2);
//        printf("%s\n%s\n",c,c2);
        cnt = 0;
        for(int i = 0 ; i &lt; strlen(c2) ; i++) {
            if(c2[i] >= 49 &amp;&amp; c2[i] &lt;= 57) {
                ed.m[cnt++] = (c2[i] - 48);
            } else if(c2[i] == 'X')
                ed.m[cnt++] = 0;
        }

        for(int i = 0 ; i &lt; 9 ; i++) {
            if(ed.m[i]) {
                ed.m[i] = xx[ed.m[i]];
            }
        }

        for(int i = 0 ; i &lt; 9 ; ++i){
            printf("%d",start.m[i]);
        }
        printf("\n");
           for(int i = 0 ; i &lt; 9 ; ++i){
           printf("%d",ed.m[i]);
        }
        printf("\n");
        printf("%d>>",id);
}


/*

4
12X453786
12345678X
564178X23
7568X4123
12X453786
12345678X
564178X23
7568X4123
*/
</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>396</wp:post_id>
		<wp:post_date><![CDATA[2019-06-03 19:32:20]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-06-03 11:32:20]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu-3567-eight-ii-hash%e5%ba%b7%e6%89%98bfs%e6%89%93%e8%a1%a8]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="kuangbin"><![CDATA[kuangbin专题]]></category>
		<category domain="category" nicename="tijie"><![CDATA[题解]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[neve_meta_content_width]]></wp:meta_key>
		<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>using的用法</title>
		<link>https://sdnuqp.cn/using%e7%9a%84%e7%94%a8%e6%b3%95/</link>
		<pubDate>Mon, 10 Jun 2019 13:06:20 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=428</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>我们知道常规用法（大部分人也只会这种用法。。。）: </p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>使用名称空间。</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>using namespace std;</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>第二种用法：</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>using ll = long long ;</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>没见过的，第一眼肯定很惊讶，心中想：“卧槽，什么鬼东西？心中万匹草泥马跑过。。。。”</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>但是一运行，没报错！？这是转念一想：“估计又是C11里的神奇东东”</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>百度一下，发现果然是C++11中的特殊用法</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>它等于：</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>typedef long long ll;</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>作用叫：设置别名</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>这个作用，我只是举了最简单的一个例子，更高级的请自行百度。。。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>各种神奇的起别名。。。。。。。。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>第三种是在子类中引用基类成员</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>类我还没怎么学，以后再说了。</p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>428</wp:post_id>
		<wp:post_date><![CDATA[2019-06-10 21:06:20]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-06-10 13:06:20]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[using%e7%9a%84%e7%94%a8%e6%b3%95]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="c11"><![CDATA[基础__C++11]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>位运算操作</title>
		<link>https://sdnuqp.cn/%e4%bd%8d%e8%bf%90%e7%ae%97%e6%93%8d%e4%bd%9c/</link>
		<pubDate>Fri, 19 Jul 2019 08:24:01 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=433</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>一点小测试，后面才是正文</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":1} -->
<h1>include </h1>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>using namespace std;</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>int lowbit(int x){<br>
    return x &amp; -x;<br>
}</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>int main() {<br>
    int n;</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>n = 16;

printf("n = %d",n);
printf("二进制:");
while(n) {
    if(n &amp; 1)
        printf("1");
    else
        printf("0");
    n >>= 1;
}
printf("\n");

n = 16;
printf("n|1     : %d\n",n|1);///一个为1，则为1
printf("n|(1&lt;&lt;3): %d\n",n|(1&lt;&lt;3));///特定位赋值
printf("n|0     : %d\n",n|0);///它本身

printf("n&amp;1     : %d\n",n&amp;1);///都为1，则为1
printf("n&amp;0     : %d\n",n&amp;0);///0

printf("n^1     : %d\n",n^1);///不同为1，相同为0
printf("n^0     : %d\n",n^0);///它本身

printf("-n      : %d\n",-n);
printf("n&amp;-n    : %d\n",n&amp;(-n));///emmmmmm，不知怎么描述...lowbit数组操作

if(-n == ~n + 1){   ///它们相等
    printf("~n+1      :%d ",~n+1);
}

return 0;</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>}</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>输出：<br>
n = 16二进制:00001<br>
n|1     : 17<br>
n|(1&lt;&lt;3): 24<br>
n|0     : 16<br>
n&amp;1     : 0<br>
n&amp;0     : 0<br>
n^1     : 17<br>
n^0     : 16<br>
-n      : -16<br>
n&amp;-n    : 16<br>
~n+1      :-16</p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>433</wp:post_id>
		<wp:post_date><![CDATA[2019-07-19 16:24:01]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-07-19 08:24:01]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e4%bd%8d%e8%bf%90%e7%ae%97%e6%93%8d%e4%bd%9c]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="sundry"><![CDATA[杂项]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>RMQ(Range Min/Max Query)算法</title>
		<link>https://sdnuqp.cn/rmqrange-min-max-query%e7%ae%97%e6%b3%95/</link>
		<pubDate>Fri, 19 Jul 2019 08:52:56 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=435</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>区间最值查询算法</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>采用dp的思想</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>


/*

RMQ算法
区间最值查询算法

*/

#include &lt;bits/stdc++.h>
using namespace std;

int n;
int a[101];
int dp[101][101];

int RMQ_init() {
    for(int i = 1; i &lt;= n; i++) {
        dp[i][0] = a[i];
    }
    for(int j = 1; (1 &lt;&lt; j) &lt;= n ; j++) {
        for(int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; i++) {
            dp[i][j] = min(dp[i][j - 1], dp[i + (1 &lt;&lt; j - 1)][j - 1]);
        }
    }
}

int RMQ_query(int l, int r) {
    int k = log2(r - l + 1);
    return min(dp[l][k], dp[r - (1 &lt;&lt; k) + 1][k]);
}

int main() {
    scanf("%d", &amp;n);
    for(int i = 1; i &lt;= n ; i++) {
        scanf("%d", &amp;a[i]);
    }
    RMQ_init();
    int a, b;
    while(scanf("%d %d",&amp;a,&amp;b) != EOF) {
        int x = RMQ_query(a, b);
        printf("%d\n", x);
    }
    return 0;
}

/*

10
1 3 7 2 5 8 9 4 10 6
2 2
2 3
2 4
5 10

*/
</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>435</wp:post_id>
		<wp:post_date><![CDATA[2019-07-19 16:52:56]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-07-19 08:52:56]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[rmqrange-min-max-query%e7%ae%97%e6%b3%95]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84__rmq"><![CDATA[数据结构__RMQ]]></category>
		<category domain="category" nicename="algorithm"><![CDATA[算法]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>happy</title>
		<link>https://sdnuqp.cn/happy/</link>
		<pubDate>Sat, 20 Jul 2019 10:43:20 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=437</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:code -->
<pre class="wp-block-code"><code>#include&lt;stdio.h>
#include&lt;stdlib.h>
#include&lt;windows.h>
int main()
{
    system("pause");
    system("cls");
    HANDLE handle = GetStdHandle(STD_OUTPUT_HANDLE);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_RED | FOREGROUND_GREEN );
    printf(" ");
    printf("                                                                                         **\n");
    Sleep(200);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_RED );
    printf("                                                                                        !■■!\n");
    Sleep(200);
    printf("                                                                                        !■■!\n");
    Sleep(200);
    printf("                                                                                        !■■!\n");
    Sleep(200);
    printf("                                                                                        !■■!\n");
    Sleep(200);
    printf("                                                                                        !■■!\n");
    Sleep(200);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_RED | FOREGROUND_GREEN);
    printf("                                                                      ( ■■■■■■■■■■■■■■■■■■■ )\n");
    Sleep(200);
    printf("                                                                      ( ■■■■■■■■■■■■■■■■■■■ )\n");
    Sleep(200);
    printf("                                                                      ( ■■■■■■■■■■■■■■■■■■■ )\n");
    Sleep(200);
    printf("                                                                      ( ■■■■■■■■■■■■■■■■■■■ )\n");
    Sleep(200);
    printf("                                                                      ( ■■■■■■■■■■■■■■■■■■■ )\n");
    Sleep(200);
    printf("                                                                      ( ■■■■■■■■■■■■■■■■■■■ )\n");
    Sleep(200);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_BLUE);
    printf("                                                  ( ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■ )\n");
    Sleep(200);
    printf("                                                  ( ■■■■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_RED );
    printf("■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_BLUE);
    printf("■■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_RED );
    printf("■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_BLUE);
    printf("■■■■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_RED );
    printf("■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_BLUE);
    printf("■■■■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_RED );
    printf("■■■■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_BLUE);
    printf("■■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_RED );
    printf("■■■■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_BLUE);
    printf("■■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_RED );
    printf("■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_BLUE);
    printf("■■■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_RED );
    printf("■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_BLUE);
    printf("■■■■■ )\n");
    Sleep(200);
    printf("                                                  ( ■■■■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_RED );
    printf("■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_BLUE);
    printf("■■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_RED );
    printf("■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_BLUE);
    printf("■■■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_RED );
    printf("■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_BLUE);
    printf("■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_RED );
    printf("■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_BLUE);
    printf("■■■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_RED );
    printf("■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_BLUE);
    printf("■■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_RED );
    printf("■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_BLUE);
    printf("■■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_RED );
    printf("■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_BLUE);
    printf("■■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_RED );
    printf("■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_BLUE);
    printf("■■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_RED );
    printf("■■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_BLUE);
    printf("■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_RED );
    printf("■■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_BLUE);
    printf("■■■■■ )\n");
    Sleep(200);
    printf("                                                  ( ■■■■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_RED );
    printf("■■■■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_BLUE);
    printf("■■■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_RED );
    printf("■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_BLUE);
    printf("■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_RED );
    printf("■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_BLUE);
    printf("■■■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_RED );
    printf("■■■■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_BLUE);
    printf("■■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_RED );
    printf("■■■■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_BLUE);
    printf("■■■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_RED );
    printf("■■■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_BLUE);
    printf("■■■■■■ )\n");
    Sleep(200);
    printf("                                                  ( ■■■■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_RED );
    printf("■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_BLUE);
    printf("■■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_RED );
    printf("■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_BLUE);
    printf("■■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_RED );
    printf("■■■■■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_BLUE);
    printf("■■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_RED );
    printf("■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_BLUE);
    printf("■■■■■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_RED );
    printf("■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_BLUE);
    printf("■■■■■■■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_RED );
    printf("■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_BLUE);
    printf("■■■■■■■ )\n");
    Sleep(200);
    printf("                                                  ( ■■■■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_RED );
    printf("■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_BLUE);
    printf("■■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_RED );
    printf("■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_BLUE);
    printf("■■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_RED );
    printf("■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_BLUE);
    printf("■■■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_RED );
    printf("■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_BLUE);
    printf("■■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_RED );
    printf("■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_BLUE);
    printf("■■■■■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_RED );
    printf("■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_BLUE);
    printf("■■■■■■■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_RED );
    printf("■");
    Sleep(100);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_BLUE);
    printf("■■■■■■■ )\n");
    Sleep(200);
    printf("                                                  ( ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■ )\n");
    Sleep(200);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("                           ( ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■ )\n");
    Sleep(200);
    printf("                         ( ■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■■■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■■■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■■■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■■■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■ )\n");
    Sleep(200);
    printf("                       ( ■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN );
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN );
    printf("■■■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN | FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN );
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN  |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN );
    printf("■■■ )\n");
    Sleep(200);
    printf("                     ( ■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■■■ )\n");
    Sleep(200);
    printf("                   ( ■■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■■■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■■■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■■■■ )\n");
    Sleep(200);
    printf("                 ( ■■■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■■■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■■■■■ )\n");
    Sleep(200);
    printf("               ( ■■■■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■■■■■■ )\n");
    Sleep(200);
    printf("             ( ■■■■■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■■■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■■■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN |FOREGROUND_RED);
    printf("■");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY |FOREGROUND_GREEN);
    printf("■■■■■■■■■ )\n");
    Sleep(200);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_RED);
    printf("                                                                        ■■\n");
    Sleep(200);
    printf("                                                                          ■■    ■■■■■■■■\n");
    Sleep(200);
    printf("                                                                                  ■■■■■■■■        ■■        ■■        ■■\n");
    Sleep(200);
    printf("                                                                      ■■■■■  ■■        ■■        ■■        ■■        ■■\n");
    Sleep(200);
    printf("                                                                      ■■■■■  ■■        ■■        ■■        ■■        ■■\n");
    Sleep(200);
    printf("                                                                            ■■  ■■        ■■        ■■        ■■        ■■\n");
    Sleep(200);
    printf("                                                                          ■■    ■■■■■■■■        ■■        ■■        ■■\n");
    Sleep(200);
    printf("                                                                          ■■    ■■■■■■■■        ■■        ■■        ■■\n");
    Sleep(200);
    printf("                                                                        ■■■■    ■■  ■■            ■■        ■■        ■■\n");
    Sleep(200);
    printf("                                                                      ■■■■■■  ■■  ■■\n");
    Sleep(200);
    printf("                                                                          ■■  ■  ■■  ■■\n");
    Sleep(200);
    printf("                                                                          ■■      ■■  ■■  ■■      ■■        ■■        ■■\n");
    Sleep(200);
    printf("                                                                          ■■    ■■    ■■  ■■      ■■        ■■        ■■\n");
    Sleep(200);
    printf("                                                                          ■■■■■      ■■■■■\n");
    Sleep(200);
    printf("                                                                          ■■  ■          ■■■\n");
    Sleep(200);
    Sleep(1000);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_BLUE);
    printf("\n                                                                                        ■■");
    Sleep(150);
    printf("                                    ■■\n");
    Sleep(200);
    printf("                                                              ■■");
    Sleep(150);
    printf("                      ■■");
    Sleep(150);
    printf("        ■■                        ■■\n");
    Sleep(200);
    printf("                                                              ■■");
    Sleep(150);
    printf("                      ■■");
    Sleep(150);
    printf("        ■■");
    Sleep(150);
    printf("                        ■■\n");
    Sleep(200);
    printf("                                                              ■■");
    Sleep(150);
    printf("                    ■■");
    Sleep(150);
    printf("          ■■");
    Sleep(150);
    printf("                        ■■\n");
    Sleep(200);
    printf("                                                      ■");
    Sleep(50);
    printf("      ■■");
    Sleep(50);
    printf("      ■");
    Sleep(50);
    printf("            ■■");
    Sleep(50);
    printf("  ■■");
    Sleep(50);
    printf("    ■■");
    Sleep(50);
    printf("    ■■");
    Sleep(50);
    printf("    ■■");
    Sleep(50);
    printf("■■");
    Sleep(50);
    printf("■■");
    printf("■■");
    Sleep(50);
    printf("■■");
    Sleep(50);
    printf("■■");
    Sleep(50);
    printf("■■");
    Sleep(50);
    printf("■\n");
    Sleep(200);
    printf("                                                      ■");
    Sleep(50);
    printf("      ■■");
    Sleep(50);
    printf("      ■■");
    Sleep(50);
    printf("        ■■■");
    Sleep(50);
    printf("  ■■");
    Sleep(50);
    printf("    ■■");
    Sleep(50);
    printf("    ■■");
    Sleep(50);
    printf("    ■■");
    Sleep(50);
    printf("■■");
    Sleep(50);
    printf("■■");
    Sleep(50);
    printf("■■");
    Sleep(50);
    printf("■■");
    Sleep(50);
    printf("■■");
    Sleep(50);
    printf("■■■\n");
    Sleep(200);
    printf("                                                    ■■");
    Sleep(150);
    printf("      ■■");
    Sleep(150);
    printf("      ■■");
    Sleep(150);
    printf("      ■■");
    Sleep(150);
    printf("■■");
    Sleep(150);
    printf("  ■■");
    Sleep(150);
    printf("    ■■");
    Sleep(150);
    printf("    ■■");
    Sleep(150);
    printf("              ■■");
    Sleep(150);
    printf("      ■■\n");
    Sleep(200);
    printf("                                                    ■■");
    Sleep(100);
    printf("      ■■");
    Sleep(100);
    printf("        ■■");
    Sleep(100);
    printf("    ■");
    Sleep(100);
    printf("  ■■");
    Sleep(100);
    printf("  ■■");
    Sleep(100);
    printf("    ■■");
    Sleep(100);
    printf("    ■■");
    Sleep(100);
    printf("              ■■");
    Sleep(100);
    printf("      ■■\n");
    Sleep(200);
    printf("                                                  ■■");
    Sleep(100);
    printf("        ■■");
    Sleep(100);
    printf("        ■■");
    Sleep(100);
    printf("        ■■");
    Sleep(100);
    printf("  ■■");
    Sleep(100);
    printf("    ■■");
    Sleep(100);
    printf("    ■■");
    Sleep(100);
    printf("            ■■");
    Sleep(100);
    printf("      ■■\n");
    Sleep(200);
    printf("                                                  ■■");
    Sleep(50);
    printf("        ■■");
    Sleep(50);
    printf("          ■■");
    Sleep(50);
    printf("      ■■");
    Sleep(50);
    printf("  ■■");
    Sleep(50);
    printf("    ■■");
    Sleep(50);
    printf("    ■■");
    Sleep(50);
    printf("            ■■■");
    Sleep(50);
    printf("    ■■\n");
    Sleep(200);
    printf("                                                  ■");
    Sleep(50);
    printf("          ■■");
    Sleep(50);
    printf("          ■■");
    Sleep(50);
    printf("      ■■");
    Sleep(50);
    printf("  ■■");
    Sleep(50);
    printf("    ■■");
    Sleep(50);
    printf("    ■■");
    Sleep(50);
    printf("                ■■■■\n");
    Sleep(200);
    printf("                                                              ■■");
    Sleep(10);
    printf("                    ■■");
    Sleep(10);
    printf("  ■■");
    Sleep(10);
    printf("    ■■");
    Sleep(10);
    printf("    ■■");
    Sleep(10);
    printf("                  ■■■■\n");
    Sleep(200);
    printf("                                                              ■■");
    Sleep(10);
    printf("                    ■■");
    Sleep(10);
    printf("  ■■");
    Sleep(10);
    printf("■■");
    Sleep(10);
    printf("■■");
    Sleep(10);
    printf("■■");
    Sleep(10);
    printf("■■");
    Sleep(10);
    printf("              ■■■");
    Sleep(10);
    printf("    ■■■\n");
    Sleep(200);
    printf("                                                          ■■■■");
    Sleep(10);
    printf("                    ■■");
    Sleep(10);
    printf("  ■■");
    Sleep(10);
    printf("■■");
    Sleep(10);
    printf("■■");
    Sleep(10);
    printf("■■");
    Sleep(10);
    printf("■■");
    Sleep(10);
    printf("          ■■■");
    Sleep(10);
    printf("            ■■\n");
    Sleep(200);
    printf("                                                          ■■■");
    Sleep(10);
    printf("                      ■■");
    Sleep(10);
    printf("                            ■■■");
    Sleep(10);
    printf("                  ■\n");
    Sleep(200);
    Sleep(500);
    printf("\n");
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_RED);
    printf("                                                     ■■               ■■■■■■■■■■         ■■        ■■                          ■■■■\n");
    Sleep(200);
    printf("                                           ■■      ■■               ■■■■■■■■■■         ■■        ■■              ■■■■■■■■■■\n");
    Sleep(200);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_RED | FOREGROUND_GREEN);
    printf("                                           ■■      ■■               ■■            ■■         ■■  ■■■■■■■■        ■■■■■\n");
    Sleep(200);
    printf("                                           ■■      ■■               ■■            ■■         ■■  ■■■■■■■■        ■■\n");
    Sleep(200);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE);
    printf("                                         ■■■■■■■■■■■■       ■■            ■■     ■  ■■■      ■■  ■■        ■■      ■■\n");
    Sleep(200);
    printf("                                         ■■■■■■■■■■■■       ■■            ■■     ■  ■■■      ■■  ■■      ■■        ■■\n");
    Sleep(200);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_GREEN);
    printf("                                       ■■          ■■               ■■■■■■■■■■   ■■  ■■        ■■  ■■      ■■■■■■■■■■■■■\n");
    Sleep(200);
    printf("                                                     ■■               ■■■■■■■■■■   ■    ■■  ■■■■■■■■■    ■■■■■■■■■■■■■\n");
    Sleep(200);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_GREEN | FOREGROUND_BLUE);
    printf("                                             ■■■■■■■■■         ■■            ■■         ■■  ■■■■■■■■■                ■■\n");
    Sleep(200);
    printf("                                             ■■■■■■■■■         ■■            ■■         ■■        ■■                  ■    ■■  ■\n");
    Sleep(200);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_BLUE);
    printf("                                                     ■■               ■■            ■■         ■■      ■■■■              ■■    ■■  ■■\n");
    Sleep(200);
    printf("                                                     ■■               ■■            ■■         ■■    ■■    ■■          ■■      ■■    ■■\n");
    Sleep(200);
    SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_RED | FOREGROUND_BLUE);
    printf("                                                     ■■               ■■■■■■■■■■         ■■  ■■        ■■      ■■        ■■      ■■\n");
    Sleep(200);
    printf("                                        ■■■■■■■■■■■■■■    ■■■■■■■■■■         ■■■■            ■■            ■■■■        ■\n");
    Sleep(200);
    printf("                                        ■■■■■■■■■■■■■■    ■■            ■■         ■■                                  ■■\n");
    Sleep(200);
    system("pause");
    return 0;
}
</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>437</wp:post_id>
		<wp:post_date><![CDATA[2019-07-20 18:43:20]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-07-20 10:43:20]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[happy]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="sundry"><![CDATA[杂项]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>POJ-3494-Largest Submatrix of All 1’s-单调栈</title>
		<link>https://sdnuqp.cn/poj-3494-largest-submatrix-of-all-1s-%e5%8d%95%e8%b0%83%e6%a0%88/</link>
		<pubDate>Sat, 20 Jul 2019 12:44:43 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=439</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:code -->
<pre class="wp-block-code"><code>



#include &lt;cstdio>
#include &lt;iostream>
#include &lt;algorithm>
#include &lt;cstring>
#include &lt;stack>
//#include &lt;bits/stdc++.h>
using namespace std;

int n, m;
int h[2001];
int a[2001];
stack&lt;int>st;

int main() {
    int z;
    int temp;
    int maxx = 0;
    memset(h,0,sizeof h);
    while(scanf("%d %d", &amp;n, &amp;m)!=EOF) {
        maxx = 0;
        for(int i = 1 ; i &lt;= n ; i++) {
            for(int j = 1; j &lt;= m ; j++) {
                scanf("%d", &amp;z);
                if(z == 1) {
                    h[j] = h[j] + 1;
                } else {
                    h[j] = 0;
                }
                a[j] = h[j];
            }
            a[n+1] = -1;
            for(int j = 1; j &lt;= m+1 ; j++) {
                if(st.empty() || a[st.top()] &lt;= a[j] ) {
                    st.push(j);
                } else {
                    while(!st.empty() &amp;&amp; a[st.top()] > a[j]) {
                        temp = st.top();
                        maxx = max(maxx, (j - temp) * a[temp]);
                        st.pop();
                    }
                    st.push(temp);
                    a[temp] = a[j];
                }
            }
        }
        printf("%d\n", maxx);
    }
    return 0;
}


/*
2 2
0 0
0 0
4 4
0 0 0 0
0 1 1 0
0 1 1 0
0 0 0 0
*/
</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>439</wp:post_id>
		<wp:post_date><![CDATA[2019-07-20 20:44:43]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-07-20 12:44:43]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[poj-3494-largest-submatrix-of-all-1s-%e5%8d%95%e8%b0%83%e6%a0%88]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84__%e5%8d%95%e8%b0%83%e6%a0%88"><![CDATA[数据结构__单调栈]]></category>
		<category domain="category" nicename="tijie"><![CDATA[题解]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>POJ-2559-Largest Rectangle in a Histogram-单调栈</title>
		<link>https://sdnuqp.cn/poj-2559-largest-rectangle-in-a-histogram-%e5%8d%95%e8%b0%83%e6%a0%88/</link>
		<pubDate>Sat, 20 Jul 2019 12:46:45 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=441</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:code -->
<pre class="wp-block-code"><code>



#include &lt;iostream>
#include &lt;cstdio>
#include &lt;algorithm>
#include &lt;cstring>
#include &lt;stack>
using namespace std;
typedef long long ll;

ll n;
struct node {
    ll x;
    ll sum;
};

stack &lt;node> st;

int main() {
    node q;
    ll z;
    ll temp;
    ll S;
    ll maxx;
    while(scanf("%I64d", &amp;n) != EOF &amp;&amp; n ) {
        maxx = 0;
        for(int i = 1; i &lt;= n ; i ++) {
            scanf("%I64d", &amp;q.x);
            q.sum = 1;
            temp = 0;
            if(st.empty()) {
                st.push(q);
            } else if(st.top().x >= q.x){
                while(!st.empty() &amp;&amp; (st.top()).x >= q.x) {
                    (st.top()).sum += temp;
                    S = (st.top()).x * (st.top()).sum;
                    maxx = max(maxx, S);
                    temp = (st.top()).sum;
                    st.pop();
                }
                q.sum += temp;
                st.push(q);
            }
            else{
                st.push(q);
            }
        }
        temp = 0;
        while(!st.empty()) {
           (st.top()).sum += temp;
            S = (st.top()).sum * (st.top()).x ;
            maxx = max(maxx, S);
            temp = (st.top()).sum;
            st.pop();
        }
        printf("%I64d\n",maxx);
    }
    return 0;
}</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>441</wp:post_id>
		<wp:post_date><![CDATA[2019-07-20 20:46:45]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-07-20 12:46:45]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[poj-2559-largest-rectangle-in-a-histogram-%e5%8d%95%e8%b0%83%e6%a0%88]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84__%e5%8d%95%e8%b0%83%e6%a0%88"><![CDATA[数据结构__单调栈]]></category>
		<category domain="category" nicename="tijie"><![CDATA[题解]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>UVA-10881-Piotr&#039;s Ants</title>
		<link>https://sdnuqp.cn/uva-10881-piotrs-ants/</link>
		<pubDate>Tue, 23 Jul 2019 03:00:32 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=445</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>这个题是真的绕，我绕来绕去，顺序排来排去，不会。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>训练指南第一个题，算是序言中的例题，还没进入第一章，就已经阵亡了。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>中间关键几行是学的别人的，写的简单，却很晦涩。</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>

#include &lt;bits/stdc++.h>
using namespace std;

struct node {
    int d;//id
    int s;//位置
    int t;//方向
}start[10010],End[10010];

int order[10010];
int az[10010];

bool cmp(struct node x, struct node y) {
    return x.s &lt; y.s;
}

bool cmp2(struct node x, struct node y) {
    return x.d &lt; y.d;
}

int main() {
    int t;
    int L, T, n;
    char c;
    scanf("%d", &amp;t);
    for (int tt = 1; tt &lt;= t; tt++) {
        scanf("%d %d %d", &amp;L, &amp;T, &amp;n);
        for (int i = 1; i &lt;= n; i++) {
            scanf("%d %c",&amp;start[i].s,&amp;c);
            End[i].t = start[i].t = c == 'L' ? -1 : 1;
            start[i].d = i;
            End[i].d = 0;
            End[i].s = start[i].s + T * start[i].t;
        }
////////////
        sort(start + 1 ,start + 1 +n,cmp);
        for(int i =1 ; i &lt;= n ; i++){
            order[start[i].d] = i;
        }
        sort(End+1,End+1+n,cmp);
        for(int i = 1; i &lt;= n ; i++){
            if(End[i].s == End[i+1].s){
                End[i].t = End[i+1].t = 0;
            }
        }
//////////////
        printf("Case #%d:\n",tt);
        for (int j = 1; j &lt;= n; j ++) {
            int i = order[j];
            if (End[i].s &lt; 0 || End[i].s > L) {
                printf("Fell off\n");
            }
            else {
                printf("%d ",End[i].s);
                int x = End[i].t;
                if (x == -1) {
                    printf("L\n");
                }
                else if(x == 1) {
                    printf("R\n");
                }
                else {
                    printf("Turning\n");
                }
            }
        }
    }

    return 0;
}

/*

2
10 1 4
1 R
5 R
3 L
10 R
10 2 3
4 R
5 L
8 R


*/
</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>445</wp:post_id>
		<wp:post_date><![CDATA[2019-07-23 11:00:32]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-07-23 03:00:32]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[uva-10881-piotrs-ants]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="uva"><![CDATA[OJ__UVA]]></category>
		<category domain="category" nicename="%e7%ac%ac%e4%b8%80%e7%ab%a0%e6%80%9d%e7%bb%b4"><![CDATA[第一章思维]]></category>
		<category domain="category" nicename="%e8%ae%ad%e7%bb%83%e6%8c%87%e5%8d%97"><![CDATA[训练指南]]></category>
		<category domain="category" nicename="tijie"><![CDATA[题解]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>排列生成算法</title>
		<link>https://sdnuqp.cn/%e7%94%9f%e6%88%903%e7%a7%8d%e6%8e%92%e5%88%97/</link>
		<pubDate>Fri, 26 Jul 2019 02:24:17 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=448</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>第一种是生成1 ~ n的全排列;</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>第二种适用于无重复数组</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>第三种适用于可重复数组</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>第四种是 解答树</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>第五种是 库函数（next_permutation()）(生成下一个排列)</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>刘汝佳大牛的代码，打下来当板子。</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>

#include &lt;bits/stdc++.h>
using namespace std;
const int maxn = 100 + 1;

int n;
int A[maxn];
int P[maxn];

void print_permutation(int n ,int* A ,int cur) {
    if (cur == n) {
        for (int i = 0; i &lt; n; i++) {
            printf("%d ",A[i]);
        }
        printf("\n");
    }
    else for (int i = 1; i &lt;= n; i++) {
        int ok = 1;
        for (int j = 0; j &lt; cur; j++) {
            if (A[j] == i) {
                ok = 0;
            }
        }
        if (ok) {
            A[cur] = i;
            print_permutation(n, A, cur + 1);
        }
    }
}

void print_permutation(int n ,int* A ,int cur) {
    if (cur == n) {
        for (int i = 0; i &lt; n; i++) {
            printf("%d ",A[i]);
        }
        printf("\n");
    }
    else for (int i = 1; i &lt;= n; i++) {
        int ok = 1;
        for (int j = 0; j &lt; cur; j++) {
            if (A[j] == P[i]) {
                ok = 0;
            }
        }
        if (ok) {
            A[cur] = P[i];
            print_permutation(n, A, cur + 1);
        }
    }
}


void print_permutation(int n ,int * P,int* A ,int cur) {
    if (cur == n) {
        for (int i = 0; i &lt; n; i++) {
            printf("%d ",A[i]);
        }
        printf("\n");
    }
    else
        for (int i = 0; i &lt; n; i++) {
            if (!i || P[i] != P[i - 1]) {
                int c1 = 0, c2 = 0;
                for (int j = 0; j &lt; cur; j++) {
                    if (A[j] == P[i]) c1++;
                }
                for (int j = 0; j &lt; n; j++) {
                    if (P[i] == P[j]) c2++;
                }
                if (c1 &lt; c2) {
                    A[cur] = P[i];
                    print_permutation(n,P, A, cur+1);
                }
            }
        }
}

int main() {
    scanf("%d", &amp;n);
    for (int i = 0; i &lt; n; i++) {
        scanf("%d", &amp;P[i]);
    }
    sort(P, P + n); /// 用于3
    print_permutation(n,A,0);///用于1，2
    print_permutation(n,P,A,0);///用于3
    return 0;
}</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>至于解答树和next_permutation函数是什么怎么用，请看紫薯或：</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><a href="https://blog.csdn.net/flora715/article/details/80967551">https://blog.csdn.net/flora715/article/details/80967551</a></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>转载 解答树 code:</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>    #include &lt;string.h>
    #include &lt;iostream>
     
    using namespace std;
    const int N = 99999999;     //输入排序的个数的最大值
    int record[N];              //记录每次排序的序列
    int visited[N];             //标记节点是否被访问过
    int n;                      //输入节点的数目
    int totalSize = 0;
    void DFS(int start){
        if(start>=n){           //递归出口
            for(int i=0;i&lt;n;i++){
                cout&lt;&lt;record[i]&lt;&lt;" ";
            }
            totalSize++;
            cout&lt;&lt;endl;
            return;
        }
        for(int i=1;i&lt;=n;i++){      //深度遍历节点，并标记已经访问过的节点
            if(visited[i]==0){
                visited[i] = 1;
                record[start] = i;
                DFS(start+1);       //递归遍历
                visited[i] = 0;     //回退时标记回退的节点为未被访问节点
            }
        }
    }
     
    int main()
    {
        cin>>n;
        memset(visited,0,n);
        DFS(0);
        cout&lt;&lt;"totalSize = "&lt;&lt;totalSize&lt;&lt;endl;
        return 0;
    }
</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>448</wp:post_id>
		<wp:post_date><![CDATA[2019-07-26 10:24:17]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-07-26 02:24:17]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e7%94%9f%e6%88%903%e7%a7%8d%e6%8e%92%e5%88%97]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="algorithm"><![CDATA[算法]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>子集生成算法</title>
		<link>https://sdnuqp.cn/%e5%ad%90%e9%9b%86%e7%94%9f%e6%88%90%e7%ae%97%e6%b3%95/</link>
		<pubDate>Fri, 26 Jul 2019 03:17:23 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=453</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>1.增量构造法，递推，DFS</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>
/*

 子集生成算法
 1.增量构造法
 2.位向量法
 3.二进制法

*/


#include &lt;bits/stdc++.h>
using namespace std;
const int maxn = 100 + 1;

int n;
int A[maxn];

void print_subset(int n , int * A, int cur) {
    for (int i = 0; i &lt; cur; i++) {
        printf("%d ", A[i]);
    }
    printf("\n");
    int s = cur ? A[cur - 1] + 1 : 0;
    for (int i = s; i &lt; n; i++) {
        A[cur] = i;
        print_subset(n, A, cur + 1);
    }
}

int main() {
    scanf("%d", &amp;n);

    print_subset(n, A, 0);
    return 0;
}</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>2.位向量法 （递推，深搜）</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>
#include &lt;bits/stdc++.h>
using namespace std;
const int maxn = 100 + 1;

int n;
int A[maxn];

void print_subset(int n , int * A, int cur) {
    if (cur == n) {
        for (int i = 0; i &lt; cur; i++) {
            if (A[i]) printf("%d ", i);
        }
        printf("\n");
        return;
    }
    A[cur] = 1;
    print_subset(n, A, cur + 1);
    A[cur] = 0;
    print_subset(n, A, cur + 1);
}

int main() {
    scanf("%d", &amp;n);
    print_subset(n, A, 0);
    return 0;
}</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>3.二进制法</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>

#include &lt;bits/stdc++.h>
using namespace std;
const int maxn = 100 + 1;

int n;
int A[maxn];

void print_subset(int n ,int s) {
    for (int i = 0; i &lt; n; i++) {
        if (s &amp; (1 &lt;&lt; i)) printf("%d ",i);
    }
    printf("\n");
}

int main() {
    scanf("%d", &amp;n);
    for (int i = 1; i &lt; (1 &lt;&lt; n); i++) {
        print_subset(n, i);
    }
    return 0;
}</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>453</wp:post_id>
		<wp:post_date><![CDATA[2019-07-26 11:17:23]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-07-26 03:17:23]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%ad%90%e9%9b%86%e7%94%9f%e6%88%90%e7%ae%97%e6%b3%95]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="algorithm"><![CDATA[算法]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>欧几里得算法gcd</title>
		<link>https://sdnuqp.cn/%e6%ac%a7%e5%87%a0%e9%87%8c%e5%be%97%e7%ae%97%e6%b3%95gcd/</link>
		<pubDate>Fri, 26 Jul 2019 07:16:05 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=458</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:code -->
<pre class="wp-block-code"><code>
//辗转相除法

#include &lt;bits/stdc++.h>
using namespace std;

int n, m;

int gcd(int a, int b) {
    printf("%d %d\n", a, b);
    return b == 0 ? a : gcd(b, a % b);
}

int main(){
    scanf("%d %d", &amp;n, &amp;m);
    printf("%d ", gcd(n, m));
    return 0;
}

/*
输入：
10 6

输出：
10 6
6 4
4 2
2 0
2
*/</code></pre>
<!-- /wp:code -->

<!-- wp:code -->
<pre class="wp-block-code"><code>求证：gcd(n,m) == gcd(m,b);
设：
1.gcd(n,m)表示n和m的最大公约数
2.c = gcd(n,m);
3.n = m*a + b;
4.d = gcd(m,b);
证：
∵c = gcd(n,m)
∴c|n ,c|m
∵c|m
∴c|m*a
∵c|n
∴c|(m*a+b)
∴c|b;
∴c|d,c是m,b的一个约数

∵d = gcd(m,b)
∴d|m , d|b;
∴d|m*a
∴d|(m*a+b)
∴d|n
又d|m
∴d|c,d是n,m的一个约数

综上所述
d|c且c|d
故d == c
即gcd(n,m) == gcd(m,n%m);</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>458</wp:post_id>
		<wp:post_date><![CDATA[2019-07-26 15:16:05]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-07-26 07:16:05]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%ac%a7%e5%87%a0%e9%87%8c%e5%be%97%e7%ae%97%e6%b3%95gcd]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论___GCD/EXGCD]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>唯一分解定理（算术基本定理）</title>
		<link>https://sdnuqp.cn/%e5%94%af%e4%b8%80%e5%88%86%e8%a7%a3%e5%ae%9a%e7%90%86%ef%bc%88%e7%ae%97%e6%9c%af%e5%9f%ba%e6%9c%ac%e5%ae%9a%e7%90%86%ef%bc%89/</link>
		<pubDate>Fri, 26 Jul 2019 08:30:22 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=461</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:code -->
<pre class="wp-block-code"><code>唯一分解定理（算术基本定理）
证明：反证法，详见百度百科

1.一个大于1的整数n，唯一分解式：n = p1^a1 * p2^a2 *...*pn^an
2.正因数个数：sum = (1+a1)(1+a2)...(1+an)
3.正因数之和：ans = (1 + p1^1 + p1^2 +...+ p1^a1)(1 + p2^1 +...+p2^a2)...(1 + pn^1 +...+ pn^an)
4.gcd(a,b)*lcm(a,b) = a*b;(反用时，注意a*b是否会溢出！)





code:
#include &lt;bits/stdc++.h>
using namespace std;

int n;
int a[1010];
int vis[1010];

int main(){
    int n;
    scanf("%d",&amp;n);
    int cnt = 0;
    for(int i = 2 ; i &lt;= n ; i++){
        if(n%i == 0)
            vis[cnt] = i;
        while(n%i == 0){
            a[cnt]++;
        }
        cnt++;
    }
    for(int i = 0 ; i &lt; cnt-1 ; i++){
        printf("%d^%d * ",vis[i],a[i]);
    }
    printf("%d^%d\n",vis[i],a[i]);
    return 0;
}</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>这个代码，虽然暴力，但又很巧妙；</p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>461</wp:post_id>
		<wp:post_date><![CDATA[2019-07-26 16:30:22]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-07-26 08:30:22]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%94%af%e4%b8%80%e5%88%86%e8%a7%a3%e5%ae%9a%e7%90%86%ef%bc%88%e7%ae%97%e6%9c%af%e5%9f%ba%e6%9c%ac%e5%ae%9a%e7%90%86%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="unique-decomposition-theorem"><![CDATA[数论___唯一分解定理]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>POJ-1451-T9-字典树+DFS</title>
		<link>https://sdnuqp.cn/poj-1451-t9-%e5%ad%97%e5%85%b8%e6%a0%91dfs/</link>
		<pubDate>Mon, 05 Aug 2019 12:42:56 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=467</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>漏了两句话：<br>
More precisely, with every character typed, the phone will show the most probable combination of characters it has found up to that point.<br>
Let us assume that the phone knows about the words "idea" and "hello", with "idea" occurring more often. Pressing the keys 4, 3, 5, 5, and 6, one after the other,<br>
the phone offers you "i", "id", then switches to "hel", "hell", and finally shows "hello".</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>两个不同单词，相同前缀的概率是可以相加的，我忘记考虑了O.o</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>新算法：<br> node{<br>     int flag;<br>     node* next[26];<br> }<br> 重新建树，next，26字母，节点flag += m(当前字符串的频率)。<br> 每次DFS搜三个next方向,比较前缀频率时，比较的是最后结尾的flag值(与中间字符的flag没关系),然后输出。<br> 我没有再去实现，思路肯定是正确的，这题并不难。。。我去找了一篇和我思路相同的代码(好难找O.o)，贴在下面了。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>My WA code:</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>

#include &lt;cstdio>
#include &lt;iostream>
#include &lt;algorithm>
#include &lt;cstring>
#include &lt;map>
using namespace std;

map&lt;char, int >mp;

struct node {
    int flag;
    char s[21];
    node* next[10];
    node() {
        flag = 0;
        memset(s, '\0', sizeof s);
        memset(next, NULL, sizeof next);
    }
};

node root;

void Insert(char *word ,int index) {
    node* p = &root;
    for (int i = 0; word[i]; ++i) {
        if (p->next[mp[word[i]]] == NULL)
            p->next[mp[word[i]]] = new node;
        p = p->next[mp[word[i]]];
        if (p->flag &lt;= index) {
            p->flag = index;
            strncpy(p->s, word,i+1);
        }
    }
}

void Find(char *w) {
    node* p = &root;
    for (int i = 0; w[i+1]; ++i) {
        p = p->next[w[i] - '0'];
        if (p == NULL) {
            for(int j = i ; w[j+1] ; ++j)
                printf("MANUALLY\n");
            return;
        }
        printf("%s\n", p->s);
    }
}

int main() {
    freopen("input.txt", "r", stdin);
    freopen("output.txt", "w", stdout);
    int T;
    int n, m;
    mp['a'] = mp['b'] = mp['c'] = 2;
    mp['d'] = mp['e'] = mp['f'] = 3;
    mp['g'] = mp['h'] = mp['i'] = 4;
    mp['j'] = mp['k'] = mp['l'] = 5;
    mp['m'] = mp['n'] = mp['o'] = 6;
    mp['p'] = mp['q'] = mp['r'] = mp['s'] = 7;
    mp['t'] = mp['u'] = mp['v'] = 8;
    mp['w'] = mp['x'] = mp['y'] = mp['z'] = 9;

    char word[21];
    scanf("%d",&amp;T);
    for (int i = 1; i &lt;= T; ++i) {
        scanf("%d", &amp;n);
        for (int j = 1; j &lt;= n; ++j) {
            scanf("%s %d", word, &amp;m);
            Insert(word,m);
        }

        scanf("%d", &amp;m);
        printf("Scenario #%d:\n", i);
        for (int j = 1; j &lt;= m; ++j) {
            char w[21] = {'\0'};
            scanf("%s",w);
            Find(w);
            printf("\n");
        }
        printf("\n");
        root = node();
    }
    return 0;
}
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>链接：https://www.cnblogs.com/183zyz/archive/2011/04/29/2033034.html</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Others AC code:</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code># include&lt;stdio.h>
# include&lt;string.h>
# include&lt;stdlib.h>
# define PI 110
# define MAX 26
struct Trie{
    int num;
    struct Trie *next[MAX];
};
int ans,dir[11]={0,0,0,3,6,9,12,15,19,22,26},len,k,max[PI];//记录手机上的每个数字所表示的字母
char st[PI],map[PI][PI],adj[PI];
Trie *NewTrie()
{
    int i;
    Trie *temp= new Trie;
    temp->num=1;
    for(i=0;i&lt;MAX;i++)
        temp->next[i]=NULL;
    return temp;
}//初始化。。
void Insert(Trie *p,char s[])
{
    int i,len1;
    Trie *temp=p;
    len1=strlen(s);
    for(i=0;i&lt;len1;i++)
    {
        if(temp->next[s[i]-'a']==NULL) {temp->next[s[i]-'a']=NewTrie();temp->next[s[i]-'a']->num+=(ans-1);}
        else temp->next[s[i]-'a']->num+=ans;
        temp=temp->next[s[i]-'a'];
    }
}//插入
void updata(Trie *p,int step)
{
    Trie *temp=p;
    int begin,end,j;
        begin=dir[st[step]-'0'];
        end=dir[st[step]-'0'+1];
        for(j=begin;j&lt;end;j++)
        {
            if(temp->next[j]==NULL) continue;
            k++;
            adj[k]=j+'a';
            if(temp->next[j]->num > max[step])
            {
                max[step] = temp->next[j]->num;
                adj[k+1]=0;
                strcpy(map[step],adj);
            }
            if(step!=len-1) updata(temp->next[j],step+1);
            k--;
        }
}//深搜一遍
int main()
{
    Trie *p;
    int i,j,n,m,ncase,t;
    char str[105];
    scanf("%d",&amp;ncase);
    for(t=1;t&lt;=ncase;t++)
    {
        scanf("%d",&amp;n);
        p=NewTrie();
        while(n--)
        {
            scanf("%s %d",str,&amp;ans);
            Insert(p,str);
        }
        scanf("%d",&amp;m);
        printf("Scenario #%d:\n",t);
        while(m--)
        {
            scanf("%s",st);
            len=strlen(st);
            len--;
            k=-1;
            memset(max,-1,sizeof(max));
            updata(p,0);
            for(i=0;i&lt;len;i++)
            {
                if(max[i]!=-1) printf("%s\n",map[i]);
                else break;
            }
            for(j=i;j&lt;len;j++)
                printf("MANUALLY\n");
            printf("\n");
        }
        printf("\n");
    }
    return 0;
}</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>467</wp:post_id>
		<wp:post_date><![CDATA[2019-08-05 20:42:56]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-08-05 12:42:56]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[poj-1451-t9-%e5%ad%97%e5%85%b8%e6%a0%91dfs]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="trie"><![CDATA[字符串__Trie字典树]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>HDU-1251-统计难题-Trie查前缀</title>
		<link>https://sdnuqp.cn/hdu-1251-%e7%bb%9f%e8%ae%a1%e9%9a%be%e9%a2%98-trie%e6%9f%a5%e5%89%8d%e7%bc%80/</link>
		<pubDate>Mon, 05 Aug 2019 12:45:53 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=469</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>经典入门题</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>AC node:</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code># include&lt;stdio.h>
# include&lt;string.h>
# include&lt;stdlib.h>
# define PI 110
# define MAX 26
struct Trie{
    int num;
    struct Trie *next[MAX];
};
int ans,dir[11]={0,0,0,3,6,9,12,15,19,22,26},len,k,max[PI];//记录手机上的每个数字所表示的字母
char st[PI],map[PI][PI],adj[PI];
Trie *NewTrie()
{
    int i;
    Trie *temp= new Trie;
    temp->num=1;
    for(i=0;i&lt;MAX;i++)
        temp->next[i]=NULL;
    return temp;
}//初始化。。
void Insert(Trie *p,char s[])
{
    int i,len1;
    Trie *temp=p;
    len1=strlen(s);
    for(i=0;i&lt;len1;i++)
    {
        if(temp->next[s[i]-'a']==NULL) {temp->next[s[i]-'a']=NewTrie();temp->next[s[i]-'a']->num+=(ans-1);}
        else temp->next[s[i]-'a']->num+=ans;
        temp=temp->next[s[i]-'a'];
    }
}//插入
void updata(Trie *p,int step)
{
    Trie *temp=p;
    int begin,end,j;
        begin=dir[st[step]-'0'];
        end=dir[st[step]-'0'+1];
        for(j=begin;j&lt;end;j++)
        {
            if(temp->next[j]==NULL) continue;
            k++;
            adj[k]=j+'a';
            if(temp->next[j]->num > max[step])
            {
                max[step] = temp->next[j]->num;
                adj[k+1]=0;
                strcpy(map[step],adj);
            }
            if(step!=len-1) updata(temp->next[j],step+1);
            k--;
        }
}//深搜一遍
int main()
{
    Trie *p;
    int i,j,n,m,ncase,t;
    char str[105];
    scanf("%d",&amp;ncase);
    for(t=1;t&lt;=ncase;t++)
    {
        scanf("%d",&amp;n);
        p=NewTrie();
        while(n--)
        {
            scanf("%s %d",str,&amp;ans);
            Insert(p,str);
        }
        scanf("%d",&amp;m);
        printf("Scenario #%d:\n",t);
        while(m--)
        {
            scanf("%s",st);
            len=strlen(st);
            len--;
            k=-1;
            memset(max,-1,sizeof(max));
            updata(p,0);
            for(i=0;i&lt;len;i++)
            {
                if(max[i]!=-1) printf("%s\n",map[i]);
                else break;
            }
            for(j=i;j&lt;len;j++)
                printf("MANUALLY\n");
            printf("\n");
        }
        printf("\n");
    }
    return 0;
}</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>469</wp:post_id>
		<wp:post_date><![CDATA[2019-08-05 20:45:53]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-08-05 12:45:53]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu-1251-%e7%bb%9f%e8%ae%a1%e9%9a%be%e9%a2%98-trie%e6%9f%a5%e5%89%8d%e7%bc%80]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="trie"><![CDATA[字符串__Trie字典树]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>HDU-1305-Immediate Decodability-Trie字典树动态建树</title>
		<link>https://sdnuqp.cn/hdu-1305-immediate-decodability-trie%e5%ad%97%e5%85%b8%e6%a0%91%e5%8a%a8%e6%80%81%e5%bb%ba%e6%a0%91/</link>
		<pubDate>Mon, 05 Aug 2019 12:48:14 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=471</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>入门级题目，这个题和POJ-1056是一摸一样的，but，测试样例却不一样，这个题你只能动态建树，不然会MLE，而那个题你只能静态建树，不然会TLE！！！！！注意！！！（对有的题来说,不删除指针也会TLE，虽然这个不会，但我懒。大部分时候都不写。。O.o）</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>AC code :</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>


#include &lt;cstdio>
#include &lt;iostream>
using namespace std;

int fl;

struct Trie {
    int flag;
    Trie* next[2];
    Trie() {
        flag = 0;
        next[0] = next[1] = NULL;
    }
};

Trie* root = new Trie;

void Insert(char word[]) {
    Trie * p = root;
    for (int i = 0; word[i]; i++) {
        if (p->next[word[i] - '0'] == NULL)
            p->next[word[i] - '0'] = new Trie;
        if (p->flag == 1) {
            fl = 1;
        }
        p = p->next[word[i] - '0'];
    }
    p->flag = 1;
}

int main() {
    char word[20];
    int cnt = 1;
    while (scanf("%s", word) != EOF) {
        if(word[0] == '9') {
            root->next[0] = root->next[1] = NULL;
            root->flag = 0;
            printf("Set %d is", cnt);
            printf(fl ? " not " : " ");
            printf("immediately decodable\n");
            cnt++;
            fl = 0;
            continue;
        }
        Insert(word);
    }
    return 0;
}</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>471</wp:post_id>
		<wp:post_date><![CDATA[2019-08-05 20:48:14]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-08-05 12:48:14]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu-1305-immediate-decodability-trie%e5%ad%97%e5%85%b8%e6%a0%91%e5%8a%a8%e6%80%81%e5%bb%ba%e6%a0%91]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="trie"><![CDATA[字符串__Trie字典树]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>HDU-1671/POJ-1630-Phone Lists-Trie字典树</title>
		<link>https://sdnuqp.cn/hdu-1671-poj-1630-phone-lists-trie%e5%ad%97%e5%85%b8%e6%a0%91/</link>
		<pubDate>Mon, 05 Aug 2019 12:55:45 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=475</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>这个题是考察字符串前缀的，有串是别的串的前缀就不行，入门级</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>AC code :</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>

#include &lt;cstdio>
using namespace std;

int sum;

struct node {
    int flag;
    node* next[10];
    node() {
        flag = 0;
        for (int i = 0; i &lt;= 9; ++i) {
            next[i] = NULL;
        }
    }
};

node* root;

void free_node(node* p) {
    for (int i = 0; i &lt;= 9; i++) {
        if (p->next[i] != NULL) {
            free_node(p->next[i]);
        }
    }
    delete p;
}

void Insert(char word[]) {
    node* p = root;
    int flag = 1;
    int fl = 0;
    for (int i = 0; word[i]; i++) {
        if (p->next[word[i] - '0'] == NULL) {
            p->next[word[i] - '0'] = new node;
            fl = 1;
        }
        if (p->flag == 1) {
            flag = 0;
        }
        p = p->next[word[i] - '0'];
    }
    if (flag == 0 || fl == 0)
        sum++;
    p->flag = 1;
}

int main() {
    int T;
    int n;
    char word[20];
    scanf("%d", &amp;T);
    while (T--) {
        root = new node;
        sum = 0;
        scanf("%d", &amp;n);
        for (int k = 1; k &lt;= n; k++) {
            scanf("%s", word);
            Insert(word);
        }
        printf(sum == 0 ? "YES\n" : "NO\n");
        free_node(root);
    }

    return 0;
}</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>475</wp:post_id>
		<wp:post_date><![CDATA[2019-08-05 20:55:45]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-08-05 12:55:45]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu-1671-poj-1630-phone-lists-trie%e5%ad%97%e5%85%b8%e6%a0%91]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="trie"><![CDATA[字符串__Trie字典树]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>HDU-2072-Trie字典树判重复串</title>
		<link>https://sdnuqp.cn/hdu-2072-trie%e5%ad%97%e5%85%b8%e6%a0%91%e5%88%a4%e9%87%8d%e5%a4%8d%e4%b8%b2/</link>
		<pubDate>Mon, 05 Aug 2019 12:57:21 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=478</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:code -->
<pre class="wp-block-code"><code>


#include &lt;cstdio>
#include &lt;iostream>
#include &lt;cstring>
#include &lt;sstream>
using namespace std;

int sum;

struct Trie {
    int flag; ///标记结尾
    Trie* next[26];
    Trie() {
        for (int i = 0; i &lt;= 25; i++) next[i] = NULL;
        flag = 0;
    }
};

char word[1010];
Trie * root;

void Insert(string word) {
    Trie* p = root;
    int flag = 1;
    for (int i = 0; word[i]; i++) {
        if (p->next[word[i] - 'a'] == NULL) {
            p->next[word[i] - 'a'] = new Trie;
        }
        p = p->next[word[i] - 'a'];
    }
    p->flag++;
    if (p->flag == 1)
        sum++;
}

int main() {
    string str, str1;
    while (getline(cin, str))
    {
        root = new Trie();
        sum = 0;
        if (str == "#")
            break;
        istringstream ss(str);
        while (ss >> str1)
        {
            Insert(str1);
        }
        cout &lt;&lt; sum &lt;&lt; endl;
    }
    return 0;
}</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>478</wp:post_id>
		<wp:post_date><![CDATA[2019-08-05 20:57:21]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-08-05 12:57:21]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu-2072-trie%e5%ad%97%e5%85%b8%e6%a0%91%e5%88%a4%e9%87%8d%e5%a4%8d%e4%b8%b2]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="trie"><![CDATA[字符串__Trie字典树]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>HDU-1247-Hat&#039;s word-Trie</title>
		<link>https://sdnuqp.cn/hdu-1247-hats-word-trie/</link>
		<pubDate>Mon, 05 Aug 2019 13:00:10 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=480</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:code -->
<pre class="wp-block-code"><code>#include &lt;bits/stdc++.h>
using namespace std;

char word[50010][50];

struct node {
    int flag;
    node* next[26];
    node() {
        flag = 0;
        for (int i = 0; i &lt;= 25; ++i)
            next[i] = NULL;
    }
};

node root;

void Insert(char *word) {
    node* p = &root;
    for (int i = 0; word[i]; i++) {
        if (p->next[word[i] - 'a'] == NULL)
            p->next[word[i] - 'a'] = new node;
        p = p->next[word[i] - 'a'];
    }
    p->flag = 1;
}

int fnd(char *word) {
    int flag = 0;
    node* p = &root;
    for (int i = 0; word[i]; i++) {
        if (p->next[word[i] - 'a'] != NULL)
            p = p->next[word[i] - 'a'];
        else {
            flag = 1;
            break;
        }
    }
    if (p->flag == 0)
        flag = 1;
    return flag ? 0 : 1;
}

int main() {
    int cnt = 1;
    while (scanf("%s", word[cnt]) != EOF) {
        Insert(word[cnt++]);
    }
    for (int i = 1; i &lt; cnt; ++i) {
        int len = strlen(word[i]);
        for (int j = 1; j &lt; len; ++j) {
            char wd1[50] = {'\0'};
            char wd2[50] = {'\0'};
            strncpy(wd1, word[i], j);
            strncpy(wd2, word[i] + j, len - j);
            //printf("%s %s\n", wd1, wd2);
            if (fnd(wd1) &amp;&amp; fnd(wd2)) {
                printf("%s\n",word[i]);
                break;
            }
        }
    }
    return 0;
}</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>480</wp:post_id>
		<wp:post_date><![CDATA[2019-08-05 21:00:10]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-08-05 13:00:10]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu-1247-hats-word-trie]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="trie"><![CDATA[字符串__Trie字典树]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>ZOJ-1109-Language of FatMouse-Trie字典树</title>
		<link>https://sdnuqp.cn/zoj-1109-language-of-fatmouse-trie%e5%ad%97%e5%85%b8%e6%a0%91/</link>
		<pubDate>Mon, 05 Aug 2019 13:01:57 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=483</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>注意node节点存的什么，要灵活变化！</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>


#include &lt;bits/stdc++.h>
using namespace std;

struct node {
    int flag;
    char s[11];
    node* next[26];
    node() {
        flag = 0;
        for (int i = 0; i &lt;= 25; i++)
            next[i] = NULL;
    }
};

node root;

void Insert(char *word, char *sf) {
    node* p = &root;
    for (int i = 0; word[i] ; ++i) {
        if (p->next[word[i] - 'a'] == NULL)
            p->next[word[i] - 'a'] = new node;
        p = p->next[word[i] - 'a'];
    }
    p->flag = 1;
    strcpy(p->s, sf);
}

int fnd(char* word) {
    int flag = 1;
    node* p = &root;
    for (int i = 0; word[i]; ++i) {
        if (p->next[word[i] - 'a'] != NULL)
            p = p->next[word[i] - 'a'];
        else {
            flag = 0;
            break;
        }
    }
    if (p->flag == 0) {
        return 0;
    }
    if (flag == 1) {
        printf("%s\n", p->s);
        return 1;
    }
    return 0;
}

int main() {
    char wd1[11], wd2[11];
    while (scanf("%s", wd1) != EOF) {
        if (getchar() == '\n') {
            if (fnd(wd1) == 0)
                printf("eh\n");
            break;
        }
        scanf("%s", wd2);
        Insert(wd2,wd1); 
    }
    while (scanf("%s", wd1) != EOF) {
        if (fnd(wd1) == 0)
            printf("eh\n");
    }
}</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>483</wp:post_id>
		<wp:post_date><![CDATA[2019-08-05 21:01:57]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-08-05 13:01:57]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[zoj-1109-language-of-fatmouse-trie%e5%ad%97%e5%85%b8%e6%a0%91]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="trie"><![CDATA[字符串__Trie字典树]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>POJ-2001-Shortest Prefixes-Trie字典树</title>
		<link>https://sdnuqp.cn/poj-2001-shortest-prefixes-trie%e5%ad%97%e5%85%b8%e6%a0%91/</link>
		<pubDate>Mon, 05 Aug 2019 13:02:19 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=486</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>这个题比较复杂，我竟然1遍过了，嘿嘿黑。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>这个题是要你找很多字符串的缩写，规则是</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>1.最短。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>2.该子串没有歧义（不是其他串的子串）</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>我的思路是，建树时，每个节点记录走过的次数。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>最后去查找的时候，查到第一个flag值 == 1 的点，说明只有1个串经过这个节点，当然这就是该串的最短前缀了。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>OVER</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>AC code:</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>

#include &lt;iostream>
#include &lt;cstdio>
#include &lt;cstring>
#include &lt;algorithm>
using namespace std;

char word[1001][21];

struct node {
    int num;
    node* next[26];
    node() {
        num = 0;
        memset(next, NULL, sizeof next);
    }
};

node root;

void Insert(char* word) {
    node* p = &root;
    for (int i = 0; word[i]; ++i) {
        if (p->next[word[i] - 'a'] == NULL)
            p->next[word[i] - 'a'] = new node;
        p = p->next[word[i] - 'a'];
        p->num++;
    }
}

void Find(char *word) {
    node* p = &root;
    for (int i = 0; word[i]; ++i) {
        p = p->next[word[i] - 'a'];
        printf("%c",word[i]);
        if (p->num == 1) {
            printf("\n");
            return;
        }
    }
    printf("\n");
}

int main() {
    int cnt = 1;
    while (scanf("%s", word[cnt]) != EOF) {
        Insert(word[cnt++]);
    }
    for (int i = 1; i &lt; cnt; i++) {
        printf("%s ",word[i]);
        Find(word[i]);
    }
    return 0;
}</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>486</wp:post_id>
		<wp:post_date><![CDATA[2019-08-05 21:02:19]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-08-05 13:02:19]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[poj-2001-shortest-prefixes-trie%e5%ad%97%e5%85%b8%e6%a0%91]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="trie"><![CDATA[字符串__Trie字典树]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>POJ - 1056-IMMEDIATE DECODABILITY-Trie字典树静态建树</title>
		<link>https://sdnuqp.cn/poj-1056-immediate-decodability-trie%e5%ad%97%e5%85%b8%e6%a0%91%e9%9d%99%e6%80%81%e5%bb%ba%e6%a0%91/</link>
		<pubDate>Mon, 05 Aug 2019 13:10:56 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=488</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:code -->
<pre class="wp-block-code"><code>去找我的代码，发现被vjudge吃掉了，55555555555555555555555555。和HDU1305几乎一样，改改就好了，去看那个吧，555555555555.</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>488</wp:post_id>
		<wp:post_date><![CDATA[2019-08-05 21:10:56]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-08-05 13:10:56]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[poj-1056-immediate-decodability-trie%e5%ad%97%e5%85%b8%e6%a0%91%e9%9d%99%e6%80%81%e5%bb%ba%e6%a0%91]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="trie"><![CDATA[字符串__Trie字典树]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>POJ-1679-The Unique MST-次小生成树</title>
		<link>https://sdnuqp.cn/poj-1679-the-unique-mst-%e6%ac%a1%e5%b0%8f%e7%94%9f%e6%88%90%e6%a0%91/</link>
		<pubDate>Mon, 12 Aug 2019 01:17:41 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=501</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:code -->
<pre class="wp-block-code"><code>
#include &lt;cstdio>
#include &lt;iostream>
#include &lt;cstring>
#include &lt;algorithm>
using namespace std;
const int maxn = 1e3 + 10;
const int INF = 0x3f3f3f3f;
#define rep(i,a,b) for(int i = (a) ; i &lt;= (b) ; ++i)

int res;
int lowcost[maxn];
int pre[maxn];
bool vis[maxn];
int maxx[maxn][maxn]; ////
bool used[maxn][maxn];////
int cost[maxn][maxn];

void init() {
    memset(cost, INF, sizeof cost);
    memset(vis, 0, sizeof vis);
    memset(maxx, 0, sizeof maxx);
    memset(used, 0, sizeof used);
}

int Prim(int cost[][maxn], int n) {
    rep(i, 1, n) {
        lowcost[i] = cost[1][i];
        pre[i] = 1;
    }
    vis[1] = 1;
    lowcost[1] = 0;
    int res = 0;
    int index;
    int min_value;
    rep(i, 2, n) {
        index = -1;
        min_value = INF;
        rep(j, 2, n) {
            if (min_value > lowcost[j] &amp;&amp; !vis[j]) {
                min_value = lowcost[j];
                index = j;
            }
        }
        if (min_value == INF || index == -1)
            return res;
        vis[index] = 1;
        used[index][pre[index]] = used[pre[index]][index] = 1;
        res += min_value;
        maxx[index][pre[index]] = maxx[pre[index]][index] = min_value;
        rep(j, 1, n) { 
            if (vis[j] &amp;&amp; j != index) {
                maxx[j][index] = maxx[index][j] = max(maxx[j][pre[index]], lowcost[index]);
            }
            if (!vis[j] &amp;&amp; lowcost[j] > cost[index][j]) {
                lowcost[j] = cost[index][j];
                pre[j] = index;
            }
        }
    }
    return res;
}

int main() {
    int n, m;
    int T;
    scanf("%d", &amp;T);
    while (T--){
        init();
        scanf("%d %d", &amp;n, &amp;m);
        int a, b, c;
        rep(i, 1, m) {
            scanf("%d %d %d", &amp;a, &amp;b, &amp;c);
            cost[a][b] = cost[b][a] = c;
        }
        int x = Prim(cost, n);
        int flag = 0;
        for (int i = 1; !flag &amp;&amp; i &lt;= n; i++) {
            rep(j, 1, n) {
                if (maxx[i][j] == INF || used[i][j] == 1)
                    continue;
                if (maxx[i][j] == cost[i][j]) {
                    flag = 1;
                    break;
                }
            }
        }
        if (flag) {
            printf("Not Unique!\n");
        }
        else
            printf("%d\n",x);
    }
    return 0;
}</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>501</wp:post_id>
		<wp:post_date><![CDATA[2019-08-12 09:17:41]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-08-12 01:17:41]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[poj-1679-the-unique-mst-%e6%ac%a1%e5%b0%8f%e7%94%9f%e6%88%90%e6%a0%91]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e6%ac%a1%e5%b0%8f%e7%94%9f%e6%88%90%e6%a0%91"><![CDATA[图论__次小生成树]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>HDU-4081-in Shi Huang&#039;s National Road System-次小生成树</title>
		<link>https://sdnuqp.cn/hdu-4081-in-shi-huangs-national-road-system-%e6%ac%a1%e5%b0%8f%e7%94%9f%e6%88%90%e6%a0%91/</link>
		<pubDate>Mon, 12 Aug 2019 01:20:14 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=503</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:code -->
<pre class="wp-block-code"><code>

/*
次小生成树
*/

#include &lt;cstdio>
#include &lt;iostream>
#include &lt;cstring>
#include &lt;algorithm>
using namespace std;
const int maxn = 1e3 + 10;
const int INF = 0x3f3f3f3f;
#define rep(i,a,b) for(int i=a ; i&lt;=b ; ++i)

double mp[maxn][maxn];
double lowcost[maxn];
double maxx[maxn][maxn];
double xy[maxn][2];
double a[maxn];
bool used[maxn][maxn];
bool vis[maxn];
int pre[maxn];

inline double getdis(double x1, double y1, double x2, double y2) {
    return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
}

double prim(int n) {
    memset(vis, 0, sizeof vis);
    memset(used, 0, sizeof used);
    memset(maxx, 0, sizeof maxx);
    rep(i, 1, n) {
        lowcost[i] = mp[1][i];
        pre[i] = 1;
    }
    vis[1] = 1;
    double res = 0;
    int idx;
    rep(i, 2, n) {
        idx = -1;
        rep(j, 2, n) if (!vis[j]) {
            if (idx == -1 || lowcost[idx] > lowcost[j]) {
                idx = j;
            }
        }
        if (idx == -1)
            return res;
        res += lowcost[idx];
        vis[idx] = 1;
        used[idx][pre[idx]] = used[pre[idx]][idx] = true;
        rep(j, 1, n) {
            if (vis[j] &amp;&amp; j != idx) {
                maxx[idx][j] = maxx[j][idx] = max(maxx[j][pre[idx]], lowcost[idx]);
            }
            if (!vis[j] &amp;&amp; lowcost[j] > mp[idx][j]) {
                lowcost[j] = mp[idx][j];
                pre[j] = idx;
            }
        }
    }
    return res;
}

int main() {
    int T;
    int n;
    scanf("%d", &amp;T);
    while (T--) {
        memset(mp, 0, sizeof mp);
        scanf("%d", &amp;n);
        rep(i, 1, n) {
            scanf("%lf %lf %lf", &amp;xy[i][0], &amp;xy[i][1], &amp;a[i]);
        }
        rep(i, 1, n) {
            rep(j, 1, n) if (i != j) {
                mp[i][j] = getdis(xy[i][0], xy[i][1], xy[j][0], xy[j][1]);
            }
        }
        double len = prim(n);
        //printf("%f\n",len);
        double ans = -1;
        rep(i, 1, n) {
            rep(j, 1, n) if (i != j) {
                if (used[i][j]) {
                    ans = max(ans, (a[i] + a[j]) / (len - mp[i][j]));
                }
                else {
                    ans = max(ans, (a[i] + a[j]) / (len - maxx[i][j]));
                }
            }
        }
        printf("%.2f\n", ans);
    }
    return 0;
}</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>503</wp:post_id>
		<wp:post_date><![CDATA[2019-08-12 09:20:14]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-08-12 01:20:14]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu-4081-in-shi-huangs-national-road-system-%e6%ac%a1%e5%b0%8f%e7%94%9f%e6%88%90%e6%a0%91]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e6%ac%a1%e5%b0%8f%e7%94%9f%e6%88%90%e6%a0%91"><![CDATA[图论__次小生成树]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>UVA-10600-CM Contest and Blackout-次小生成树</title>
		<link>https://sdnuqp.cn/uva-10600-cm-contest-and-blackout-%e6%ac%a1%e5%b0%8f%e7%94%9f%e6%88%90%e6%a0%91/</link>
		<pubDate>Mon, 12 Aug 2019 01:21:33 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=505</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:code -->
<pre class="wp-block-code"><code>


#include &lt;bits/stdc++.h>
using namespace std;
#define rep(i,a,b) for(int i=(a) ; i&lt;=(b); ++i)
const int maxn = 1e2 + 10;
const int INF = 0x3f3f3f3f;

int n, m;
int a, b, c;

int mp[maxn][maxn];
int maxx[maxn][maxn];
int lowcost[maxn];
int pre[maxn];
bool vis[maxn];
bool used[maxn][maxn];

void init() {
    memset(vis, 0, sizeof vis);
    memset(used, 0, sizeof used);
    memset(maxx, 0, sizeof maxx);
    rep(i, 1, n)
        rep(j, 1, n) {
        if (i == j)
            mp[i][j] = 0;
        else
            mp[i][j] = mp[j][i] = INF;
    }
}

int prim() {
    rep(i, 1, n) {
        lowcost[i] = mp[1][i];
        pre[i] = 1;
    }
    vis[1] = 1;
    int res = 0;
    rep(i, 2, n) {
        int idx = -1;
        rep(j, 2, n) if (!vis[j]) {
            if (lowcost[j] &lt; lowcost[idx] || idx == -1) {
                idx = j;
            }
        }
        vis[idx] = 1;
        res += lowcost[idx];
        used[idx][pre[idx]] = used[pre[idx]][idx] = true;
        rep(j, 1, n) {
            if (vis[j] &amp;&amp; j != idx) {
                maxx[j][idx] = maxx[idx][j] = max(maxx[pre[idx]][j], lowcost[idx]);
            }
            if (!vis[j] &amp;&amp; lowcost[j] > mp[j][idx]) {
                lowcost[j] = mp[j][idx];
                pre[j] = idx;
            }
        }
    }
    return res;
}

int SecMST(int num) {
    int z = INF;
    rep(i, 1, n)
        rep(j, i + 1, n)
        if (!used[i][j] &amp;&amp; mp[i][j] != INF)
            z = min(z, num - maxx[i][j] + mp[i][j]);
    return z;
}

int main() {
    int T;
    scanf("%d", &amp;T);
    while (T--) {
        scanf("%d %d", &amp;n, &amp;m);
        init();
        for (int i = 1; i &lt;= m; i++) {
            scanf("%d %d %d", &amp;a, &amp;b, &amp;c);
            mp[a][b] = mp[b][a] = c;
        }
        int ans = prim();
        int secans = SecMST(ans);
        printf("%d %d\n", ans, secans);
    }
}


/*
2
5 8
1 3 75
3 4 51
2 4 19
3 2 95
2 5 42
5 4 31
1 2 9
3 5 66
9 14
1 2 4
1 8 8
2 8 11
3 2 8
8 9 7
8 7 1
7 9 6
9 3 2
3 4 7
3 6 4
7 6 2
4 6 14
4 5 9
5 6 10

*/</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>505</wp:post_id>
		<wp:post_date><![CDATA[2019-08-12 09:21:33]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-08-12 01:21:33]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[uva-10600-cm-contest-and-blackout-%e6%ac%a1%e5%b0%8f%e7%94%9f%e6%88%90%e6%a0%91]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e6%ac%a1%e5%b0%8f%e7%94%9f%e6%88%90%e6%a0%91"><![CDATA[图论__次小生成树]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>EXGCD拓展欧几里得算法</title>
		<link>https://sdnuqp.cn/exgcd%e6%8b%93%e5%b1%95%e6%ac%a7%e5%87%a0%e9%87%8c%e5%be%97%e7%ae%97%e6%b3%95/</link>
		<pubDate>Mon, 12 Aug 2019 03:15:40 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=507</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>很精妙的算法，通过简单的递归，就能够求出一组解，满足ax+by = GCD(a,b);</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>这个等式是一个贝祖等式，贝祖定理(裴蜀定理)详见：<a href="https://baike.baidu.com/item/裴蜀定理/5186593?fr=aladdin&amp;fromtitle=%E8%B4%9D%E7%A5%96%E5%AE%9A%E7%90%86&amp;fromid=5185441">传送门</a></p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>Code 1:

#include &lt;bits/stdc++.h>
using namespace std;
int a, b, x, y；

void EXGCD(int a, int b, int &amp;x, int &amp;y) {
    if (!b) { x = 1; y = 0; return; }
    EXGCD(b, a%b, y, x);
    y -= a / b * x;
}

int main() {
    scanf("%d %d", &amp;a, &amp;b);
    EXGCD(a,b,x,y);
    printf("%d %d", x, y);
    return 0;
}</code></pre>
<!-- /wp:code -->

<!-- wp:code -->
<pre class="wp-block-code"><code>Code 2:

#include &lt;bits/stdc++.h>
using namespace std;
#define pir pair&lt;int,int>    
int a, b, x, y;

pir EXGCD(int a,int b) {
    if (!b) return make_pair(1, 0);
    pir tmp = EXGCD(b, a%b);
    return make_pair(tmp.second ,tmp.first - a/b*tmp.second);
}

int main() {
    scanf("%d %d", &amp;a, &amp;b);
    pir ans = EXGCD(a,b);
    printf("%d %d",ans.first,ans.second);
    return 0;
}</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>507</wp:post_id>
		<wp:post_date><![CDATA[2019-08-12 11:15:40]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-08-12 03:15:40]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[exgcd%e6%8b%93%e5%b1%95%e6%ac%a7%e5%87%a0%e9%87%8c%e5%be%97%e7%ae%97%e6%b3%95]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论___GCD/EXGCD]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>UVA-10371-Choose and divide-唯一分解定理应用</title>
		<link>https://sdnuqp.cn/uva-10371-choose-and-divide-%e5%94%af%e4%b8%80%e5%88%86%e8%a7%a3%e5%ae%9a%e7%90%86%e5%ba%94%e7%94%a8/</link>
		<pubDate>Mon, 12 Aug 2019 07:00:18 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=510</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>唯一分解定理的简单应用。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>素数要先筛出来（埃氏筛/线性筛）</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>然后将因子存入数组中</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>再用公式逐项处理即可：</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>C(m,n) = m! / (n! (m-n)! )</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>


#include &lt;bits/stdc++.h>
using namespace std;

int primes[10010];
bool vis[10010];
int e[10010];
int cnt;

void get_primes() {
    for (int i = 2; i &lt;= 10000; i++) {
        if (vis[i] == 0) {
            primes[cnt++] = i;
            for (int j = i * i; j &lt;= 10000; j += i) {
                vis[j] = 1;
            }
        }
    }
}

void add_integer(int n,int d) {
    for (int i = 0; i &lt; cnt ; i++) {
        while (n % primes[i] == 0) {
            n /= primes[i];
            e[i] += d;
        }
        if (n == 1)
            break;
    }
}

void add_factorical(int n, int d) {
    for (int i = 1; i &lt;= n; i++) {
        add_integer(i, d);
    }
}

int main() {
    int p, q, r, s;
    get_primes();
    while (cin >> p >> q >> r >> s) {
        memset(e,0,sizeof e);
        add_factorical(p,1);
        add_factorical(q,-1);
        add_factorical(p-q,-1);
        add_factorical(r, -1);
        add_factorical(s, 1);
        add_factorical(r - s, 1);
        double ans = 1;
        for (int i = 0; i &lt; cnt; i++) {
            ans *= pow(primes[i], e[i]);
        }
        printf("%.5f\n",ans);
    }
}</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>510</wp:post_id>
		<wp:post_date><![CDATA[2019-08-12 15:00:18]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-08-12 07:00:18]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[uva-10371-choose-and-divide-%e5%94%af%e4%b8%80%e5%88%86%e8%a7%a3%e5%ae%9a%e7%90%86%e5%ba%94%e7%94%a8]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="unique-decomposition-theorem"><![CDATA[数论___唯一分解定理]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>UVA-12716-GCD XOR</title>
		<link>https://sdnuqp.cn/uva-12716-gcd-xor/</link>
		<pubDate>Mon, 12 Aug 2019 09:34:28 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=514</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>紫薯p318上的例题</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>并没有看懂刘大爷再说什么。。。n(log(n)^2) 的算法也不知道怎么实现的。。。怎么就logn了呢。。ORZ。。。请看下面这位同学的blog。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><a href="https://blog.csdn.net/shimmer_/article/details/38492143">传送门</a></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>不过这个题最重要的地方应该是c = a - b吧，刘大爷直接明确说了，但自己不一定能推出来吧，我大概会暴力的去gcd</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>学到了，倍增的话可以将所有情况遍历一遍，并且时间复杂度还比较低(这个题打表时的确运行要明显卡顿一下，n &lt;= 3e7)</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>
#include &lt;bits/stdc++.h>
using namespace std;
#define ll long long
typedef unsigned long long ull;
#define maxn 30000000
#define INF 1&lt;&lt;30

int s[30000000 + 10];

void init() {
    int sum = 0;
    for (int c = 1; c &lt;= maxn / 2; c++) {
        for (int a = c + c; a &lt;= maxn; a += c) {
            int b = a - c;
            if ((a ^ b) == c)
                s[a]++;
        }
    }
    for (int i = 2; i &lt;= maxn; i++)
        s[i] += s[i - 1];
}

int main() {
    int counts = 0, num;
    scanf("%d", &amp;num);
    init();
    while (num--) {
        int n;
        scanf("%d", &amp;n);
        printf("Case %d: %d\n", ++counts, s[n]);
    }
    return 0;
}
</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>514</wp:post_id>
		<wp:post_date><![CDATA[2019-08-12 17:34:28]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-08-12 09:34:28]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[uva-12716-gcd-xor]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论___GCD/EXGCD]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>SDNUOJ-1213-金额的中文大写-模拟</title>
		<link>https://sdnuqp.cn/sdnuoj-1213-%e9%87%91%e9%a2%9d%e7%9a%84%e4%b8%ad%e6%96%87%e5%a4%a7%e5%86%99-%e6%a8%a1%e6%8b%9f/</link>
		<pubDate>Wed, 14 Aug 2019 08:11:32 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=518</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>真恶心哦，这个题数据很水，我有个地方写错了也A了，当然，接着改过来了，后面代码是完美的（像00000.00这种李XX出的250样例当然过不了）</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>这个题思路是这样的：</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>首先最大是亿，所以数最大有12位(整数部分)，所以我将输入数字(字符串读入)存在一个数组中，然后3个for循环遍历1-&gt;4 , 5 -&gt; 8 , 9 -&gt; 12 ，为什么要这样呢，因为，我们可以发现，每一段的输出规则是一样的，只不过在每一段后面加了一个“亿”或者“万”，请看样例：</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">input:
12345678900.23

output:
壹佰贰拾叁亿肆仟伍佰陆拾柒万捌仟玖佰元贰角叁分</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>我们可以发现输出分解一下就是：</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>壹佰贰拾叁      亿    肆仟伍佰陆拾柒     万     捌仟玖佰元     贰角叁分</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>每一部分对应着：</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>123     4567     8900     .23</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>这时候我们就可以写代码了。情况只有4种而已，注意要在开头是10的时候输出“拾”，而不是“一拾”，top变量标记开始。</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>


#include &lt;bits/stdc++.h>
using namespace std;

int vis[100];
char s[100];
char ss[100];
map&lt;int, string>mp;
map&lt;char, string>mmp;

int main() {
    mp[4] = "";
    mp[3] = "拾";
    mp[2] = "佰";
    mp[1] = "仟";
    mmp['0'] = "零";
    mmp['1'] = "壹";
    mmp['2'] = "贰";
    mmp['3'] = "叁";
    mmp['4'] = "肆";
    mmp['5'] = "伍";
    mmp['6'] = "陆";
    mmp['7'] = "柒";
    mmp['8'] = "捌";
    mmp['9'] = "玖";
    while (gets(s)) {
        int top = 1;
        memset(vis, 0, sizeof vis);
        for (int i = 1; i &lt;= 30; i++) {
            ss[i] = '\0';
        }
        int flag = 0;
        int idx = strlen(s);
        for (int i = 0; i &lt; strlen(s); ++i) {
            if (s[i] == '.') {
                flag = 1;
                idx = i;
                break;
            }
        }
        int cnt = 12;
        for (int i = idx - 1; i >= 0; i--) {
            ss[cnt] = s[i];
            cnt--;
        }

        //printf("no.1\n");
        int fl1 = 0;
        for (int i = 1; i &lt;= 4; i++) {
            if (ss[i] != '\0') {
                if(top){
                    top = 0;
                    if(ss[i] == '1' &amp;&amp; i ==  3){
                        cout &lt;&lt; "拾";
                        continue;
                    }
                }
                if (ss[i] != '0') {
                    cout &lt;&lt; mmp[ss[i]] ;
                    cout &lt;&lt; mp[i] ;
                }
                else {
                    if (ss[i + 1] != '0' &amp;&amp; ss[i+1] != '\0') {
                        cout &lt;&lt; "零" ;
                    }
                }
                fl1 = 1;
            }
        }
        if (fl1)
            cout &lt;&lt; "亿";

        int fl2 = 0;
        for (int i = 5; i &lt;= 8; i++) {
            if (ss[i] != '\0') {
                if(top){
                    top = 0;
                    if(ss[i] == '1' &amp;&amp; i == 7){
                        cout &lt;&lt; "拾";
                        continue;
                    }
                }
                if (ss[i] != '0') {
                    cout &lt;&lt; mmp[ss[i]];
                    cout &lt;&lt; mp[i - 4];
                }
                else {
                    if (ss[i + 1] != '0' &amp;&amp; ss[i+1] != '\0') {
                        cout &lt;&lt; "零";
                    }
                }
                fl2 = 1;
            }
        }
        if (fl2)
            cout &lt;&lt; "万";

        for (int i = 9; i &lt;= 12; i++) {
            if (ss[i] != '\0') {
                if(top){
                    top = 0;
                    if(ss[i] == '1' &amp;&amp; i == 11){
                        cout &lt;&lt; "拾";
                        continue;
                    }
                }
                if (ss[i] != '0') {
                    cout &lt;&lt; mmp[ss[i]];
                    cout &lt;&lt; mp[i - 8];
                }
                else {
                    if (ss[i + 1] != '0' &amp;&amp; ss[i+1] != '\0') {
                        cout &lt;&lt; "零";
                    }
                }
                fl1 = 1;
            }
        }
        cout &lt;&lt; "元";
        if (flag) {
            for (int i = idx + 1; i &lt; strlen(s); i++) {
                cout &lt;&lt; mmp[s[i]];
                if (i == idx + 1)
                    if(s[i] == '0')
                        ;
                    else
                        cout &lt;&lt; "角";
                else
                    cout &lt;&lt; "分";
            }
        }
        else
            cout &lt;&lt; "整";
        cout &lt;&lt; '\n';
    }
    return 0;
}


/*

12345678900.23

*/
</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>518</wp:post_id>
		<wp:post_date><![CDATA[2019-08-14 16:11:32]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-08-14 08:11:32]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[sdnuoj-1213-%e9%87%91%e9%a2%9d%e7%9a%84%e4%b8%ad%e6%96%87%e5%a4%a7%e5%86%99-%e6%a8%a1%e6%8b%9f]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="sdnuoj"><![CDATA[OJ__SDNUOJ]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>HDU-2222-Keywords Search-AC自动机</title>
		<link>https://sdnuqp.cn/hdu-2222-keywords-search-ac%e8%87%aa%e5%8a%a8%e6%9c%ba/</link>
		<pubDate>Sat, 17 Aug 2019 02:55:36 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=521</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>入门级模板题,比着斌巨模板写的:</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>AC code:</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>#include &lt;cstdio>
#include &lt;iostream>
#include &lt;cstring>
#include &lt;algorithm>
#include &lt;queue>
//#include &lt;bits/stdc++.h>
using namespace std;

struct Trie {
    int next[500010][26], fail[500010], end[500010];
    int root, L;
    int newnode() {
        for (int i = 0; i &lt;= 25; ++i)
            next[L][i] = -1;
        end[L++] = 0;
        return L - 1;
    }
    void init() {
        L = 0;
        root = newnode();
    }
    void insert(char buf[]) {
        int len = strlen(buf);
        int now = root;
        for (int i = 0; i &lt; len; ++i) {
            if (next[now][buf[i] - 'a'] == -1)
                next[now][buf[i] - 'a'] = newnode();
            now = next[now][buf[i] - 'a'];
        }
        end[now]++;
    }
    void build() {
        queue&lt;int>q;
        fail[root] = root;
        for (int i = 0; i &lt; 26; i++)
            if (next[root][i] == -1)
                next[root][i] = root;
            else {
                fail[next[root][i]] = root;
                q.push(next[root][i]);
            }
        while (!q.empty()) {
            int now = q.front();
            q.pop();
            for (int i = 0; i &lt;= 25; ++i) {
                if (next[now][i] == -1)
                    next[now][i] = next[fail[now]][i];
                else {
                    fail[next[now][i]] = next[fail[now]][i];
                    q.push(next[now][i]);
                }
            }
        }
    }
    int query(char buf[]) {
        int len = strlen(buf);
        int now = root;
        int res = 0;
        for (int i = 0; i &lt; len; ++i) {
            now = next[now][buf[i] - 'a'];
            int temp = now;
            while (temp != root) {
                res += end[temp];
                end[temp] = 0;
                temp = fail[temp];
            }
        }
        return res;
    }
};

char buf[1000010];
Trie ac;

int main() {
    int T;
    int n;
    scanf("%d",&amp;T);
    while (T--) {
    scanf("%d", &amp;n);
    ac.init();
    for (int i = 0; i &lt;= n - 1; ++i) {
        scanf("%s", buf);
        ac.insert(buf);
    }
    scanf("%s", buf);
    ac.build();
    printf("%d\n", ac.query(buf));
    }
    return 0;
}

/*
binju模板
*/</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>521</wp:post_id>
		<wp:post_date><![CDATA[2019-08-17 10:55:36]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-08-17 02:55:36]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu-2222-keywords-search-ac%e8%87%aa%e5%8a%a8%e6%9c%ba]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="aho-corasick-automation"><![CDATA[字符串__AC自动机]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>SDNUOJ-1118-单词统计-AC自动机</title>
		<link>https://sdnuqp.cn/sdnuoj-1118-%e5%8d%95%e8%af%8d%e7%bb%9f%e8%ae%a1-ac%e8%87%aa%e5%8a%a8%e6%9c%ba/</link>
		<pubDate>Sat, 17 Aug 2019 03:02:13 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=523</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>呵呵,这道题要统计每一个单词的出现次数.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>注意,字符串可能会有重复!!!!!我想了好久,最后才意识到可能只是这错了,我觉得根据题意不应该会有重复串的,可惜题就是题而已,不会考虑真实情况,改了之后,AC.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>这题师哥写: 也可以java水过...</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>于是:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":524} -->
<figure class="wp-block-image"><img src="https://sdnuqp.cn/wp-content/uploads/2019/08/image-1024x496.png" alt="" class="wp-image-524"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>我笑了.....</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>呵</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>呵呵</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>请看正确题解:</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>AC code:</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>

#include &lt;bits/stdc++.h>
using namespace std;

map&lt;int, int>mp;

struct Trie {
    int next[1000010][26], fail[1000010], end[1000010];
    int root, L;
    int newnode() {
        for (int i = 0; i &lt;= 25; i++)
            next[L][i] = -1;
        end[L++] = -1;
        return L - 1;
    }
    void init() {
        memset(num, 0, sizeof num);
        L = 0;
        root = newnode();
    }

    void insert(char word[] ,int cnt) {
        int len = strlen(word);
        int now = root;
        for (int i = 0; i &lt; len; i++) {
            if (next[now][word[i] - 'a'] == -1)
                next[now][word[i] - 'a'] = newnode();
            now = next[now][word[i] - 'a'];
        }
        end[now] = cnt;
        mp[cnt] = now;
    }

    void build() {
        queue&lt;int>q;
        fail[root] = root;
        for (int i = 0; i &lt;= 25; ++i) {
            if (next[root][i] == -1)
                next[root][i] = root;
            else {
                fail[next[root][i]] = root;
                q.push(next[root][i]);
            }
        }
        while (!q.empty()) {
            int now = q.front();
            q.pop();
            for (int i = 0; i &lt;= 25; ++i) {
                if (next[now][i] == -1) {
                    next[now][i] = next[fail[now]][i];    ///应用fail，转到其他串上
                }
                else {
                    fail[next[now][i]] = next[fail[now]][i]; ///填充fail数组.
                    q.push(next[now][i]);
                }
            }
        }
    }
    int num[50010];
    void query(char word[]) {
        int len = strlen(word);
        int now = root;
        for (int i = 0; i &lt; len; i++) {
            now = next[now][word[i] - 'a'];
            int temp = now;
            while (temp != root) {
                //printf("%d\n",end[temp]);
                if (end[temp] != -1)
                    num[end[temp]]++;
                //end[temp] = 0;
                temp = fail[temp];
            }
        }
    }
    void print(int n) {
        printf("%d",num[end[mp[1]]]);
        for (int i = 2; i &lt;= n; i++) {
            printf(" %d", num[end[mp[i]]]);
        }
        printf("\n");
    }
};

char word[1000010];
Trie ac;

int main() {
    int n;
    while (scanf("%d", &amp;n) != EOF) {

        ac.init();
        for (int i = 1; i &lt;= n; ++i) {
            scanf("%s", word);
            ac.insert(word , i);
        }
        ac.build();
        scanf("%s", word);
        ac.query(word);
        ac.print(n);
    }
    return 0;
}


/*

6
she
she
he
say
shr
her
sheyasherhs
5
she
he
say
shr
her
yasherhs
7
a
ab
ba
aba
aba
bab
bab
aababa

*/</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>523</wp:post_id>
		<wp:post_date><![CDATA[2019-08-17 11:02:13]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-08-17 03:02:13]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[sdnuoj-1118-%e5%8d%95%e8%af%8d%e7%bb%9f%e8%ae%a1-ac%e8%87%aa%e5%8a%a8%e6%9c%ba]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="aho-corasick-automation"><![CDATA[字符串__AC自动机]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>OOP-C++笔记-1</title>
		<link>https://sdnuqp.cn/oop-c-%e7%ac%94%e8%ae%b01/</link>
		<pubDate>Tue, 27 Aug 2019 13:29:28 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=530</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:code -->
<pre class="wp-block-code"><code>提前声明: temp 均为变量

第二章C++对C的改进及拓展
2.1 函数中一些基本控制的区别{
    2.1.1 C++I/O流{
        "流" : 将数据从一个对象到另一个对象的流动抽象为"流"
        提取符: ">>"
        插入符: "&lt;&lt;"
    }
    2.1.2 注释
    2.1.3 const{
        用const定义只读变量,而不是宏定义,安全.
        课本写到 : 缺省"常量类型",默认为int,注意!!!VS和CB测试后均提示"C++不支持默认int"
        符号常量有地址,可以有指针指向,但不能修改常量值;
    }
    2.1.4 强制类型转换{
        static_cast
        const_cast
        dynamic_cast
        reinterpret_cast
    }
    2.1.5 bool{
        可以使用boollalpha操纵符使其输出为true/false.
        用法: 
            cout &lt;&lt; boolalpha &lt;&lt; temp; 
        流操纵符 : 控制输入输出格式的一类函数
    }
    2.1.6 名称(字)空间{
        格式:
            namespace 名称 { ... ; }
        使用方法:{
            1.using namespace ...; 之后可以随便使用,无需"::"
            2.使用域解析符(或称作用域运算)"::". 例: std::cin >> temp
            3.using namespace 名称::局部内容(相当于"解析"了部分东西,不能全部使用)
        }
    }
}
2.2有关函数的区别{
    2.2.1 局部变量随用随定义
    2.2.2 域解析符::扩大全局变量的范围{
        局部变量与全局变量重名时,局部变量优先级高,但我们此时仍要用全局变量,就要使用"::"
        用法:
            ::temp = ... ;
        (局部变量全局变量重名后还要用全局变量是只有沙雕才会做出来的事,请不要做沙雕)
    }
    2.2.3 形式参数可带有默认值{
        一般的写法 : f(int a ,int b ,int c)
        现在可以写成 : f(int a , int b = 1, int c = 2) (注意这里缺省是有顺序的,请自己测试)
        并且在使用的时候可以不传 b 和 c 的值 : f(5);
        而不会提示 "E0165 函数调用中的参数太少".
    }
    2.2.4 内联函数{
        函数前面增加关键字 inline , 该函数就成为内联函数
        内联函数与宏定义相似, 但更安全.
        注意,内联函数虽然是函数,但只能处理很简单的操作.
        请不要妄想将所有函数前面都加inline去提高程序运行速度
        这种做法,貌似很厉害(我也这么写过)
        实际上,计算机会识别函数复杂程度, 基本上, 只有不超过2行内容的函数才会成功转化为内联函数,其他的....emm,写了和没写一模一样...
    }
    2.2.5 函数重载{
        定义:对于功能完全相同或类似,只是在形式参数的个数,类型,顺序仿麦呢有区别的不同函数以相同函数名来命名,该同名函数称为被重载(Overload)
        f(int = 3) 与 f() 不可.
        上面这个函数()中的东西很奇怪,意思是你可以传入参数也可以不传参数,参数默认==3,没法引用,没有用.
    }
}
2.3 新增引用的灵活运用{
    引用(Reference)在声明时通过&amp;来标记,用来为变量起别名
    2.3.1 引用的概念及使用{
        使用时,不会为其另外分配空间
        不能建立引用的引用,引用的指针,引用数组,总之,引用是最后一级.并且,引用和原变量是"绑定"的(一个值变,都变!)
    }
    2.3.2 引用作为形式参数{
        最常用的方法,标准的称为,扩大实际参数变量的作用域.(多定义全局变量可以省事很多)
        const int &amp;temp 常引用,只能访问,不能修改,安全
    }
    2.3.3 引用与指针的区别{
        区别较大,却又功能相似.
        可以理解为引用是有限制的简化的指针,所以引用深受C++程序员青睐,但指针...你懂的.

    }
    2.3.4 引用作为返回值{
        int&amp; f(){ ...; }
    }
}
2.4 动态内存空间管理{
    2.4.1 用new申请动态空间{
        int *pre;
        C风格{
            pre = (int*)malloc(10*sizeof(int));
            pre = (int*)calloc(10,sizeof(int));
            free;
        }
    }
    2.4.2 用delete释放动态内存空间{
        C++风格{
            (new是运算符而不是库函数)
            pre = new int;
            pre = new int[10];
            delete []pre;
            delete pre;
        }
        注意! 尽可能使用new &amp; delete,因为malloc&amp;free对于C++中的一些东西(构造/析构函数)不支持!
    }
    2.4.3 void类型的指针{
        1.可以定义void类型的指针,但是不能定义void类型的变量或引用
        用法:{
            void *temp;
            char c = 'A';
            temp = &c;
            cout &lt;&lt; *(char *)temp &lt;&lt; endl;  // 这个地方转成什么类型就再显示转换回什么类型,写别的类型输出不正确
        }
    }
}
2.5 C++语言中的异常处理{
    2.5.1 异常和异常处理{
        RE; runtime error 运行错误
        CE; complier error 编译错误
    }
    2.5.2 异常处理的实现{
        3步:{
            1.检查异常(使用try)
            2.抛出异常(使用throw)
            3.捕捉异常(使用catch)
            catch(...)
            "..."不是省略号,而是可变参数列表,能用于捕捉所有异常
        }
    }
}

2019-8-28</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>530</wp:post_id>
		<wp:post_date><![CDATA[2019-08-27 21:29:28]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-08-27 13:29:28]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[oop-c-%e7%ac%94%e8%ae%b01]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="oop-c"><![CDATA[基础__OOP-C++]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>OOP-C++笔记-2</title>
		<link>https://sdnuqp.cn/oop-c%e7%ac%94%e8%ae%b0-2/</link>
		<pubDate>Thu, 29 Aug 2019 13:47:20 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=533</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:code -->
<pre class="wp-block-code"><code>
第三章类与对象
3.1 类的定义{
    3.1.1 类的定义{
        类: 将不同的数据和这些数据相关的操作封装在一起的集合体
        类包含两部分: 数据成员 和 成员函数
        注意 : 在类的定义中不能对数据成员直接进行初始化(尽管程序可以运行)
        成员函数的写法{
            1.放在class中 : void 函数名() (自动视为内联函数) 
            2.放在class外 : void 类名::函数名()
        }
        访问属性
        访问权限修饰符/访问控制修饰符 : public,private,protected
        private 私有成员 只允许该类的成员和友元访问, 不能被其他函数访问
        protected 保护成员 既允许该类的成员函数和友元访问, 又允许其派生类的成员函数访问
        public 公有成员 既允许该类的成员函数访问, 也允许类外部的其他函数访问
        class 和 struct 的区别, 结构体默认访问属性为public , 类默认访问属性为private.
    }
    3.1.2 定义对象{
        对象是类的实例或实体,类本身是抽象的,只有定义了对象,系统才会给对象分配相应的储存空间
    }
    3.1.3 this指针{
        this指针用来存放当前对象的地址,从而使得不同对象调用同意成员函数所处理的是自己的数据成员,不会造成混乱
    }
}
3.2 构造函数和析构函数{
    属性均必须为public.
    构造函数 : 在定义类的对象时,为其所属类分配储存空间,并初始化
    析构函数 : 在对象身份期结束时,完成对象存储空间的回收和相关的善后事务
    3.2.1 构造函数{
        1.如果构造函数有实际参数表,那么在创建对象时就必须要给出构造函数需要的实际参数表:{
            形式1:
            class{
                Date(int ,int )
            }
            ...
            Date today(1,5);
            -----------------
            形式2:
            class{
                Date()
            }
            ...
            Date today;
        }                 
        下面这条语句:                       
            today = Date(2,3);
        构造函数无法直接调用,只能在创建对象时自动调用,而这一句是在定义一个无名对象.
        2.任何类的对象在建立时必定要自动调用构造函数,如果没有程序员定义的构造函数,系统将会默认构造函数,其作用就只有分配空间,该函数无任何参数和语句,空壳子.
        构造函数可重载.
        3.具有默认参数值的构造函数 : Date(int a = 1 ,int b = 2) ,此时传入0个,1个或2个参数均可.
        4.构造拷贝函数 : Date(const Date &amp; d)
        构造拷贝函数是一类特殊的构造函数,它能够用一个已知的对象初始化另一方个新建的同类新对象.
        用户可以根据需要定义自己的拷贝构造函数,从而实现同类对象之间数据成员的值传递
        注意! : Date d2 = d1 ; 等效于 Date d2(d1); 这不是一个赋值语句!!!
        d2 = d1; 才是一个赋值语句
        此处注意到 : 没有写拷贝构造函数 Date d2 = d1; 也成功运行,百度后得知:编译器也能默认生成拷贝构造函数,此处进行浅拷贝.
        >>>浅拷贝/深拷贝后面将会学到,先搁置
        调用拷贝构造函数的三种情况{
            1.明确表示有一个对象初始化另一个对象 : Date d2(d1);
            2.当对象作为参数的实际参数传递给函数的值形式参数(注意,如果形式参数是引用参数或指针参数,都不会调用拷贝构造函数,因为此时不会产生新对象) :Date f(Date d) {...}
            3.当对象作为函数返回值
        }
    }
    3.2.2 析构函数{
        形式{
            类内:
                ~类名();
            类外:
                类名::~类名(){...}
        }
        析构函数无形式参数,并且不能被重载
        自动调用
        两种情况下调用{
            1.对象生存期结束时
            2.对用new运算符动态创建的对象,再用delete释放时.(别忘了,free/malloc在析构/构造函数中不能用!)
        }
        一般用默认的析构函数就可以了,但是,当类中有指针类型的数据成员,并且在构造函数中用该指针申请了空间,此时一定要自定义析构函数来释放这些空间,保证对象生存期结束时,所有空间被释放了!
    }
}
3.3 深拷贝与浅拷贝{
    浅拷贝造成指针悬挂问题:两个同类对象,类中有指针,并且构造函数为指针变量申请了空间,浅拷贝时,两个对象中的指针变量指向同一块地址,一旦,其中一个对象调用了析构函数,该地址空间被释放,另一个对象的指针成员变量就无法访问该空间了,从而导致出错.
    解决方法 : 深拷贝 : 另外申请动态空间后,再复制对应动态空间中的内容.(new)
}
3.4 对象的使用{
    ......;
}
3.5 友元{
    友元的三种形式{
        1.一个不属于任何类的普通函数声明为当前类的友元,称为当前类的友元函数
        2.一个其他类的成员函数声明为当前类的友元,称为当前类的友元成员
        3.另一个类声明为当前类的友元,称为当前类的友元类
    }
    3.5.1 友元函数{
        friend 函数返回类型 函数名 (形式参数表)
        友元函数要在类内给出声明(之后定义时,不能再加friend),或者直接给出定义,不受访问属性的约束.
    }
    3.5.2 友元成员{
        friend void Date::diaplay(const Student &amp;);
        友元成员不仅可以访问自己所在类的所有成员,也可以访问friend声明所在类的所有成员,这样,可以使两个类共享数据,相互合作.
    }
    3.5.3 友元类{
        friend 类名;
        友元关系是单向的,也不存在传递性.
    }
    使用友元可以避免频繁的调用接口函数,提高程序运行速度和运行效率.
}
3.6 程序实例-学生信息管理系统

2019-8-29</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>533</wp:post_id>
		<wp:post_date><![CDATA[2019-08-29 21:47:20]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-08-29 13:47:20]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[oop-c%e7%ac%94%e8%ae%b0-2]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="oop-c"><![CDATA[基础__OOP-C++]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>OOP-C++笔记-3</title>
		<link>https://sdnuqp.cn/oop-c%e7%ac%94%e8%ae%b0-3/</link>
		<pubDate>Sat, 31 Aug 2019 05:18:56 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=537</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:code -->
<pre class="wp-block-code"><code>
第四章 类中数据的共享与保护

4.1 静态成员{
    4.1.1 静态数据成员{
        static 类型名 静态数据成员名;
        作用: 同一个类共享此成员, 并且类外无法访问, 又保证了数据的安全性
        特点 : {
            1. 它在类的任何对象创建之前就已经存在,不能由构造函数初始化, 必须 在类的定义结束之后进行,默认值为0.静态数据成员是在编译时创建并初始化的.
            2. 共有的静态数据成员可以在类的对象定义之前被访问.
            3. 私有的静态数据成员不能被类的外部函数访问,也不能用对象名直接进行访问,而需要对象 调用 操作该数据成员的共有函数 进行.
        }
    }
    4.1.2 静态成员函数 {
        static 返回值类型 静态成员函数名(形式参数表);
        静态成员函数 在只能访问静态数据成员,不能对类的其他类型的数据成员或成员函数进行访问.
    }
}
4.2 共享数据的保护{
    4.2.1 常数据成员{
        const 类型名 常数据成员名;
        注意 : 常数据成员的初始化只能在构造函数的初始化列表中进行,不能再构造函数的函数体中实现.
        Circle(double r = 0) : PI(3.14) {...;}
    }
    4.2.2 常成员函数 {
        如果一个成员函数对类中数据成员只作访问而不直接或间接修改,则最好将该成员函数说明为常数据成员,以明确表示它对水据成员的保护性
        类型 函数名(形式参数表) const;
        注意 : const 可以作为与其他成员函数重载的标志,例 : void p(); 和 void p() const; 二者均是正确的重载函数.
        常成员函数不能修改本类的数据成员,因此也不能调用该类中未经const修饰的普通成员函数,普通成员函数可以调用常成员函数.
    }
    4.2.3  常对象 {
        在定义常对象时必须进行初始化.
        常对象只能调用它的常成员函数而不能调用普通的成员函数.
    }
}
4.3 程序实例--学生信息管理系统
</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>537</wp:post_id>
		<wp:post_date><![CDATA[2019-08-31 13:18:56]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-08-31 05:18:56]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[oop-c%e7%ac%94%e8%ae%b0-3]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="oop-c"><![CDATA[基础__OOP-C++]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>Codefroces-906-D-欧拉降幂</title>
		<link>https://sdnuqp.cn/codefroces-906-d-%e6%ac%a7%e6%8b%89%e9%99%8d%e5%b9%82/</link>
		<pubDate>Tue, 03 Sep 2019 12:10:18 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=539</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>裸(水)题,虽然刚开始我也不会.......</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>2019ICPC区域赛南京站网络赛有一个类似的题,只不过那个题要通过给你的函数看出要求什么,虽然很复杂的一个函数和描述,但是能发现答案是其实是幂塔函数取模,就是a^a^a^a^a........mod m .</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>这个题是要求 a[1] ^ a[2] ^ a[3] ^ a[4] ^ a[5] ^ ....... .</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>这两个题降幂部分是一样的 , 但是求欧拉函数的方式却不一样, 所以两个题都值得去当成模板 . </p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>此题欧拉函数要通过O(根号(n))的算法求出 , 因为这个题mod的最大值是1e9.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>只能实时计算mod,而无法打表存下来,但是每次都计算会TLE在23个样例上,所以要用map随时存下来,这样可以省去很多时间.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>那个题mod的最大值是1e6 ,可以通过素数表的方式打出表.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>AC code :</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>

#pragma warning (disable : 4996)

#include &lt;cstdio>
#include &lt;map>
using namespace std;
#define rep(i,a,b) for(int i = a ; i &lt;= b ; ++i)
const int maxn = 1e5 + 10;
using ll = long long;

map&lt;ll, ll > mp;
int a[maxn], p[maxn];

ll phi(int n) {
    if (mp.count(n) == 1)
        return mp[n];
    ll ans = n;
    for (int i = 2; i * i &lt;= n; i++) {
        if (n % i == 0) {
            ans -= ans / i;
            while (n % i == 0)
                n /= i;
        }
    }
    if (n > 1) ans -= ans / n;
    return mp[n] = ans;
}

ll mod(ll x, ll m) {
    return x &lt; m ? x : x % m + m;
}

ll power(ll a, ll b, ll m) {
    ll ans = 1;
    while (b) {
        if (b &amp; 1)
            ans = mod(ans * a, m);
        a = mod(a * a, m);
        b >>= 1;
    }
    return ans;
}

ll dfs(ll l, ll r, ll m) {
    if (m == 1)
        return 1;
    if (l == r)
        return a[l];
    ll res = dfs(l + 1, r , phi(m));
    return power(a[l] , res , m);
}

int main() {
    int n;
    ll l, r, m;
    scanf("%d %lld", &amp;n, &amp;m);
    rep(i, 1, n) {
        scanf("%d", &amp;a[i]);
    }
    int t;
    scanf("%d", &amp;t);
    rep(i, 1, t) {
        scanf("%lld %lld", &amp;l, &amp;r);
        ll x = dfs(l, r, m) % m ;
        printf("%d\n",x);
    }
    return 0;
}</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>539</wp:post_id>
		<wp:post_date><![CDATA[2019-09-03 20:10:18]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-09-03 12:10:18]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[codefroces-906-d-%e6%ac%a7%e6%8b%89%e9%99%8d%e5%b9%82]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e6%95%b0%e8%ae%ba-%e6%ac%a7%e6%8b%89%e5%87%bd%e6%95%b0%e5%ae%9a%e7%90%86"><![CDATA[数论___欧拉函数&amp;定理]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>2019ICPC区域赛南京站网络赛 - B题 - 欧拉降幂</title>
		<link>https://sdnuqp.cn/2019icpc%e5%8c%ba%e5%9f%9f%e8%b5%9b%e5%8d%97%e4%ba%ac%e7%ab%99%e7%bd%91%e7%bb%9c%e8%b5%9b-b%e9%a2%98-%e6%ac%a7%e6%8b%89%e9%99%8d%e5%b9%82/</link>
		<pubDate>Tue, 03 Sep 2019 12:17:27 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=541</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>首先要通过给你的"诡异"的公式看出 , 实际上要求幂塔函数 a^a^a^a (b个) mod m.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>实际上是个裸题,可惜我不会.....排名从106 一直掉到500多....</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>这里欧拉函数是用素数筛的方式提前打表,关于欧拉函数,会单独写篇博客.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>对比另一道题. codefroces 906 D</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>

#pragma warning(disable : 4996)

#include &lt;bits/stdc++.h>
using namespace std;
using ll = long long;
const int maxn = 1e6 + 10;

int m[maxn], phi[maxn], p[maxn], nump;

void get_prime() {
    phi[1] = 1;
    for (int i = 2; i &lt;= maxn; ++i) {
        if (!m[i]) {
            p[++nump] = i;
            phi[i] = i - 1;
        }
        for (int j = 1; j &lt;= nump &amp;&amp; p[j] * i &lt;= maxn; ++j) {
            m[p[j] * i] = 1;
            if (i % p[j] == 0) {
                phi[p[j] * i] = phi[i] * p[j];
                break;
            }
            else
                phi[p[j] * i] = phi[i] * (p[j] - 1);
        }
    }
}

ll mod(ll x, ll m) {
    return x &lt; m ? x : x % m + m;
}

ll power(ll a, ll b, ll m) {
    ll ans = 1;
    while (b) {
        if (b &amp; 1)
            ans = mod(ans*a , m);
        a = mod(a * a, m);
        b >>= 1;
    }
    return ans;
}

ll dfs(int a ,int b ,int m) {
    if (b == 0)
        return 1;
    if (m == 1)
        return a;
    ll res = dfs(a, b - 1, phi[m]);
    return power(a, res, m);
}

int main() {
    get_prime();
    int T;
    ll a, b, m;
    scanf("%d",&amp;T);
    while(T--) {
        scanf("%lld %lld %lld",&amp;a,&amp;b,&amp;m);
        ll x = dfs(a,b,m) % m;
        printf("%lld\n",x);
    }
    return 0;
}


/*

5
2 0 3
3 1 2
3 1 100
3 2 16
5 3 233

*/</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>541</wp:post_id>
		<wp:post_date><![CDATA[2019-09-03 20:17:27]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-09-03 12:17:27]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[2019icpc%e5%8c%ba%e5%9f%9f%e8%b5%9b%e5%8d%97%e4%ba%ac%e7%ab%99%e7%bd%91%e7%bb%9c%e8%b5%9b-b%e9%a2%98-%e6%ac%a7%e6%8b%89%e9%99%8d%e5%b9%82]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e6%95%b0%e8%ae%ba-%e6%ac%a7%e6%8b%89%e5%87%bd%e6%95%b0%e5%ae%9a%e7%90%86"><![CDATA[数论___欧拉函数&amp;定理]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>欧拉函数,欧拉定理,拓展欧拉定理</title>
		<link>https://sdnuqp.cn/%e6%ac%a7%e6%8b%89%e5%87%bd%e6%95%b0%e6%ac%a7%e6%8b%89%e5%ae%9a%e7%90%86%e6%8b%93%e5%b1%95%e6%ac%a7%e6%8b%89%e5%ae%9a%e7%90%86/</link>
		<pubDate>Tue, 03 Sep 2019 12:41:04 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=543</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:code -->
<pre class="wp-block-code"><code>
1.欧拉函数
2.欧拉定理
3.拓展欧拉定理
4.欧拉降幂

1.欧拉函数
Φ(n) = 小于等于n的与n互质的数的数量 (Φ(1) = 1)
计算公式:Φ(n) = ∏(p - 1)p^(a[p] - 1) = n∏(1 - 1/p);
if(n&amp;1) Φ(n) = n-1;
if(n&amp;1 &amp;&amp; b mod a == 0) Φ(a*b) = Φ(b) * a;
if(gcd(a,b) == 1) Φ(a*b) = Φ(a) * Φ(b);
编程实现:

方法1 素数表法:

#include &lt;bits/stdc++.h>
using namespace std;
const int maxn = 1e5;

int m[maxn], phi[maxn], p[maxn], nump;

void get_prime() {
    phi[1] = 1;
    for (int i = 2; i &lt;= maxn; ++i) {
        if (!m[i]) {
            p[++nump] = i;
            phi[i] = i - 1;
        }
        for (int j = 1; j &lt;= nump &amp;&amp; p[j] * i &lt;= maxn; ++j) {
            m[p[j] * i] = 1;
            if (i % p[j] == 0) {
                phi[p[j] * i] = phi[i] * p[j];
                break;
            }
            else
                phi[p[j] * i] = phi[i] * (p[j] - 1);
        }
    }
}

int main() {
    get_prime();
    for (int i = 1; i &lt;= 10; i++)
        printf("%d ",phi[i]);
    return 0;
}

方法2 根号(n) 暴力:

ll Euler(int n) {
    ll ans = n;
    for (int i = 2; i * i &lt;= n; i++) {
        if (n % i == 0) {
            ans -= ans / i;
            while (n % i == 0)
                n /= i;
        }
    }
    if (n > 1) ans -= ans / n;
    return ans;
}
方法3 递推 :

#pragma warning (disable : 4996)

#include &lt;bits/stdc++.h>
using namespace std;
const int maxn = 1e5;
#define rep(i,a,b) for(int i = a ; i &lt;= b ; ++i)

int phi[maxn];

void Euler() {
    rep(i, 1, maxn)
        phi[i] = i;
    rep(i, 2, maxn)
        phi[i++] /= 2;
    rep(i, 3, maxn) {
        if (phi[i] == i) {
            rep(j, i, maxn) {
                phi[j] -= phi[j] / i;
                j += i - 1;
            }
        }
        i++;
    }
}

int main() {
    Euler();
    rep(i, 1, 10)
        printf("%d ",phi[i]);
    return 0;
}

2.欧拉定理 

欧拉定理 : 当a,m互质时,a^Φ(m) ≡ 1 (mod m);
费马小定理 : 当m为质数且a不为m的倍数时,a^(m-1) ≡ 1 (mod m);

3.拓展欧拉定理

a^c = a^(c mod Φ(m)) , gcd(a,m) = 1;
    = a^c            , gcd(a,m) != 1 &amp;&amp; c &lt; Φ(m)
    = a^((c mod Φ(m)) + Φ(m)) , gcd(a,m) != 1, c >= Φ(m)
    </code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>543</wp:post_id>
		<wp:post_date><![CDATA[2019-09-03 20:41:04]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-09-03 12:41:04]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%ac%a7%e6%8b%89%e5%87%bd%e6%95%b0%e6%ac%a7%e6%8b%89%e5%ae%9a%e7%90%86%e6%8b%93%e5%b1%95%e6%ac%a7%e6%8b%89%e5%ae%9a%e7%90%86]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e6%95%b0%e8%ae%ba-%e6%ac%a7%e6%8b%89%e5%87%bd%e6%95%b0%e5%ae%9a%e7%90%86"><![CDATA[数论___欧拉函数&amp;定理]]></category>
		<category domain="post_tag" nicename="%e6%ac%a7%e6%8b%89%e5%87%bd%e6%95%b0"><![CDATA[欧拉函数]]></category>
		<category domain="post_tag" nicename="%e6%ac%a7%e6%8b%89%e5%ae%9a%e7%90%86"><![CDATA[欧拉定理]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>通过学生邮箱永久白嫖JB软件(链接)</title>
		<link>https://sdnuqp.cn/%e9%80%9a%e8%bf%87%e5%ad%a6%e7%94%9f%e9%82%ae%e7%ae%b1%e6%b0%b8%e4%b9%85%e7%99%bd%e5%ab%96jb%e8%bd%af%e4%bb%b6%e9%93%be%e6%8e%a5/</link>
		<pubDate>Thu, 05 Sep 2019 13:08:08 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=548</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p><a href="https://solodance.top/2019/09/04/如何通过学生邮箱%EF%BC%88教育邮箱%EF%BC%89申请Jetbrains系列软件无限期试用/">https://solodance.top/2019/09/04/如何通过学生邮箱%EF%BC%88教育邮箱%EF%BC%89申请Jetbrains系列软件无限期试用/</a></p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>548</wp:post_id>
		<wp:post_date><![CDATA[2019-09-05 21:08:08]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-09-05 13:08:08]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e9%80%9a%e8%bf%87%e5%ad%a6%e7%94%9f%e9%82%ae%e7%ae%b1%e6%b0%b8%e4%b9%85%e7%99%bd%e5%ab%96jb%e8%bd%af%e4%bb%b6%e9%93%be%e6%8e%a5]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="sundry"><![CDATA[杂项]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>SDNUOJ-1000-1009</title>
		<link>https://sdnuqp.cn/sdnuoj-1000-1009/</link>
		<pubDate>Mon, 23 Sep 2019 13:15:23 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=553</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>自觉哦.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>1000:</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>#include&lt;stdio.h>
int main()
{
    int a,b;
    scanf("%d%d",&amp;a,&amp;b);
    {
        printf("%d\n",a+b);
    }
    return 0;
}</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>1001:</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>#include&lt;stdio.h>
int main()
{
    int a,b;
    while(scanf("%d%d",&amp;a,&amp;b)!=EOF)
    {
        printf("%d\n",a+b);
    }
    return 0;
}</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>1002:</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>#include&lt;stdio.h>
int main()
{
    int N;
    int a,b;
    int i=1;
    scanf("%d",&amp;N);
    while(i&lt;=N)
    {
        i++;
        scanf("%d%d",&amp;a,&amp;b);
        {
            printf("%d\n",a+b);
        }
    }
    return 0;
}</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>1003:</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>#include&lt;stdio.h>
int main()
{
    int a,b;
    while(scanf("%d%d",&amp;a,&amp;b)&amp;&amp;(a!=0&amp;&amp;b!=0))
    {
    printf("%d\n",a+b);
    }
    return 0;
}</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>1004:</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>#include&lt;stdio.h>
int main()
{
    int N,i,sum,a;
    while(scanf("%d",&amp;N)&amp;&amp;(N!=0))
    {
        sum=0;
        for(i=1;i&lt;=N;i++)
        {
            scanf("%d",&amp;a);
            sum+=a;
        }
        printf("%d\n",sum);
    }
    return 0;
}</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>1005:</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>#include&lt;stdio.h>
int main()
{
    int N,sum;
    int a,b,c;
    int i;
    scanf("%d",&amp;b);
    for(i=1;i&lt;=b;i++)
    {
        scanf("%d",&amp;N);
        sum=0;
        for(c=1;c&lt;=N;c++)
        {
            scanf("%d",&amp;a);
            sum+=a;
        }
        printf("%d\n",sum);
    }
    return 0;
}</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>1006:</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>#include&lt;stdio.h>
int main()
{
    int N,i,sum,a;
    while(scanf("%d",&amp;N)!=EOF)
    {
        sum=0;
        for(i=1;i&lt;=N;i++)
        {
            scanf("%d",&amp;a);
            sum+=a;
        }
        printf("%d\n",sum);
    }
    return 0;
}</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>1007:</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>#include&lt;stdio.h>
int main()
{
    int a,b;
    while(scanf("%d%d",&amp;a,&amp;b)!=EOF)
    {
        printf("%d\n\n",a+b);
    }
    return 0;
}</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>1008:</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>#include&lt;stdio.h>
int main()
{
    int N,sum;
    int a,b,c;
    int i;
    scanf("%d",&amp;b);
    for(i=1;i&lt;=b;i++)
    {
        scanf("%d",&amp;N);
        sum=0;
        for(c=1;c&lt;=N;c++)
        {
            scanf("%d",&amp;a);
            sum+=a;
        }
        printf("%d\n\n",sum);
    }
    return 0;
}</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>1009:</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>#include&lt;stdio.h>
int main()
{
    int n,m,i,a,sum;
    scanf("%d",&amp;n);
    scanf("%d",&amp;m);
    sum=0;
    for(i=1;i&lt;=n;i++)
    {
        scanf("%d",&amp;a);
        if(a>m)
        {
            sum=a+sum;
        }
    }
    printf("%d",sum);
    return 0;
}
</code></pre>
<!-- /wp:code -->

<!-- wp:code -->
<pre class="wp-block-code"><code></code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>553</wp:post_id>
		<wp:post_date><![CDATA[2019-09-23 21:15:23]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-09-23 13:15:23]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[sdnuoj-1000-1009]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="sdnuoj"><![CDATA[OJ__SDNUOJ]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>超简易贪吃蛇源码</title>
		<link>https://sdnuqp.cn/%e8%b6%85%e7%ae%80%e6%98%93%e8%b4%aa%e5%90%83%e8%9b%87%e6%ba%90%e7%a0%81/</link>
		<pubDate>Fri, 04 Oct 2019 12:18:49 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=556</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>闲来无事(不学算法??????)写了一个贪吃蛇小游戏,很简单的只是用了一个获取键盘事件的小函数而已.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>为了确定蛇的位置,蛇头复制4(蛇的长度),蛇尾赋值1,蛇身赋值3到2(如图),然后怎么动呢?每次蛇头移动一格,蛇身的值-1,但是这样时间复杂度高了,每次蛇移动都要循环一次去对蛇身改值,所以我打算放弃这种思路,改而去将蛇头移动后的位置直接赋值为原蛇头位置的值+1,这样就直接省去了蛇身的操作,仅仅更改蛇头,蛇尾即可,但是移动次数收到了限制,要在int范围内,不然就会分崩离析.....</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>对了,为甚么要对蛇每一节赋值,就是为了确定蛇尾的上一节,之后进行蛇尾坐标的更改.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>我的贪吃蛇只能动,还没有加上吃的操作,并且使用OOD写的,没用OOP.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>欢迎复制黏贴运行.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Code :</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>
#include &lt;bits/stdc++.h>
#include &lt;conio.h>
using namespace std;

bool vis[11][11];
int mp[11][11] = {
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 1, 2, 3, 4, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
};
int xt, yt, d = 4;
int xw, yw;

int judge(int x, int y) {
    if (x > 10 || x &lt;= 0 || y > 10 || y &lt;= 0 || vis[x][y])
        return 1;
    return 0;
}

int main() {
    int ch1, ch2;
    xt = 5, yt = 4;
    xw = 5, yw = 1;
    while (1) {
        cout &lt;&lt; xt &lt;&lt; yt &lt;&lt; '\n';
        if (judge(xt, yt)) {
            cout &lt;&lt; "YOU LOSE!";
            break;
        }
        if (_kbhit()) {
            ch1 = _getch();
            ch2 = _getch();
            //cout &lt;&lt; ch1 &lt;&lt; " " &lt;&lt; ch2 &lt;&lt; '\n';
            switch (ch2) {
            case 72:
                d = 1; //上
                break;
            case 80:
                d = 2; //下
                break;
            case 75:
                d = 3; //左
                break;
            case 77:
                d = 4; //右
            }
        }

        switch (d) {
        case 1:
            mp[xt - 1][yt] = mp[xt][yt] + 1;
            xt -= 1; //上
            break;
        case 2:
            mp[xt + 1][yt] = mp[xt][yt] + 1;
            xt += 1; //下
            break;
        case 3:
            mp[xt][yt - 1] = mp[xt][yt] + 1;
            yt -= 1; //左
            break;
        case 4:
            mp[xt][yt + 1] = mp[xt][yt] + 1;
            yt += 1; //右
        }
        //对尾巴进行操作
        if (mp[xw + 1][yw] == mp[xw][yw] + 1) {
            mp[xw][yw] = 0;
            xw = xw + 1;
        }
        else if (mp[xw - 1][yw] == mp[xw][yw] + 1) {
            mp[xw][yw] = 0;
            xw = xw - 1;
        }
        else if (mp[xw][yw + 1] == mp[xw][yw] + 1) {
            mp[xw][yw] = 0;
            yw = yw + 1;
        }
        else if (mp[xw][yw - 1] == mp[xw][yw] + 1) {
            mp[xw][yw] = 0;
            yw = yw - 1;
        }
        //输出mp
        cout &lt;&lt; d &lt;&lt; '\n';
        for (int i = 1; i &lt;= 10; i++) {
            for (int j = 1; j &lt;= 10; j++) {
                if (mp[i][j]) {
                    if (i == xt &amp;&amp; j == yt)
                        cout &lt;&lt; "O";
                    else
                        cout &lt;&lt; "o";
                }
                else
                    cout &lt;&lt; "#";
                //cout &lt;&lt; ' ';
            }
            cout &lt;&lt; '\n';
        }
        _sleep(100);
        system("cls");
    }
    return 0;
}</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>556</wp:post_id>
		<wp:post_date><![CDATA[2019-10-04 20:18:49]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-10-04 12:18:49]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e8%b6%85%e7%ae%80%e6%98%93%e8%b4%aa%e5%90%83%e8%9b%87%e6%ba%90%e7%a0%81]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="sundry"><![CDATA[杂项]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>费马小定理</title>
		<link>https://sdnuqp.cn/%e8%b4%b9%e9%a9%ac%e5%b0%8f%e5%ae%9a%e7%90%86/</link>
		<pubDate>Sun, 06 Oct 2019 11:09:04 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=560</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>....</p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>560</wp:post_id>
		<wp:post_date><![CDATA[2019-10-06 19:09:04]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-10-06 11:09:04]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e8%b4%b9%e9%a9%ac%e5%b0%8f%e5%ae%9a%e7%90%86]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e6%95%b0%e8%ae%ba__%e8%b4%b9%e9%a9%ac%e5%b0%8f%e5%ae%9a%e7%90%86"><![CDATA[数论__费马小定理]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>唯一分解定理</title>
		<link>https://sdnuqp.cn/%e5%94%af%e4%b8%80%e5%88%86%e8%a7%a3%e5%ae%9a%e7%90%86/</link>
		<pubDate>Sun, 06 Oct 2019 11:31:56 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=562</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:preformatted -->
<pre class="wp-block-preformatted">唯一分解定理（算术基本定理）
 证明：反证法，详见百度百科
 1.一个大于1的整数n，唯一分解式：n = p1^a1 * p2^a2 <em>…</em>pn^an
 2.正因数个数：sum = (1+a1)(1+a2)…(1+an)
 3.正因数之和：ans = (1 + p1^1 + p1^2 +…+ p1^a1)(1 + p2^1 +…+p2^a2)…(1 + pn^1 +…+ pn^an)
 4.gcd(a,b)<em>lcm(a,b) = a</em>b;(反用时，注意a*b是否会溢出！)

 code:

 #include &lt;bits/stdc++.h> 
 using namespace std;
 int n;
 int a[1010];
 int vis[1010];
 int main(){
     int n;
     scanf("%d",&amp;n);
     int cnt = 0;
     for(int i = 2 ; i &lt;= n ; i++){
         if(n%i == 0)
             vis[cnt] = i;
         while(n%i == 0){
             a[cnt]++;
         }
         cnt++;
     }
     for(int i = 0 ; i &lt; cnt-1 ; i++){
         printf("%d^%d * ",vis[i],a[i]);
     }
     printf("%d^%d\n",vis[i],a[i]);
     return 0;
 }</pre>
<!-- /wp:preformatted -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>562</wp:post_id>
		<wp:post_date><![CDATA[2019-10-06 19:31:56]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-10-06 11:31:56]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%94%af%e4%b8%80%e5%88%86%e8%a7%a3%e5%ae%9a%e7%90%86]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="unique-decomposition-theorem"><![CDATA[数论___唯一分解定理]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>Xtu-1260-Determinant-高斯消元+逆元+线代</title>
		<link>https://sdnuqp.cn/xtu-1260-determinant-%e9%ab%98%e6%96%af%e6%b6%88%e5%85%83%e9%80%86%e5%85%83%e7%ba%bf%e4%bb%a3/</link>
		<pubDate>Sun, 06 Oct 2019 11:47:53 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=564</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>这是2017年湘潭大学举办的一个大学生程序设计全国邀请赛的题目.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>xtu我搜了,根本搜不到,感觉已经凉了,比我们学校还凉.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>这个题出的非常好.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>高斯消元可以用来做两件事,一是线性方程组求解,而是求解矩阵的逆矩阵.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>这个题用到了第二种.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>先要转化一下,将n * (n-1)的矩阵补全成n * n的矩阵,之后求新矩阵的伴随矩阵,伴随矩阵的第一行就是题目的答案啊!(伴随矩阵要用逆矩阵求出来,|A| * A^-1 = A* , 而逆矩阵要通过矩阵初等变换求出来,当然要用Gauss消元了)</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>代码是别人的,自己懒的写了.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><a href="https://blog.csdn.net/crazy_calf/article/details/75270151" target="_blank" rel="noreferrer noopener" aria-label="（在新窗口打开）">大佬的博客</a></p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>

#include &lt;bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn = 205;
const ll mod = 1e9 + 7;
ll a[maxn][maxn], b[maxn][maxn];

ll inv_(ll a, ll k) {
    ll res = 1;
    while (k) {
        if (k &amp; 1) res = res * a % mod;
        a = a * a % mod;
        k >>= 1;
    }
    return res;
}
void solve(int n) {
    memset(b, 0, sizeof b);
    for (int i = 1; i &lt;= n; i++) b[i][i] = 1;
    ll det = 1;
    for (int i = 1; i &lt;= n; i++) {
        int t;
        for (t = i; t &lt;= n; t++) {
            if (a[t][i]) break;
        }
        if (t != i) det *= -1;
        for (int j = 1; j &lt;= n; j++) {
            swap(a[i][j], a[t][j]);
            swap(b[i][j], b[t][j]);
        }
        det = (det * a[i][i] % mod + mod) % mod;
        ll inv = inv_(a[i][i], mod - 2); //a[i][i]的逆元
        for (int j = 1; j &lt;= n; j++) {
            a[i][j] = inv * a[i][j] % mod;
            b[i][j] = inv * b[i][j] % mod;
        }
        for (int k = 1; k &lt;= n; k++) {
            if (k == i) continue;
            ll tmp = a[k][i];
            for (int j = 1; j &lt;= n; j++) {
                a[k][j] = (a[k][j] - a[i][j] * tmp % mod + mod) % mod;
                b[k][j] = (b[k][j] - b[i][j] * tmp % mod + mod) % mod;
            }
        }
    }
    det = (det + mod) % mod;
    for (int i = 1; i &lt;= n; i++) {
        for (int j = 1; j &lt;= n; j++) {
            b[i][j] = det * b[i][j] % mod;  //将b由逆矩阵变成伴随矩阵
        }
    }
}
int main(void) {
    int n;
    while (scanf("%d", &amp;n) != EOF) {
        for (int i = 1; i &lt;= n; i++) a[1][i] = 1;
        for (int i = 2; i &lt;= n; i++)
            for (int j = 1; j &lt;= n; j++)
                scanf("%lld", &amp;a[i][j]);
        solve(n);
        for (int i = 1; i &lt;= n; i++)
            printf("%lld%c", (i &amp; 1 ? b[i][1] : (mod - b[i][1]) % mod), i == n ? '\n' : ' ');
    }
    return 0;
}
</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>564</wp:post_id>
		<wp:post_date><![CDATA[2019-10-06 19:47:53]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-10-06 11:47:53]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[xtu-1260-determinant-%e9%ab%98%e6%96%af%e6%b6%88%e5%85%83%e9%80%86%e5%85%83%e7%ba%bf%e4%bb%a3]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e6%95%b0%e8%ae%ba__%e9%ab%98%e6%96%af%e6%b6%88%e5%85%83"><![CDATA[数论__高斯消元]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>不挂VPN登录Pixiv</title>
		<link>https://sdnuqp.cn/%e4%b8%8d%e6%8c%82vpn%e7%99%bb%e5%bd%95pixiv/</link>
		<pubDate>Fri, 11 Oct 2019 07:33:35 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=572</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>首先,下载该文件夹,并解压到C盘中.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>链接：https://pan.baidu.com/s/1tdxRrIqa4pzK4LVhj-X-4w <br> 提取码：aoe9</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>第二步,更改host文件,将文件夹中的host文件替换你的host,host文件一般在C/windows/system32/drivers/etc.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>第三步,安装证书,注意中途选择添加到信任的整数.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>最后,打开Nginx反向代理服务器,如果嫌麻烦可以将Ngnix添加到开机启动项.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>输入pixiv.net.........不可描述.</p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>572</wp:post_id>
		<wp:post_date><![CDATA[2019-10-11 15:33:35]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-10-11 07:33:35]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e4%b8%8d%e6%8c%82vpn%e7%99%bb%e5%bd%95pixiv]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="stl"><![CDATA[基础__STL]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>splay伸展树指针+数组模板</title>
		<link>https://sdnuqp.cn/splay%e4%bc%b8%e5%b1%95%e6%a0%91%e6%8c%87%e9%92%88%e6%95%b0%e7%bb%84%e6%a8%a1%e6%9d%bf/</link>
		<pubDate>Thu, 05 Dec 2019 12:30:22 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=579</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:code -->
<pre class="wp-block-code"><code>//#pragma GCC optimize("O3")
//#include &lt;bits/stdc++.h>
//#define N 100005
//#define inf 1000000005
//using namespace std;
//inline int read()
//{
//    register int x = 0, f = 1; register char ch = getchar();
//    while (ch &lt; '0' || ch>'9') { if (ch == '-')f = -1; ch = getchar(); }
//    while (ch >= '0' &amp;&amp; ch &lt;= '9')x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0', ch = getchar();
//    return x * f;
//}
//inline void write(register int x)
//{
//    if (!x)putchar('0'); if (x &lt; 0)x = -x, putchar('-');
//    static int sta[36]; int tot = 0;
//    while (x)sta[tot++] = x % 10, x /= 10;
//    while (tot)putchar(sta[--tot] + 48);
//}
//struct node
//{
//    int v;
//    int fa;
//    int ch[2];
//    int rec;
//    int sum;
//}tree[N];
//int tot;
//inline void update(register int x)
//{
//    tree[x].sum = tree[tree[x].ch[0]].sum + tree[tree[x].ch[1]].sum + tree[x].rec;
//}
//inline bool findd(register int x)
//{
//    return tree[tree[x].fa].ch[0] == x ? 0 : 1;
//}
//inline void connect(register int x, register int fa, register int son) //把x转为fa的son(son是0/1，表示左孩子或右孩子)
//{
//    tree[x].fa = fa;
//    tree[fa].ch[son] = x;
//}
//inline void rotate(register int x)
//{
//    int Y = tree[x].fa;
//    int R = tree[Y].fa;
//    int Yson = findd(x);
//    int Rson = findd(Y);
//    int B = tree[x].ch[Yson ^ 1];
//    connect(B, Y, Yson);
//    connect(Y, x, Yson ^ 1);
//    connect(x, R, Rson);
//    update(Y), update(x);
//}
//inline void splay(register int x, register int to)
//{
//    to = tree[to].fa;
//    while (tree[x].fa != to)
//    {
//        int y = tree[x].fa;
//        if (tree[y].fa == to)
//            rotate(x);
//        else if (findd(x) == findd(y))
//            rotate(y), rotate(x);
//        else
//            rotate(x), rotate(x);
//    }
//}
//inline int newpoint(register int v, register int fa)
//{
//    tree[++tot].fa = fa;
//    tree[tot].v = v;
//    tree[tot].sum = tree[tot].rec = 1;
//    return tot;
//}
//inline void Insert(register int x)
//{
//    int now = tree[0].ch[1];
//    if (tree[0].ch[1] == 0)
//    {
//        newpoint(x, 0);
//        tree[0].ch[1] = tot;
//    }
//    else
//    {
//        while (19260817)
//        {
//            ++tree[now].sum;
//            if (tree[now].v == x)
//            {
//                ++tree[now].rec;
//                splay(now, tree[0].ch[1]);
//                return;
//            }
//            int nxt = x &lt; tree[now].v ? 0 : 1;
//            if (!tree[now].ch[nxt])
//            {
//                int p = newpoint(x, now);
//                tree[now].ch[nxt] = p;
//                splay(p, tree[0].ch[1]);
//                return;
//            }
//            now = tree[now].ch[nxt];
//        }
//    }
//}
//inline int find(register int v)
//{
//    int now = tree[0].ch[1];
//    while (19260817)
//    {
//        if (tree[now].v == v)
//        {
//            splay(now, tree[0].ch[1]);
//            return now;
//        }
//        int nxt = v &lt; tree[now].v ? 0 : 1;
//        if (!tree[now].ch[nxt])
//            return 0;
//        now = tree[now].ch[nxt];
//    }
//}
//inline void delet(register int x)
//{
//    int pos = find(x);
//    if (!pos)
//        return;
//    if (tree[pos].rec > 1)
//    {
//        --tree[pos].rec;
//        --tree[pos].sum;
//    }
//    else
//    {
//        if (!tree[pos].ch[0] &amp;&amp; !tree[pos].ch[1])
//            tree[0].ch[1] = 0;
//        else if (!tree[pos].ch[0])
//        {
//            tree[0].ch[1] = tree[pos].ch[1];
//            tree[tree[0].ch[1]].fa = 0;
//        }
//        else
//        {
//            int left = tree[pos].ch[0];
//            while (tree[left].ch[1])
//                left = tree[left].ch[1];
//            splay(left, tree[pos].ch[0]);
//            connect(tree[pos].ch[1], left, 1);
//            connect(left, 0, 1);
//            update(left);
//        }
//    }
//}
//inline int rank(register int v)
//{
//    int pos = find(v);
//    return tree[tree[pos].ch[0]].sum + 1;
//}
//inline int arank(register int x)
//{
//    int now = tree[0].ch[1];
//    while (19260817)
//    {
//        int used = tree[now].sum - tree[tree[now].ch[1]].sum;
//        if (x > tree[tree[now].ch[0]].sum&amp;&amp; x &lt;= used)
//        {
//            splay(now, tree[0].ch[1]);
//            return tree[now].v;
//        }
//        if (x &lt; used)
//            now = tree[now].ch[0];
//        else
//            x -= used, now = tree[now].ch[1];
//    }
//}
//inline int lower(register int v)
//{
//    int now = tree[0].ch[1];
//    int ans = -inf;
//    while (now)
//    {
//        if (tree[now].v&lt;v &amp;&amp; tree[now].v>ans)
//            ans = tree[now].v;
//        if (v > tree[now].v)
//            now = tree[now].ch[1];
//        else
//            now = tree[now].ch[0];
//    }
//    return ans;
//}
//inline int upper(register int v)
//{
//    int now = tree[0].ch[1];
//    int ans = inf;
//    while (now)
//    {
//        if (tree[now].v > v&amp;&amp; tree[now].v &lt; ans)
//            ans = tree[now].v;
//        if (v &lt; tree[now].v)
//            now = tree[now].ch[0];
//        else
//            now = tree[now].ch[1];
//    }
//    return ans;
//}
//int main()
//{
//    int m = read();
//    while (m--)
//    {
//        int opt = read(), x = read();
//        if (opt == 1)
//            Insert(x);
//        else if (opt == 2)
//            delet(x);
//        else if (opt == 3)
//        {
//            write(rank(x));
//            printf("\n");
//        }
//        else if (opt == 4)
//        {
//            write(arank(x));
//            printf("\n");
//        }
//        else if (opt == 5)
//        {
//            write(lower(x));
//            printf("\n");
//        }
//        else
//        {
//            write(upper(x));
//            printf("\n");
//        }
//    }
//    return 0;
//}


#include &lt;bits/stdc++.h>
using namespace std;

class spnode {
public:
    spnode* l, * r, * f;
    int key;
    spnode(int k);
    void rightnode();
    void leftnode();
    static void splay(spnode* x, spnode* rt);
    spnode* find(int k);
    spnode* insert(int k);
    spnode* max();
    spnode* min();
    spnode* succ(int k);
    spnode* prev(int k);
    static spnode* join(spnode* x, spnode* y);
    static spnode* deletenode(spnode* x, spnode* y);
    static void split(int k, spnode* s, spnode*&amp; x, spnode*&amp; y);
};

spnode::spnode(int k) {
    key = k;
    l = r = f = NULL;
}

void spnode::rightnode() {
    spnode* y = f;
    f = y->f;
    if (f != NULL) {
        if (f->l == y)
            f->l = this;
        else
            f->r = this;
    }
    if (r != NULL)
        r->f = y;
    y->l = r;
    y->f = this;
    this->r = y;
}

void spnode::leftnode() {
    spnode* y = f;
    f = y->f;
    if (f != NULL) {
        if (f->l == y)
            f->l = this;
        else
            f->r = this;
    }
    if (l != NULL)
        l->f = y;
    y->r = l;
    y->f = this;
    this->l = y;
}

void spnode::splay(spnode *x, spnode *rt) {
    spnode* rtf = rt->f;
    while (x->f != rtf) {
        spnode* y = x->f;
        spnode* z = y->f;
        if (z == rtf) {
            if (y->l == x) x->rightnode();
            else x->leftnode();
        }
        else {
            if (y->l == x &amp;&amp; z->l == y) {
                y->rightnode();
                x->rightnode();
            }
            else if (y->l == x &amp;&amp; z->r == y) {
                x->rightnode();
                x->leftnode();
            }
            else if (y->r == x &amp;&amp; z->l == y) {
                x->leftnode();
                x->rightnode();
            }
            else {
                y->leftnode();
                x->leftnode();
            }
        }
    }
}

spnode* spnode::find(int k) {
    if (k == key) return this;
    if (k &lt; key) {
        if (l == NULL)
            return NULL;
        else
            l->find(k);
    }
    else {
        if (r == NULL)
            return NULL;
        else
            r->find(k);
    }
}

spnode* spnode::insert(int k) {
    if(k &lt;= key) {
        if (l == NULL) {
            l = new spnode(k);
            l->f = this;
            return l;
        }
        else
            return l->insert(k);
    }
    else {
        if (r == NULL) {
            r = new spnode(k);
            r->f = this;
            return r;
        }
        else
            return r->insert(k);
    }
}

spnode* spnode::deletenode(spnode *x ,spnode *rt) {
    splay(x, rt);
    spnode* a = x->l;
    spnode* b = x->r;
    delete x;
    if (a != NULL) a->f = NULL;
    if (b != NULL) b->f = NULL;
    if (a == NULL) return b;
    if (b == NULL) return a;
    return join(a, b);
}

spnode* spnode::max() {
    if (r == NULL)
        return this;
    else
        r->max();
}

spnode* spnode::min() {
    if (l == NULL)
        return this;
    else
        l->min();
}

spnode* spnode::prev(int k) {
    if (key &lt;= k) {
        if (r == NULL)
            return this;
        spnode* tmp = r->prev(k);
        if (tmp == NULL)
            return this;
        return tmp;
    }
    else {
        if (l == NULL)
            return NULL;
        return l->prev(k);
    }
}

spnode* spnode::succ(int k) {
    if (k &lt;= key) {
        if (l == NULL)
            return this;
        spnode* tmp = l->succ(k);
        if (tmp == NULL)
            return this;
        return tmp;
    }
    else {
        if (r == NULL)
            return NULL;
        return r->succ(k);
    }
}

spnode* spnode::join(spnode *x ,spnode *y) {
    spnode* p = x->max();
    splay(p, x);
    p->r = y;
    y->f = p;
    return p;
}

void spnode::split(int k, spnode* s, spnode*&amp; x, spnode*&amp; y) {
    spnode* p = s->find(k);
    splay(p, s);
    x = p->l;
    y = p->r;
} // 分离

int main() {
    
    return 0;
}
</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>579</wp:post_id>
		<wp:post_date><![CDATA[2019-12-05 20:30:22]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-12-05 12:30:22]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[splay%e4%bc%b8%e5%b1%95%e6%a0%91%e6%8c%87%e9%92%88%e6%95%b0%e7%bb%84%e6%a8%a1%e6%9d%bf]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="stl"><![CDATA[基础__STL]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>Codeforces-670C-离散化</title>
		<link>https://sdnuqp.cn/codeforces-670c-%e7%a6%bb%e6%95%a3%e5%8c%96/</link>
		<pubDate>Thu, 30 Jan 2020 08:39:40 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=586</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:code -->
<pre class="wp-block-code"><code>离散化之后排序, 统计每种语言人数

#include &lt;bits/stdc++.h>
using namespace std;
const int INF = 0x3f3f3f3f;
const int maxn = 2e6 + 10;

int n, m;
int a[maxn], b[maxn], c[maxn];
int sum[maxn];
int cnt;
int d[maxn];
int num[maxn];
int ct2;

int query(int x) {
    return lower_bound(num + 1, num + ct2 + 1, x) - num;
}

int main() {
    scanf("%d", &amp;n);
    for (int i = 1; i &lt;= n; i++) {
        scanf("%d", &amp;a[i]);
        d[++cnt] = a[i];
    }
    
    scanf("%d", &amp;m);
    for (int i = 1; i &lt;= m; i++) {
        scanf("%d", &amp;b[i]);
        d[++cnt] = b[i];
    }
    
    for (int i = 1; i &lt;= m; i++) {
        scanf("%d", &amp;c[i]);
        d[++cnt] = c[i];
    }

    sort(d + 1, d + cnt + 1);
    for (int i = 1; i &lt;= cnt; i++) {
        if (i == 1 || d[i] != d[i - 1])
            num[++ct2] = d[i];
    }
    
    for (int i = 1; i &lt;= n; i++) {
        int id = query(a[i]);
        sum[id]++;
    }
    
    int bmax = -1, cmax = -1, ans = 0;
    for (int i = 1; i &lt;= m; i++) {
        int x = query(b[i]);
        int y = query(c[i]);
        if (sum[x] > bmax) {
            bmax = sum[x], cmax = sum[y];
            ans = i;
        }
        else if(sum[x] == bmax){
            if (sum[y] > cmax) {
                bmax = sum[x], cmax = sum[y];
                ans = i;
            }
        }
    }
    printf("%d\n", ans);
    return 0;
}
</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>586</wp:post_id>
		<wp:post_date><![CDATA[2020-01-30 16:39:40]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2020-01-30 08:39:40]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[codeforces-670c-%e7%a6%bb%e6%95%a3%e5%8c%96]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="stl"><![CDATA[基础__STL]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>CodeForces-705C- 思维+模拟</title>
		<link>https://sdnuqp.cn/codeforces-705c-%e6%80%9d%e7%bb%b4%e6%a8%a1%e6%8b%9f/</link>
		<pubDate>Thu, 30 Jan 2020 09:03:12 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=588</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>只会暴力肯定无限超时, 要记录每一个的x值前面的第一个x值的位置. </p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>大佬的题解 : <a href="https://blog.csdn.net/codeblocksm/article/details/52230380">https://blog.csdn.net/codeblocksm/article/details/52230380</a></p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>#include &lt;bits/stdc++.h>
using namespace std;

const int N = 3 * 1e5 + 100;
int arr[N], tail[N], pre[N], vis[N];

int main()
{
    int n, q, id = 0, sum = 0, last = 0;
    scanf("%d%d", &amp;n, &amp;q);
    memset(tail, -1, sizeof(tail));
    memset(pre, -1, sizeof(pre));

    while (q--) {
        int op, x;
        scanf("%d%d", &amp;op, &amp;x);
        if (op == 1) {
            pre[++id] = tail[x];
            tail[x] = id;
            sum++;
        }
        else if (op == 2{
            int tmp = tail[x];
                while (tmp != -1 &amp;&amp; !vis[tmp]) {
                    vis[tmp] = true;
                        tmp = pre[tmp];
                        sum--;
                }
        }
        else {
            for (int i = last + 1; i &lt;= x; i++) {
                if (!vis[i]) {
                    sum--;
                    vis[i] = true;
                }
            }
            last = max(last, x);
        }
        printf("%d\n", sum);
    }
    return 0;
}</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>588</wp:post_id>
		<wp:post_date><![CDATA[2020-01-30 17:03:12]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2020-01-30 09:03:12]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[codeforces-705c-%e6%80%9d%e7%bb%b4%e6%a8%a1%e6%8b%9f]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="stl"><![CDATA[基础__STL]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>HDU-1364-DFS/dp</title>
		<link>https://sdnuqp.cn/hdu-1364-dfs-dp/</link>
		<pubDate>Fri, 31 Jan 2020 05:56:21 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=592</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>DFS暴力搜索每一个点就好了, dp优雅一些</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>
#include &lt;cstdio>
#include &lt;iostream>
#include &lt;algorithm>
using namespace std;
int lim;
int mp[150][150];
int n, m;
int lr[100017][2];
char ch[100017];
int ok(int x, int y){
    if (x &lt;= n &amp;&amp; x >= 1 &amp;&amp; y >= 1 &amp;&amp; y &lt;= m){
        if (mp[x][y] == 0)
            return 1;
    }
    return 0;
}

int dfs(int x, int y, int nw){
    if (!ok(x, y))
        return 0;
    if (nw == lim)
        return 1;
    if (ch[nw] == 'R'){
        for (int i = 1; i &lt; lr[nw][0]; i++){
            if (!ok(x, y + i))
                return 0;
        }
        for (int i = lr[nw][0]; i &lt;= lr[nw][1]; i++){
            if (!ok(x, y + i))
                break;
            if (dfs(x, y + i, nw + 1))
                return 1;
        }
    }
    if (ch[nw] == 'L'){
        for (int i = 1; i &lt; lr[nw][0]; i++){
            if (!ok(x, y - i))
                return 0;
        }
        for (int i = lr[nw][0]; i &lt;= lr[nw][1]; i++){
            if (!ok(x, y - i))
                break;
            if (dfs(x, y - i, nw + 1))
                return 1;
        }
    }
    if (ch[nw] == 'U'){
        for (int i = 1; i &lt; lr[nw][0]; i++){
            if (!ok(x - i, y))
                return 0;
        }
        for (int i = lr[nw][0]; i &lt;= lr[nw][1]; i++){
            if (!ok(x - i, y))
                break;
            if (dfs(x - i, y, nw + 1))
                return 1;
        }
    }
    if (ch[nw] == 'D')
    {
        for (int i = 1; i &lt; lr[nw][0]; i++){
            if (!ok(x + i, y))
                return 0;
        }
        for (int i = lr[nw][0]; i &lt;= lr[nw][1]; i++){
            if (!ok(x + i, y))
                break;
            if (dfs(x + i, y, nw + 1))
                return 1;
        }
    }
    return 0;
}

int main(){
    int t;
    scanf("%d", &amp;t);
    while (t--){
        scanf("%d%d", &amp;n, &amp;m);
        for (int i = 1; i &lt;= n; i++)
            for (int j = 1; j &lt;= m; j++)
                scanf("%d", &amp;mp[i][j]);
        int l, r;
        lim = 0;
        char c;
        while (scanf("%d%d", &amp;l, &amp;r), l || r){
            getchar();
            cin >> c;
            if (l > r)
                swap(l, r);
            lr[lim][0] = l;
            lr[lim][1] = r;
            ch[lim++] = c;
        }
        int ans = 0;
        for (int ii = 1; ii &lt;= n; ii++){
            for (int j = 1; j &lt;= m; j++){
                if (ok(ii, j) &amp;&amp; dfs(ii, j, 0))
                    ans++;
            }
        }
        printf("%d\n", ans);
    }
    return 0;
}</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>592</wp:post_id>
		<wp:post_date><![CDATA[2020-01-31 13:56:21]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2020-01-31 05:56:21]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu-1364-dfs-dp]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="stl"><![CDATA[基础__STL]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>HDU-1531-差分约束</title>
		<link>https://sdnuqp.cn/hdu-1531-%e5%b7%ae%e5%88%86%e7%ba%a6%e6%9d%9f/</link>
		<pubDate>Fri, 31 Jan 2020 06:01:43 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=594</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>做到hdu1364时搜题解, 第一篇题解竟然是个假的, 套着羊皮的狼, 作者标错题号了,顺便看看.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>题目很有意思, 但是.............显然不会, 滑稽.</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">差分约束:  如果一个系统由n个变量和m个约束条件组成，形成m个形如ai-aj≤k的不等式(i,j∈[1,n],k为常数),则称其为差分约束系统(system of difference constraints)。亦即，差分约束系统是求解关于一组变量的特殊不等式组的方法。</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>求解差分约束系统，可以转化成图论的单源最短路径（或最长路径）问题。 观察xj-xi&lt;=bk，会发现它类似最短路中的三角不等式d[v]&lt;=d[u]+w[u,v]，即d[v]-d[u]&lt;=w[u,v] [1]  。因此，以每个变量xi为结点，对于约束条件xj-xi&lt;=bk，连接一条边(i,j)，边权为bk。我们再增加一个源点s,s与所有定点相连，边权均为0。对这个图，以s为源点运行Bellman-ford算法（或SPFA算法），最终{d[i]}即为一组可行解。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>                                                                                                             -------百度词条</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>总之, 建图最重要.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><a href="https://www.cnblogs.com/liyinggang/p/5697436.html">https://www.cnblogs.com/liyinggang/p/5697436.html</a></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>大佬的code:</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>
#include &lt;cstdio>
#include &lt;iostream>
#include &lt;algorithm>
using namespace std;
int lim;
int mp[150][150];
int n, m;
int lr[100017][2];
char ch[100017];
int ok(int x, int y){
    if (x &lt;= n &amp;&amp; x >= 1 &amp;&amp; y >= 1 &amp;&amp; y &lt;= m){
        if (mp[x][y] == 0)
            return 1;
    }
    return 0;
}

int dfs(int x, int y, int nw){
    if (!ok(x, y))
        return 0;
    if (nw == lim)
        return 1;
    if (ch[nw] == 'R'){
        for (int i = 1; i &lt; lr[nw][0]; i++){
            if (!ok(x, y + i))
                return 0;
        }
        for (int i = lr[nw][0]; i &lt;= lr[nw][1]; i++){
            if (!ok(x, y + i))
                break;
            if (dfs(x, y + i, nw + 1))
                return 1;
        }
    }
    if (ch[nw] == 'L'){
        for (int i = 1; i &lt; lr[nw][0]; i++){
            if (!ok(x, y - i))
                return 0;
        }
        for (int i = lr[nw][0]; i &lt;= lr[nw][1]; i++){
            if (!ok(x, y - i))
                break;
            if (dfs(x, y - i, nw + 1))
                return 1;
        }
    }
    if (ch[nw] == 'U'){
        for (int i = 1; i &lt; lr[nw][0]; i++){
            if (!ok(x - i, y))
                return 0;
        }
        for (int i = lr[nw][0]; i &lt;= lr[nw][1]; i++){
            if (!ok(x - i, y))
                break;
            if (dfs(x - i, y, nw + 1))
                return 1;
        }
    }
    if (ch[nw] == 'D')
    {
        for (int i = 1; i &lt; lr[nw][0]; i++){
            if (!ok(x + i, y))
                return 0;
        }
        for (int i = lr[nw][0]; i &lt;= lr[nw][1]; i++){
            if (!ok(x + i, y))
                break;
            if (dfs(x + i, y, nw + 1))
                return 1;
        }
    }
    return 0;
}

int main(){
    int t;
    scanf("%d", &amp;t);
    while (t--){
        scanf("%d%d", &amp;n, &amp;m);
        for (int i = 1; i &lt;= n; i++)
            for (int j = 1; j &lt;= m; j++)
                scanf("%d", &amp;mp[i][j]);
        int l, r;
        lim = 0;
        char c;
        while (scanf("%d%d", &amp;l, &amp;r), l || r){
            getchar();
            cin >> c;
            if (l > r)
                swap(l, r);
            lr[lim][0] = l;
            lr[lim][1] = r;
            ch[lim++] = c;
        }
        int ans = 0;
        for (int ii = 1; ii &lt;= n; ii++){
            for (int j = 1; j &lt;= m; j++){
                if (ok(ii, j) &amp;&amp; dfs(ii, j, 0))
                    ans++;
            }
        }
        printf("%d\n", ans);
    }
    return 0;
}</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>594</wp:post_id>
		<wp:post_date><![CDATA[2020-01-31 14:01:43]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2020-01-31 06:01:43]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu-1531-%e5%b7%ae%e5%88%86%e7%ba%a6%e6%9d%9f]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="stl"><![CDATA[基础__STL]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>CodeForces-1242B-01MST</title>
		<link>https://sdnuqp.cn/codeforces-1242b-01mst/</link>
		<pubDate>Fri, 31 Jan 2020 06:32:08 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=596</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>这个题题意是: 给你一张图, 有n个点, 完全图, 有m条边边权1, 其余为0. 让你去求这个图最小生成树的边</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>这个题方法有很多, 用krusral的, dfs暴力, 贪心的都有, 可惜我都不会.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>决定看一下补图连通块个数,</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>图G的补图 : 通俗的来讲就是完全图K<sub>n</sub>去除G的边集后得到的图K<sub>n</sub>-G。在图论里面，一个图<em>G</em>的<strong>补图</strong>（complement）或者反面（inverse）是一个图有着跟<em>G</em>相同的点，而且这些点之间有边相连当且仅当在<em>G</em>里面他们没有边相连。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>另一个求补图连通块个数的题目 : <a href="https://www.cnblogs.com/NaVi-Awson/p/8682506.html">[Codeforces 920E]Connected Components?</a></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>这个题大佬code:</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><a href="https://www.cnblogs.com/NaVi-Awson/p/11823608.html">https://www.cnblogs.com/NaVi-Awson/p/11823608.html</a></p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>#include &lt;bits/stdc++.h>
#define pb push_back
using namespace std;
const int N = 100000+5;

int n, m, u, v, vis[N], undo[N], ans, lst[N], nxt[N];
vector&lt;int> to[N];
queue&lt;int> Q;

void delet(int x) {nxt[lst[x]] = nxt[x], lst[nxt[x]] = lst[x]; }
int main() {
    scanf("%d%d", &amp;n, &amp;m);
    for (int i = 1; i &lt;= m; i++)
        scanf("%d%d", &amp;u, &amp;v), to[u].pb(v), to[v].pb(u);
    nxt[0] = 1;
    for (int i = 1; i &lt; n; i++) lst[i+1] = i, nxt[i] = i+1;
    for (int i = 1; i &lt;= n; i++)
        if (!vis[i]) {
            ++ans; Q.push(i); vis[i] = 1; delet(i);
            while (!Q.empty()) {
                int u = Q.front(); Q.pop();
                for (auto v : to[u])
                    if (!vis[v]) undo[v] = 1;
                for (int j = nxt[0]; j; j = nxt[j])
                    if (undo[j] == 0) Q.push(j), vis[j] = 1, delet(j);
                    else undo[j] = 0;
            }
        }
    printf("%d\n", ans-1);
    return 0;   
}</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>596</wp:post_id>
		<wp:post_date><![CDATA[2020-01-31 14:32:08]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2020-01-31 06:32:08]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[codeforces-1242b-01mst]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="stl"><![CDATA[基础__STL]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>连通块个数-DFS/并查集</title>
		<link>https://sdnuqp.cn/%e8%bf%9e%e9%80%9a%e5%9d%97%e4%b8%aa%e6%95%b0-dfs-%e5%b9%b6%e6%9f%a5%e9%9b%86/</link>
		<pubDate>Fri, 31 Jan 2020 06:36:30 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=598</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>DFS板子:</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>
//图的DFS遍历 计算连通块数 
#include &lt;iostream>
#include &lt;cstdio>
#include &lt;vector>
#include &lt;cstring> 
using namespace std;
const int nmax = 1e5 + 10;
vector&lt;int> G[nmax];
int vis[nmax];//1已被访问 0未被访问 
//遍历连通块 

void DFS(int u) {
    vis[u] = true;
    for (int i = 0; i &lt; G[u].size(); i++) {
        int v = G[u][i];
        if (vis[v] == 0) {//如果该节点未被访问，则深度遍历 
            DFS(v);
        }
    }
}

int main(int argc, char** argv) {
    int n;//点数 
    int m;//边数
    while (cin >> n >> m) {
        memset(vis, 0, sizeof(vis));
        int u, v;
        for (int i = 0; i &lt; m; i++) {
            cin >> u >> v;
            G[u].push_back(v);
            G[v].push_back(u);
        }
        int blk = 0;
        //遍历整个图G
        for (int i = 1; i &lt;= n; i++) {
            if (vis[i] == 0) {
                DFS(i);//访问i所在的连通块 
                blk++;
            }
        }
        cout &lt;&lt; blk &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>并查集板子:</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>
#include &lt;bits/stdc++.h>
using namespace std;
const int nmax = 1010;

int father[nmax];
int isRoot[nmax];
int findFather(int u) {
    if (u == father[u]) return u;//u==father[u] √;u==findFtaher[u] x 
    else {
        int f = findFather(father[u]);
        father[u] = f;
        return f;
    }
}

void Union(int u, int v) {
    int fu = findFather(u);
    int fv = findFather(v);
    if (fu != fv) {
        father[fu] = fv;
    }
}
void init(int n) {
    for (int i = 1; i &lt;= n; i++) {
        father[i] = i;
        isRoot[i] = 0;
    }
}

int main(int argc, char** argv) {
    int t;
    while (cin >> t) {
        int n, m;//点数，边数 
        while (t--) {
            memset(father, 0, sizeof(father));
            memset(isRoot, 0, sizeof(isRoot));
            cin >> n >> m;
            init(n);
            int u, v;
            for (int i = 0; i &lt; m; i++) {
                cin >> u >> v;
                Union(u, v);
            }
            for (int i = 1; i &lt;= n; i++) {
                isRoot[findFather(i)]++;
            }
            int ans = 0;
            for (int i = 1; i &lt;= n; i++) {
                if (isRoot[i] != 0) {
                    ans++;
                }
            }
            cout &lt;&lt; ans &lt;&lt; endl;
        }
    }
    return 0;
}
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>板子来源: https://blog.csdn.net/qian2213762498/article/details/82020882</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>ORZ</p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>598</wp:post_id>
		<wp:post_date><![CDATA[2020-01-31 14:36:30]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2020-01-31 06:36:30]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e8%bf%9e%e9%80%9a%e5%9d%97%e4%b8%aa%e6%95%b0-dfs-%e5%b9%b6%e6%9f%a5%e9%9b%86]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="stl"><![CDATA[基础__STL]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>汇编语言学习(day1)</title>
		<link>https://sdnuqp.cn/%e6%b1%87%e7%bc%96%e8%af%ad%e8%a8%80%e5%ad%a6%e4%b9%a0day1/</link>
		<pubDate>Fri, 31 Jan 2020 06:40:30 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=600</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>写挂必备吗?</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">2020.01.30
 汇编语言的主体是汇编指令, 汇编指令是机器指令的助记符.
 mov ax,bx

 寄存器,嵌入到cpu中的内存
 汇编语言的组成:{
     1.汇编指令 机器码的助记符
     2.伪指令 由编译器执行
     3.其它符号 + - * / 由编译器识别
 }

 存储器基础知识
 1个存储单元可以存8位, 1Byte
 
cpu想要进行数据读写, 必须和外部器件(标准说法是芯片)进行三类信息的交互:{
     1.存储单元的地址(地址信息)
     2.器件的选择, 读或写命令(控制信息)
     3.读或写数据(数据信息)
 }
 
cpu与内存 传输电信号 通过导线: 称为总线(耳熟能详的词){
     1.地址总线
     2.数据总线
     3.控制总线
 }
 
老cpu: 8088(8位)cpu  8086(16位)cpu
 x86架构
 cpu管脚
 
1.地址总线{
     1.cpu是通过直至总线来指定地址的.
     2.地址总线上能存储多少个不同的新信息, cpu就能够对多少个存储单元进行寻址.(反映了cpu寻址能力, 我们常说的64位, 32位cpu就是它的寻址能力)
     3.64位cpu + 64位操作系统 + 64位软件
     4.从高位到低位读
     5.一个cpu有N根地址总线, 则可以说明这个cpu的地址总线宽度为N, 这个cpu最多能够寻找2的N次方个内存单元
 }

 2.数据总线{
     1.cpu与内存或其他器件之间的数据传送是通过数据总线来进行的.
     2.数据总线的宽度决定了cpu和外界的数据传送速度(类比公路, 更宽的路).
 }

 3.控制总线{
     1.不同控制线的集合, 前面两个也是.
     2.控制总线的宽度决定了cpu对外部器件的控制能力
     3.
 }

 &lt;&lt;c的缺陷与陷阱>>: 为何从0开始存储, 而不是1

 内存地址空间

 主板, 接口卡

 cpu对外界部件不能直接控制

 ram随机存储器 (:内存, …)
 rom只读存储器

1. 随机存储器ram
2. 装有BIOS的rom
3. 接口卡上的ram

 BIOS : Basic Input/Output System 基本输入输出系统
 主板和各类接口卡(网卡, 显卡, 声卡)都有BIOS.
 cpu将各种存储器只看成一个逻辑存储器
 8086cpu:{
     1. 00000 - 9FFFF : RAM主存储器地址空间
     2. A0000 - BFFFF 显存地址空间
     3. C0000 - FFFFF 各类ROM地址空间
 } 将物理地址抽象为逻辑地址

 
二. 寄存器(cpu工作原理)
2.0 概述{
     1. cpu内部通讯
     2. cpu主要有运算器, 控制器, 寄存器等器件,这些器件靠 内部总线 相连.
     3. 8086cpu有14个寄存器 : AX, BX, CX, DX, SI, DI, SP, BP, IP, CS, SS, DS, ES, PSW
 }

 2.1通用寄存器{
     1. 大部分cpu都有8个通用寄存器
     2.
 }

 2.2字在寄存器中的存储</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p></p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>600</wp:post_id>
		<wp:post_date><![CDATA[2020-01-31 14:40:30]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2020-01-31 06:40:30]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%b1%87%e7%bc%96%e8%af%ad%e8%a8%80%e5%ad%a6%e4%b9%a0day1]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="stl"><![CDATA[基础__STL]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>汇编语言学习(day2)</title>
		<link>https://sdnuqp.cn/%e6%b1%87%e7%bc%96%e8%af%ad%e8%a8%80%e5%ad%a6%e4%b9%a0day2/</link>
		<pubDate>Fri, 31 Jan 2020 06:41:20 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=602</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:preformatted -->
<pre class="wp-block-preformatted">二. 寄存器(cpu工作原理)
 概述{
     1. cpu内部通讯
     2. cpu主要有运算器, 控制器, 寄存器等器件,这些器件靠 内部总线 相连.
     3. 8086cpu有14个寄存器 : AX, BX, CX, DX, SI, DI, SP, BP, IP, CS, SS, DS, ES, PSW
 }
 2.1 通用寄存器{
     1. 大部分cpu都有8个通用寄存器(AX,BX,CX,DX,都可以分成两个8位寄存器, AX : AH(high高地址: 8 - 16) + AL(low低地址: 0 - 7))
     2. 一个字两个字节, 这个奇怪单位来源就可见一斑了.
 }
 2.2 字在寄存器中的存储{
     …
 }
 2.3 汇编指令{
     1. 不区分大小写, 大小写不敏感
     2. 几条指令{
         mov ax, 18 -> ax = 18      -> ax寄存器中的值赋值为18
         mov ah, 78 -> ah = 78      -> ah寄存器中的值赋值为78
         add ax, 8  -> ax = ax + 18 -> ax寄存器中的值+8
         mov ax, bx -> ax = bx      -> 将bx寄存器中的值送入ax寄存器
         add ax, bx -> ax = ax + bx -> 将ax, bx中的值相加, 然后赋给ax
     }
     3. 易错点1: 请看这条指令 mov bx, ax (ax = 8226H, bx = 8226H){
         8226H + 8226H = 1044CH, 是个5位数, 而十六位寄存器只能存4位, 所以bx = 044CH
         而多出来的一位1, 被存放到了其他地方, 以后再说. (姑且称为进制位存放寄存器)
     }
     4. 易错点2: 请看这条指令 add al,93H(al = 85H){
         前面说了, AL是AX的低位, 8位寄存器, 我们知道AX = AL + AH
         93H + 85H = 158H, 三位数, 类似第三条, 又是多出一位
         这个多出的1位, 不是! 不是! 不是! 存放在AH中, AL 和 AH虽然连着, 但规则没那么简单, 不要想当然.
         存放到了哪里, 以后再说.
     }
 }
 2.4 物理地址</pre>
<!-- /wp:preformatted -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>602</wp:post_id>
		<wp:post_date><![CDATA[2020-01-31 14:41:20]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2020-01-31 06:41:20]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%b1%87%e7%bc%96%e8%af%ad%e8%a8%80%e5%ad%a6%e4%b9%a0day2]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="stl"><![CDATA[基础__STL]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>hexo+github博客搭建全流程</title>
		<link>https://sdnuqp.cn/hexogithub%e5%8d%9a%e5%ae%a2%e6%90%ad%e5%bb%ba%e5%85%a8%e6%b5%81%e7%a8%8b/</link>
		<pubDate>Sat, 01 Feb 2020 18:53:43 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=606</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:code -->
<pre class="wp-block-code"><code>第一步:
首先需要git和node.js
git都有吧.
nodejs可以去官网nodejs.org下载
(不知道为啥nodejs/ch-zn中国官网下载超级慢, 去nodjs.org/en/下载正常...无语)

第二步:

win+r -> cmd

无脑输入指令:

npm install -g cnpm -registry=https:/registry.npm.taobao.org
npm是包管理器, 中国么, 有高墙的呢, 所以通过npm安装cnpm, 淘宝的镜像源,  会快很多.
这一步很快

cnpm install -g hexo
通过cnpm安装hexo
这一步也很快

mkdir blog
创建一个新的文件夹

cd blog
进入

hexo init
众所周知, init初始化的意思
这一步可能会卡住, 我卡了三个小时, 各种重试, 结果发现断了wifi, 连上手机热点, 1min就搞定了...无语

hexo s
start, 启动!!!
这时候可以去浏览器地址栏输入 localhost:4000
如果你进去了, 看见了hallo world
恭喜

第三步:

hexo n "第一篇博客"
new, 新建文章

hexo clean
清空旧的

hexo g
generate, 生成新的

hexo s
启动动动动动

去浏览器进blog看看是否有了新文章
如果有了
恭喜

第四步:
部署到服务器上

有钱人可以买个服务器
穷逼可以部署到github或者gitee(码云)
此码云非彼马云

去github建立一个新的仓库命名为: 你的用户名.github.io
必须这样命名!

成功建立好了
恭喜

第五步:

去cmd,
先安装一个插件

cnpm install --save hexo-deployer-git
安装插件

去blog文件夹中找到: _config.yml

记事本打开, 找到最后两行
改成:
deploy:
    type: git
    repo: 你的仓库地址(https://github.com/你的用户名/你的仓库名)
    branch: master

最后:
hexo d
将blog推送到github上

去github仓库中看一下, 有文件了
恭喜

第六步:

更改主题:
https://github.com/litten/hexo-theme-yilia

好看不亏
完事




</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>606</wp:post_id>
		<wp:post_date><![CDATA[2020-02-02 02:53:43]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2020-02-01 18:53:43]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[hexogithub%e5%8d%9a%e5%ae%a2%e6%90%ad%e5%bb%ba%e5%85%a8%e6%b5%81%e7%a8%8b]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="stl"><![CDATA[基础__STL]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_oembed_33dd70d4c2564c906e08602c2d480b55]]></wp:meta_key>
		<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>汇编语言学习(day3)</title>
		<link>https://sdnuqp.cn/%e6%b1%87%e7%bc%96%e8%af%ad%e8%a8%80%e5%ad%a6%e4%b9%a0day3/</link>
		<pubDate>Sun, 02 Feb 2020 16:27:51 +0000</pubDate>
		<dc:creator><![CDATA[wlkq]]></dc:creator>
		<guid isPermaLink="false">https://sdnuqp.cn/?p=608</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>明明是day3, 却已经过了12点....</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>2.9 - 2.12{
    1.cpu访问内存单元时, 必须向内存提供内存单元的物理地址
    2.一个物理地址能够分解为多个段地址 + 偏移地址
    3.描述: 数据在21F60H内存单元中:{
        1.数据存在内存2000:1F60单元中
        2.数据存在内存dd呃2000段中的1F60H中
    }
    4.可根据需要将地址连续,起始地址为16的倍数的一组内存单元定义为一个段.
    5.8086cpu有4个段寄存器: CS, DS, SS, ES. (现在的cpu多了)
    6.提供内存单元的段地址
    7.CS: 代码段寄存器 , 段地址
    8.IP: 指令指针寄存器 , 偏移地址
    9.8086cpu加电启动或者复位时, cs, ip分别被设置为 FFFFH, 0000H.
    10.如果内存中的一段信息曾被cpu执行过, 那么,它所在的内存单元必然被cs:ip指向过
    11.在cpu中, 程序员能够用指令读写的部件只有寄存器, 程序员可以通过改变寄存器中的内容实现对cpu的控制.
    12.cs, ip转移指令是不能通过mov指令更改的, cpu专门提供了专门的指令: 转移指令{
        jmp 2AE3:3 cs=2AE3, ip=3
        jmp 3:2AE3
        jmp ax 用ax中的值修改ip
    }
    13. 死循环导致死机
    14. 可以将一段长度为n &lt;= 64kb 的一组代码, 存在一组地址连续, 起始地址为16的倍数的内存单元中, 从而定义了一个代码段.
    15. cpu只认cs : ip指向的内存单元中的内容为指令
    16. 8086cpu工作过程{
        1. 从cs:ip指向的内存单元中读取指令, 读取的这段指令进入指令缓冲器,
        2. ip指向下一段指令
        3. 执行指令 , 转到步骤1, 重复
    }
}

Debug常用命令 {
    1.R ：查看更改cpu寄存器内容
    2.D：查看内存中内容
    3.E：改写内存中内容
    4.U：将内存中机器指令翻译成汇编指令
    5.T：执行一条机器指令
    6.A：以汇编格式在内存中写入一条指令
}

</code></pre>
<!-- /wp:code -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>608</wp:post_id>
		<wp:post_date><![CDATA[2020-02-03 00:27:51]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2020-02-02 16:27:51]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%b1%87%e7%bc%96%e8%af%ad%e8%a8%80%e5%ad%a6%e4%b9%a0day3]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="stl"><![CDATA[基础__STL]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpas_done_all]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_pingme]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_encloseme]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							</item>
				</channel>
</rss>
	